<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org story by Simon: Apocalypse 5 on Regular Expressions Posted</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Apocalypse 5 on Regular Expressions Posted</h1>
<h2><a href="/user/Simon/">Simon</a> on 2002-06-04T22:40:28</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>The <a href="http://dev.perl.org/perl6/apocalypse/">Apocalypses</a> are Larry's explanation of the design of Perl 6. <a href="http://www.perl.com/pub/a/2002/06/04/apo5.html">Apocalypse 5</a> deals with - or should I say, redesigns - regular expressions. Hang onto your hats, because this one is 24 pages long and will break a lot of your expectations...</p>
<p></p>


<hr/>



<h2>On breakage of various types</h2>
<h3><a href="/user/Damian/">Damian</a> on 2002-06-04T23:27:39</h3>
24 pages? It's only that long because the "pages" on perl.com are so very much shorter than they've ever been before. Perhaps you're responding to user requests for that or trying to distribute your server load differently? But the implication that Apocalypse 5 is unprecedentedly huge is just plain wrong: in line count A5 is within a few percent of A4.<br> <br>As for breaking expectations...we sure did! Assuming people expected regexes to continue to be an ad hoc accretion of vaguely incompatible syntaxes, obscure stand-alone features, and special cases.<nobr> <wbr></nobr><tt>;-)</tt> <br> <br>I mean, did people really expect Larry <em>wouldn't</em> take this unique opportunity to drag Perl regexes completely free from the syntactic and semantic mire into which they've slowly been sinking?<br> <br>Apocalypse 5 is Perl 6 in microcosm: throwing away the prototype and using the lessons learned to design a system that's integrated, rather than aggregated. <br> <br>Of course, there will almost certainly be issues and problems we've overlooked. That's why we'll be relying so heavily on the community's constructive feedback over the next few weeks. But fear, uncertainty, doubt, and xenophobia aren't likely to be helpful in that regard.



<blockquote>

<h2>KEKEK I HAXOR YR APOCLIPS!</h2>
<h3><a href="/user/TorgoX/">TorgoX</a> on 2002-06-05T03:03:58</h3>
<em>24 pages? It's only that long because the "pages" on perl.com are so very
   much shorter than they've ever been before.</em>

<p>I do wish they had a "printable version" link that'd dump the whole thing as simple HTML all on a single page.  But <a href="http://www.perl.com/pub/a/2002/06/04/apo5.html?page=all" title="perl.com">http://www.perl.com/pub/a/2002/06/04/apo5.html?page=all</a perl.com> works.</p>



<blockquote>

<h2>Re:KEKEK I HAXOR YR APOCLIPS!</h2>
<h3><a href="/user/TorgoX/">TorgoX</a> on 2002-06-05T04:05:42</h3>
It seems there <em>is</em> a "printable version" link, but it's rendered as a wee little icon that's off the side of my screen.  HTML is hard!





</blockquote>


<h2>Re:On breakage of various types</h2>
<h3><a href="/user/Simon/">Simon</a> on 2002-06-05T04:31:46</h3>
<i>But the implication that Apocalypse 5 is unprecedentedly huge is just plain wrong: in line count A5 is within a few percent of A4.</i>
<p>
<code>
 % wc -l a4.pod a5.pod<br>
   2175 a4.pod<br>
   2811 a5.pod
</code>
</p><p>
In word count, about 30% more. In byte code, about 40% more. And A4 wasn't small. Still, it depends on your definition of "a few"...</p>



<blockquote>

<h2>Re:On breakage of various types</h2>
<h3><a href="/user/Damian/">Damian</a> on 2002-06-05T05:51:53</h3>
In my view, line counts on marked-up source aren't particularly meaningful. I was reckoning by the counts on the visible text itself:<br> <br> <code> <br>% lynx -dump 'http://www.perl.com/pub/a/2002/06/04/apo5.html?page=all' &gt; a5.txt<br>% lynx -dump 'http://www.perl.com/pub/a/2002/01/15/apo4.html?page=all' &gt; a4.txt<br>% wc a[45].txt<br>2518  16682  104463  a4.txt<br>2768  18534  119403  a5.txt<br> </code> <br> <br>So in terms of readable content, A5 is 10% bigger by lines, 11% bigger by words, and 14% bigger by bytes. No big deal.



<h2>Re:On breakage of various types</h2>
<h3><a href="/user/jdavidb/">jdavidb</a> on 2002-06-05T12:56:37</h3>
<p>Where can I get a5 in pod?</p>



<blockquote>

<h2>Apocalypses in pod</h2>
<h3><a href="/user/pne/">pne</a> on 2002-06-10T11:39:47</h3>
It probably helps if you're an oreilly.com editor<nobr> <wbr></nobr>:)





</blockquote>

</blockquote>


<h2>Re:On breakage of various types</h2>
<h3><a href="/user/m2/">m2</a> on 2002-06-05T21:52:08</h3>
<blockquote><div>24 pages? It's only that long because the "pages" on perl.com are so very much shorter than they've ever been before.</div></blockquote>
<p>Yes, that's completly out of touch with reality.  <a href="http://www.perl.com/lpt/a/2002/06/04/apo5.html" title="perl.com">The one page, printable version</a perl.com> is 33 pages long on A4 paper...</p>





</blockquote>


<h2>See the Dark One's influence</h2>
<h3><a href="/user/autarch/">autarch</a> on 2002-06-04T23:42:26</h3>
I hope it does not escape people that an awful lot of the syntax looks like something from Parse::RecDescent.  Coincidence?  I think not!<br> <br>Seriously, it all looks very cool.  Simple regexes remain simple, while grammars becomes possible.  I like it.



<h2>First Reaction</h2>
<h3><a href="/user/samtregar/">samtregar</a> on 2002-06-05T00:06:53</h3>
Nirvana! Parse::RecDescent is dead and re-born in a new and glorious form. For the first time I'm actually anxious to use Perl 6.
<p>
Sure, all the changes will take time to get used to. But the result will be both cleaner and more powerful than what we have now.
</p><p>
-sam</p>



<blockquote>

<h2>Re:First Reaction</h2>
<h3><a href="/user/tzz/">tzz</a> on 2002-06-05T14:41:26</h3>
Dead?  I doubt it.  Parse::RecDescent could benefit from the new Perl 6 regex engine (both in internal implementation and in features passed to the user), but for writing grammars it is very different from what Perl 6 will offer.

At least, that's my hope.  Damian may have already started work on the<nobr> <wbr></nobr>:p-rd directive
<p><nobr> <wbr></nobr><code>:)</code></p>



<blockquote>

<h2>Re:First Reaction</h2>
<h3><a href="/user/Damian/">Damian</a> on 2002-06-06T07:33:44</h3>
Actually, having seen A5, you've seen the first draft of the new Parse::FastDescent syntax! Of course, P::FD will provide a large number of additional assertions (replicating P::RD's numerous handy directives), but the syntax and semantics will almost certainly be as close to A5 as possible.<br> <br>That way, P::FD can continue P::RD's role as a test-bed for Perl 6 regex/grammar features, as well as providing a migration path from Perl 5 to Perl 6.



<blockquote>

<h2>Re:First Reaction</h2>
<h3><a href="/user/tzz/">tzz</a> on 2002-06-06T13:37:49</h3>
I certainly hope backward compatibility is not completely lost, or at least we're given a way to port P::RD grammars to P::FD semi-automatically.



<blockquote>

<h2>Re:First Reaction</h2>
<h3><a href="/user/Damian/">Damian</a> on 2002-06-06T21:28:06</h3>
<i>I certainly hope backward compatibility is not completely lost...</i> <br> <br>I'm afraid so. <br> <br><nobr> <wbr></nobr><i>...or at least we're given a way to port P::RD grammars to P::FD semi-automatically.</i> <br> <br>Yes. One of the big tests of P::FD is whether I can build a P::RD metagrammar with it.





</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Oh shee-it</h2>
<h3><a href="/user/LunaticLeo/">LunaticLeo</a> on 2002-06-05T05:32:15</h3>
That is a big one to swallow.<br> <br>I like A5, but it is dramatic. It will piss off alot of hum-buggers.<br> <br>Mostly, it makes me wonder how long it will take to build perl6. Much of my apprehension is allieviated by the thought that perl6 will not show up in my lifetime<nobr> <wbr></nobr>:)<br>



<blockquote>

<h2>Re:Oh shee-it</h2>
<h3><a href="/user/Damian/">Damian</a> on 2002-06-05T06:02:43</h3>
<i>I like A5, but it is dramatic. It will piss off alot of hum-buggers.</i> <br> <br>You really think so? I can't think of any significant way in which Larry's proposal isn't a vast improvement on what we have now: more readable, more consistent, better optimized for the common cases, more powerful. What do you think they'll object to? (That's not a rhetorical question: I'd really like to know.)<br> <br> <i> Mostly, it makes me wonder how long it will take to build perl6. Much of my apprehension is allieviated by the thought that perl6 will not show up in my lifetime<nobr> <wbr></nobr>:)</i> <br> <br>Wow, I sincerely hope you're wrong about that! I'm expecting to see a usable beta some time next year, and I'd <i>hate</i> to think of you shuffling off this mortal coil so soon!<nobr> <wbr></nobr><tt>;-)</tt>



<blockquote>

<h2>Re:Oh shee-it</h2>
<h3><a href="/user/pudge/">pudge</a> on 2002-06-05T11:17:00</h3>
Well, if I were inclined to object, I would object about the fact that it is too different.  I don't, in general, like different.<br> <br>OK, that's an oversimplification, but I just woke up.  In any event, though, I am far more interested in the Perl syntax than the Perl regex syntax.  My primary concern with regexes is the learning curve and speed of execution.  It's a very dissimilar situation to Perl syntax itself, to my mind: I mean, how many people are really in love with Perl regex syntax, really?<br>



<h2>Re:Oh shee-it</h2>
<h3><a href="/user/Smylers/">Smylers</a> on 2002-06-05T13:52:58</h3>
<em>What do you think they'll object to?</em>

<p>Backwards compatibility with Perl 5 people can get used to, as they use less Perl 5.  Incompatibility with <code>egrep</code>, <code>vi</code>, <code>mod_rewrite</code>, <cite>et al</cite> could be harder to overcome.  They aren't all completely compatible at the moment, but at least things like character classes are similar.  I can see people not liking having to learn a completely different regexp syntax just for Perl.</p>

<p>It also depends on how many other languages pick up Perl 6 regexes.  It'd be bizarre to find Java and C++ coders disliking Perl because its regexes aren't what they're used to.</p>

<p>(Not me though &#8212; I think the new regexes are a great improvement.)</p>

<p>Smylers</p>



<blockquote>

<h2>Re:Oh shee-it</h2>
<h3><a href="/user/pne/">pne</a> on 2002-06-06T08:35:51</h3>
Yeah... character classes were also number one on my list of "things that I'll miss knowing how to do in Perl6".<br> <br>I know they'll still be there, but the syntax will be different -- and pretty much all other regex languages will still allow [aeiou], only Perl6 will require &lt;[aeiou]&gt; (or perhaps &lt;vowel&gt;?). So I won't be able to carry over my knowledge directly.



<blockquote>

<h2>Re:Oh shee-it</h2>
<h3><a href="/user/buckaduck/">buckaduck</a> on 2002-06-06T14:14:47</h3>
I actually think that <blockquote><div> <tt>&lt;vowel&gt;</tt> </div></blockquote> might be pretty cool. But how would you handle "sometimes Y"?
<p>
I suppose if any language could do it, Perl could...</p>





</blockquote>

</blockquote>


<h2>Re:Oh shee-it</h2>
<h3><a href="/user/ct/">ct</a> on 2002-06-05T15:36:05</h3>
I haven't read A5 yet as perl.com has just taken a nice nosedive.<p>

My reaction to the first four (though I usually need the Exegesis to make sense out of some bits<nobr> <wbr></nobr>:) has been, well, not negative so much as fearful.</p><p>

It may be perl, but it's clear that it's radically different. While I don't have a huge stack of legacy code I'm concerned about, I've done perl long enough that when I think of a problem, I think of it in perl. Changing the syntax of the language on me now would be like someone announcing "OK, new rules for the English Language, instead of adverbs ending in -ly, they now end in -o-rama. Quick-o-rama!".</p><p>

So for the first few Apoc's I kept thinking "Oh, hell, don't do that." Because it seemed like the language ingrained in my psyche was being disassembled before my eyes.</p><p>

But, reading a single article and evaluating it as a standalone entity is a bad thing. I'm slowly realizing that the language is being improved, and that to do that you need to touch a good sized chunk of the syntax and semantics of the language itself. While I'm not giddy at the thought of having to relearn the language, I'm now resigned to the fact that changes are coming. I'll be relearning SOMETHING, so we might as well change everything that needs fixing now.</p><p>

Just like ripping off a band-aid.</p>



<blockquote>

<h2>Re:Oh shee-it</h2>
<h3><a href="/user/m2/">m2</a> on 2002-06-05T23:05:39</h3>
<blockquote><div>I haven't read A5 yet as perl.com has just taken a nice nosedive.</div></blockquote>
<p>Remove the <tt>www</tt> from the URL.  http://perl.com/ works for me, http://www.perl.com/ doesn't. HTH.</p>





</blockquote>


<h2>Re:Oh shee-it</h2>
<h3><a href="/user/jaffray/">jaffray</a> on 2002-06-05T18:34:36</h3>
Many people perceive anything new as "more complicated", and have the reaction "oh, gawd, what a pain, I'll have to learn all this new junk, Larry and Damian are horrible people who want to make my life miserable for their own sadistic enjoyment".  You've seen this already with the reactions to A1-A4.<p>

Not much to be done, but a page or so of examples of the type "look how little most of your simple cases are going to change,<nobr> <wbr></nobr>.* isn't going anywhere, take a deep breath, everything's going to be fine, there there" might help appease them.  <em>Then</em> plunge into all the stuff that's changing and why it's so much better the new way.</p>



<h2>Re:Oh shee-it</h2>
<h3><a href="/user/felixgallo/">felixgallo</a> on 2002-06-05T19:53:40</h3>
When you say 'optimized', I don't think you mean what you think you mean.  It's syntactically optimized, which is good for some things, but time will tell how much slower the bells and whistles make the engine.  Time will also tell how many years we will continue to wait.<br> <br>This is either the best thing to happen to the regular expression engine since the invention of *, or the most profound and breathtaking example of Second System Effect since the invention of J2EE (or COM+ if you swing that way).



<blockquote>

<h2>Re:Oh shee-it</h2>
<h3><a href="/user/marklark/">marklark</a> on 2002-06-07T15:58:39</h3>
But, "syntactically optimized" might be just the thing!  I'm not going to get much faster or smarter in the future, but I'll almost certainly be using a faster computer with more memory.  <br> <br>So, if Perl 6 lets me be faster it should work out for the best.  <br> <br>Of course, I might behave like the majority of projects out there and just add more variables, more data, etc (think of the US National Weather Service), and end up still having a slow process.<br> <br>:^)





</blockquote>


<h2>Re:Oh shee-it</h2>
<h3><a href="/user/LunaticLeo/">LunaticLeo</a> on 2002-06-06T01:51:24</h3>
<i>You really think so? I can't think of any significant way in which Larry's proposal isn't a vast improvement on what we have now: more readable, more consistent, better optimized for the common cases, more powerful. What do you think they'll object to?</i>
<p>Again, I like it. In my mind, it is a whole New Thing(tm). It is lex-yacc replacement built into Perl, and intimately tied to Perl. Regex's have always been a language with a language. Clearly, Perl5 regexs were going in the grammer direction. However, I can't think of a lot of examples of using the (?...) constructs. And the examples I can think of were simple non-grammer non-rule based stuff. I've used it only to match strings "" but skiping \" tokens sorta naively.
</p><p>I think Larry Wall dramatically accepted that the regex inteligensia were trying to fit grammer-like constructs into Perl5 regexs. So he said this is a Good Thing(tm) but he wanted it Done Right(tm). But he had to sacrafice backward compatability and compatability/simmilarity with other regex engines. Character classes come to mind, so does having to escape ':', and whitespace is different (today's \s really should be \h in Perl6-A5 regexs).
</p><p>Other projects have been struggling to create Perl5 regexs as the needed extension to old-school unix extended regexs. Now that Perl6-A5 regexs are a whole new thing tied in with the perl language (ala<nobr> <wbr></nobr><code>/@foo<nobr> <wbr></nobr>:= (&lt;rule&gt;)+/</code> err some such construct).  For Java or Python to have Perl6 regexes seems improbable mabe even impossible.
</p><p>What I would like to see possible is to consider both Perl6 and Perl5 regexs first class citizens in Perl6. That means that we don't need to <code>use P5::Regex; ($foo) = $str =~<nobr> <wbr></nobr>/([[:alpha:]]+)/; no P5::Regex;</code>. Instead we can have, like Larry indicated, <code>($foo) = $str =~ s:p5<nobr> <wbr></nobr>/([[:alpha:]]+)/</code>. That should shut up alot of the humbuggers.
</p><p>BTW. Thanks for you concern with my longevity. Also, I hope you are right that 18 months should be enough for some solid betas.</p>





</blockquote>

</blockquote>


<h2>bare hash</h2>
<h3><a href="/user/mad-p/">mad-p</a> on 2002-06-05T11:17:38</h3>
One rule I don't understand is Rules 8 and 9 on bare hash (p.15 on perl.com).<br>What is the last assertion for?<br>



<h2>Slashdotted?</h2>
<h3><a href="/user/tzz/">tzz</a> on 2002-06-05T14:33:40</h3>
I can't retrieve any of the A5 anymore, I think the page was Slashdotted.<br> <br>I was in the middle, too (page 12, I should have done page=all).<br>



<h2>www.perl.com overloaded?</h2>
<h3><a href="/user/bart/">bart</a> on 2002-06-05T14:37:21</h3>
Is it just me, or is &lt;www.perl.com&gt; acting strangely? Even the home page occasionally gives me a 400 error ("Bad Request"). If so, surely, apo 5 would have to be the cause.<br>



<blockquote>

<h2>Re:www.perl.com overloaded?</h2>
<h3><a href="/user/miko/">miko</a> on 2002-06-06T00:22:24</h3>
That was probably the Slashdotting it got this afternoon.  It seems fine now.





</blockquote>


<h2>/ @kids := [(\S+) \s+]* /</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-05T15:13:00</h3>
<br>Does anyone see this as potentially confusing given...<br> <br>apo4 wrote:<br>&gt; An ordinary flattening list assignment:<br>&gt;<br>&gt;    @a = (@b, @c);<br>&gt;<br>&gt; is equivalent to:<br>&gt;<br>&gt;    *@a<nobr> <wbr></nobr>:= (@b, @c);<br>&gt;<br>&gt; That's not the same as<br>&gt;<br>&gt;    @a<nobr> <wbr></nobr>:= *(@b, @c);<br> <br>I mean, we've got<nobr> <wbr></nobr>:= meaning something outside of regexen and something else (it means =) inside regexen.<br> <br>Are there ever going to be cases where one might want to use<nobr> <wbr></nobr>:= (in the apo4 non-regex sense) inside of a regex? <br> <br>If so, how would it be typed? As<nobr> <wbr></nobr>::= perhaps? Is that OK?<br> <br>-matt<br> <br>



<blockquote>

<h2>Re:/ @kids := [(\S+) \s+]* /</h2>
<h3><a href="/user/Damian/">Damian</a> on 2002-06-06T07:39:56</h3>
<i>I mean, we've got<nobr> <wbr></nobr>:= meaning something outside of regexen and something else (it means =) inside regexen.</i> <br> <br>No, it doen't. It means "bind", exactly as it does outside a regex. And what it binds in a regex is a hypothetical variable to a captured value.



<blockquote>

<h2>Re:/ @kids := [(\S+) \s+]* /</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-06T15:22:34</h3>
<tt> <br>&gt; It means "bind", exactly as it does outside a regex<br> <br>Ahh... Ok.<br> <br>Well are there times when you might want to mean 'assign'<br>(as in '=', rather than bind as in ':=') within a regex?<br> <br>I confess that I haven't really wrapped my mind fully<br>around the differences between binding and assignment,<br>so my question may be silly.<br> <br>-matt<br> </tt>





</blockquote>

</blockquote>


<h2>inline comments have no syntax</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-05T15:44:54</h3>
&gt; Old                   New<br>&gt; ---                   ---<br>:<br>&gt;/patpat(?#text)/<nobr> <wbr></nobr>/pat pat<nobr> <wbr></nobr>/<br> <br>Would there be something wrong with instead allowing<br> <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; either<nobr> <wbr></nobr>/pat pat<nobr> <wbr></nobr>/<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or<nobr> <wbr></nobr>/pat pat<nobr> <wbr></nobr>/<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or<nobr> <wbr></nobr>/pat pat<nobr> <wbr></nobr>/<br> <br>or something that *looks* like more a comment instead of looking like a single-quoted string?<br> <br>I understand that the single-quoted string asserts as true, but in some cases, single-quoted strings asser to false. I can imagine that programmers who never use string assertions could learn from example that the above is "how to do an inline comment" rather than learning that the above is "how to assert a string". If they learn this, then they're liable to get bit one day by  or something like that.<br> <br>As long as we're trying to dump special cases, why not allow a syntax for inline comments? If no special syntax is to be provided, then I'd shy away from saying "here's a kludgey way to do it" because that will just encourage folks to abuse the syntax until they learn the hard way what the sytax *really* means.<br> <br>-matt<br>



<blockquote>

<h2>Re:inline comments have no syntax</h2>
<h3><a href="/user/autarch/">autarch</a> on 2002-06-05T15:56:43</h3>
As Larry says in the 'poco',<nobr> <wbr></nobr>/x is the default, meaning you can have inline comments like this:<br> <br>
&nbsp; &nbsp; / x is the default # so this is a comment<br>
&nbsp; &nbsp; &nbsp; &nbsp; and this is not a comment<nobr> <wbr></nobr>/<br> <br>At least that's what I remember from yesterday.  I wish perl.com was up so I could confirm that<nobr> <wbr></nobr>;)



<blockquote>

<h2>Re:inline comments have no syntax</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-05T16:39:25</h3>
perl.com is back up (at least for me)<br> <br>apo5 explicitly (in text, and by examples such as the one quoted in my post above) says that to get an inline (meaning, I don't want to break my regex into two lines) comment you should assert a string.<br> <br>So, inline comments don't currently have a syntax, and instead, there is explicit advice to assert a string. I'm wondering whether we can either come up with an appropriate syntax, or not explicitly advise folks to use a kludge.<br> <br>It just feels like there's something amiss if the design specification is suggesting a kludge. Kludges should be for after the design has been implmented and found to be lacking, not an integral part of the design<nobr> <wbr></nobr>:)<br> <br>-matt<br> <br>PS: no slight intended... I know if I were trying to do even a small part of this, I'd just plain do it Wrong rather than do it so well. This is just a nit pick, really.<br>



<blockquote>

<h2>Re:inline comments have no syntax</h2>
<h3><a href="/user/autarch/">autarch</a> on 2002-06-05T16:57:31</h3>
Well, I checked again and you're wrong.<br> <br>Go to <a href="http://www.perl.com/pub/a/2002/06/04/apo5.html?page=6" title="perl.com">page 6</a perl.com> and look at the table at the bottom.<br> <br>The very first example shows an inline comment.



<blockquote>

<h2>Re:inline comments have no syntax</h2>
<h3><a href="/user/swiftone/">swiftone</a> on 2002-06-05T20:33:03</h3>
&gt; Well, I checked again and you're wrong.<br> <br>Given that he defined "inline comment" to mean "I don't want to break my regex into two lines", he's very much correct.  And since that's how Larry refers to inline comments, I'm inclined to agree with him on that definition.<br> <br>In fact, I'll agree with him across the line: A5 is good, I couldn't do better, this is a nit pick, telling people to use a string assertion as an inline comment is a time-bomb.  <br> <br>Personally I don't much care if we have inline comments (even though I've avoided<nobr> <wbr></nobr>/x so far), but I agree that telling people to abuse a construction that will fail under certain circumstances is a mistake.<br>



<blockquote>

<h2>Re:inline comments have no syntax</h2>
<h3><a href="/user/autarch/">autarch</a> on 2002-06-05T20:49:21</h3>
Oops, I didn't read wickline's message carefully enough.  I missed the part about not wanting to break the regex into two lines.<br> <br>Geez, what a weird nitpick though.  I agree that telling people to use inline strings is potentially a problem, but why would you insist on single-line regexes?<br> <br>Do you try to keep all of you other code on one line too?<nobr> <wbr></nobr>;)



<blockquote>

<h2>Re:inline comments have no syntax</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-06T02:33:52</h3>
<tt> <br>&gt; why would you insist on single-line regexes<br> <br>Personally, I have zero attachment to in-line comments<br>in regexen. If your regex is short enough to fit on<br>one line with an inline comment, then it can darn well<br>fit on one line with a comment at the end of the line.<br> <br>So, if there is no support for them, I don't mind.<br> <br>However, perl5 supports them, and rather than saying<br>that they go away in perl6, the apo currently documents<br>(and recomends?) the practice of asserting a string.<br> <br>*That* is my real nit pick. I think that either the final<br>spec should say "don't inline comments" or it should say<br>here's the provided syntax for inlining comments (which<br>would not be the same as asserting a string).<br> <br>Having thought about why I've never used in-line regex<br>comments, I think my vote would be to just not support<br>them and not advertize any kludge for them either. Tell<br>folks to put their comment on the end of the line, after<br>the regexg rather than within it.<br> <br>Does anyone currently use inline comments rather than the<br>/x modifier? If so, can you speak to whether and when<br>inline comments are handy?<br> <br>-matt<br> </tt>



<blockquote>

<h2>Re:inline comments have no syntax</h2>
<h3><a href="/user/pdcawley/">pdcawley</a> on 2002-06-06T09:06:43</h3>
Personally I think asserting a string's a great idea. If it weren't for the fact that it throws a warning at the moment I reckon that 'string in a void' context has potential to be used as a comment elsewhere in perl. But that might be seen as stealing a little too much from smalltalk.<br>



<h2>Re:inline comments have no syntax</h2>
<h3><a href="/user/TimToady/">TimToady</a> on 2002-06-06T18:52:07</h3>
The only reason it's in there is so that the p52p6 translator will know what it's supposed to translate <tt>(?#...)</tt> to.  Yes, it'd be possible to translate it to a line-ending comment, but it's better if the translator avoids changing line numbers whenever possible.



<blockquote>

<h2>Re:inline comments have no syntax</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-06T20:14:38</h3>
<tt> <br>&gt; so that the p52p6 translator will know what<br>&gt; it's supposed to translate (?#...) to.<br> <br>Then the translator shoudl probably have a special<br>check for inlined empty or '0' (zero) comments. I<br>don't use inline comments myself, but I can imagine<br>that someone who does use them might start to type<br>an inline comment and then forget to fill it in if<br>they got a phone call, or sudden inspiration in a<br>more troubling bit of code somewhere else.<br> <br>I have more trouble imagining a (?#0) comment, but<br>it seems like a good idea to protect against that too.<br> <br>-matt<br> </tt>





</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Re:inline comments have no syntax</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-05T16:46:37</h3>
<tt>hmmm...<br> <br>I should have used preview. I need to start posting as Code instead of Plain Old Text<br> <br>None of the three suggestions above look like comments.<br> <br>They should read as<br> <br>either<nobr> <wbr></nobr>/patpat&lt;(#text#)&gt;/<br>&nbsp; &nbsp; or<nobr> <wbr></nobr>/patpat&lt;#text#&gt;/<br>&nbsp; &nbsp; or<nobr> <wbr></nobr>/patpat&lt;#text&gt;/<br> <br>-matt<br> <br>this long line added to get around slashcode avg 8.9 char per line requirement blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah</tt>





</blockquote>


<h2>Regexp objects</h2>
<h3><a href="/user/Matts/">Matts</a> on 2002-06-05T16:12:25</h3>
There seems to be no indication of how regexps will behave as first class objects. I'm hoping for something akin to either Ruby or Python's Regexp objects. I think it's as good a time as any to kill regexps built using a custom quote-like operator.



<blockquote>

<h2>Re:Regexp objects</h2>
<h3><a href="/user/cmeyer/">cmeyer</a> on 2002-06-05T19:03:26</h3>
Larry drops a hint about regex objects on page 8:<br> <br>&gt;<nobr> <wbr></nobr>...<br>&gt; To reset it, use the<nobr> <wbr></nobr>.reset method on the regex object. (If you haven't named the regex &gt; object, too bad...)





</blockquote>


<h2>Help? (newbieish floundering follows)</h2>
<h3><a href="/user/mcc/">mcc</a> on 2002-06-05T17:39:58</h3>
I'm sorry, but.. maybe i'm just stupid, but i can't follow this at *ALL*. I mean, i realize the apocalypses are written this way because they're notes on language design, not a language specification, but as a curious bystander i'm having a lot of trouble following the semirandom ordering of this particular apocalypse. It isn't helping that i can never tell whether something in this document that i don't recognize is meant to be a new, proposed operator, or an "established" perl6 operator from one of the other apocalypses that i've just forgotten<nobr> <wbr></nobr>:)<br> <br>Could i request that someone post, somewhere, a somewhat more organized approach to this material? I mean, we *could* just all wait for the Exegesis documents, but those seem to mostly be sample code.<br> <br>What i'm looking for is something somewhat more along the lines of a reference-- i mean, something that just lists each operator/modifier in the new, proposed regex system, and its function, the way the perl 5 reference does. Do you think anyone would be interested in undertaking such a project at the moment, or should i just wait for perl6 to actually be released?<nobr> <wbr></nobr>;)<br> <br>If not, does anyone think they could just kind of post a summary of the new operators? Earlier posts by mr. Wall seem to be implying that in perl 6 syntax, () means grouping, &lt;&gt; refers to a special token flagging something to the regex system, and {} refers to embedded code. Is this correct? What does this mean in practice to the programmer?<br> <br>Basically, anything that anyone could post helping to digest all this would be greatly appreciated. Most of the RFCs &amp; responses describe an idea very nicely but don't really make clear how this idea would be used. For example, when you're in embedded code ( Is this {}, (&lt;&gt;), or either? ) What scope you're working in? What variables does the regex system set for you in this scope, and are there variables that if you change them it has an effect on stuff? Is the idea just that unless your embedded code returns true, the regex will fail? Stuff like that.<br> <br>I know, i really should just wait for the exegesis, i'm just so curious<nobr> <wbr></nobr>:)<br> <br>Sorry to bother<nobr> <wbr></nobr>:)



<blockquote>

<h2>Eek!</h2>
<h3><a href="/user/mcc/">mcc</a> on 2002-06-05T20:38:23</h3>
Wow, i feel dumb. I had completely missed pages 2-16, because i didn't realize they existed-- i was looking at the links on the front page covering the RFCs (pages 17 on) and assumign that was a table of contents. i missed the "jump to page" bit at the bottom.<br> <br>The first sixteen pages actually make sense, and are MUCH better organized. Please feel free to disregard my parent post<nobr> <wbr></nobr>:)





</blockquote>


<h2>Use of //</h2>
<h3><a href="/user/swiftone/">swiftone</a> on 2002-06-05T20:39:37</h3>
Okay, so <a href="http://www.perl.com/pub/a/2002/06/04/apo5.html?page=9" title="perl.com">Page 9</a perl.com> says that<nobr> <wbr></nobr>// is no longer a m//, but instead a short form of rx//.
<p>
It also talks about delayed evaluation of the pattern.
</p><p>
So, given that almost all the example patterns use<nobr> <wbr></nobr>/foo/ and not m/foo/, what is happening, and when is it happening?</p>



<blockquote>

<h2>Re:Use of //</h2>
<h3><a href="/user/Damian/">Damian</a> on 2002-06-06T08:04:44</h3>
<i>So, given that almost all the example patterns use<nobr> <wbr></nobr>/foo/ and not m/foo/, what is<br>happening, and when is it happening?</i> <br> <br><nobr> <wbr></nobr><tt>/.../</tt> now *always* returns a regex object. <br>But a regex object in a void, boolean, string, numeric, or <tt>=~</tt> context <br>immediately matches against the current topic.<br> <br>So you get:<blockquote><div> <tt>&nbsp; &nbsp;<nobr> <wbr></nobr>/pattern/;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# void context&nbsp; &nbsp; -&gt; automatch<br>&nbsp; &nbsp; if<nobr> <wbr></nobr>/pattern/ {...}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# boolean context -&gt; automatch<br>&nbsp; &nbsp; %hash{/pattern/} = 1;&nbsp; &nbsp; &nbsp; # string context&nbsp; -&gt; automatch<br>&nbsp; &nbsp; if<nobr> <wbr></nobr>/pattern/ &lt; 1 {...}&nbsp; &nbsp; &nbsp;# numeric context -&gt; automatch<br>&nbsp; &nbsp; $str =~<nobr> <wbr></nobr>/pattern/;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# =~ context&nbsp; &nbsp; &nbsp; -&gt; automatch<br>&nbsp; &nbsp; when<nobr> <wbr></nobr>/pattern/ {...}&nbsp; &nbsp; &nbsp; &nbsp;# =~ context&nbsp; &nbsp; &nbsp; -&gt; automatch</tt> </div></blockquote>and:<blockquote><div> <tt>&nbsp; &nbsp; @pats = (/pat1/,<nobr> <wbr></nobr>/pat2/);&nbsp; # list context&nbsp; &nbsp; -&gt; no automatch<br>&nbsp; &nbsp; %hash = ( pat =&gt;<nobr> <wbr></nobr>/pat/ );&nbsp; # scalar context&nbsp; -&gt; no automatch<br>&nbsp; &nbsp; $pat =<nobr> <wbr></nobr>/pat/;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # scalar context&nbsp; -&gt; no automatch<br>&nbsp; &nbsp; given<nobr> <wbr></nobr>/pat/ {...}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # scalar context&nbsp; -&gt; no automatch</tt> </div></blockquote>And if you're ever unsure, just be explicit:<blockquote><div> <tt>&nbsp; &nbsp; $pat = rx/pat/;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # definitely assigning a regex object<br>&nbsp; &nbsp; $pat = m<nobr> <wbr></nobr>/pat/;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # definitely assigning the match result</tt> </div></blockquote>





</blockquote>


<h2>Minor bug?</h2>
<h3><a href="/user/Cine/">Cine</a> on 2002-06-05T20:51:33</h3>
Shouldn't<br>/$1/                my $old1 = $1;<nobr> <wbr></nobr>/$old1/  # must use temporary here<br>have been<br>/$1/                my $old1 = $1;<nobr> <wbr></nobr>//  # must use temporary here<br>???



<blockquote>

<h2>Re:Minor bug?</h2>
<h3><a href="/user/Cine/">Cine</a> on 2002-06-05T20:53:39</h3>
ARG, it ate my &lt; &gt; even in plain text...<br><nobr> <wbr></nobr>/$1/ my $old1 = $1;<nobr> <wbr></nobr>/&lt;$old1&gt;/ # must use temporary here



<blockquote>

<h2>Re:Minor bug?</h2>
<h3><a href="/user/TimToady/">TimToady</a> on 2002-06-06T18:43:04</h3>
In general, when matching against backreferences,
you want to match it literally, not as if it were
regex.  So you wouldn't want the angles.





</blockquote>


<h2>Re:Minor bug?</h2>
<h3><a href="/user/Cine/">Cine</a> on 2002-06-05T21:11:57</h3>
And in the perl5 compat section:<br>/pat\s*pat/<nobr> <wbr></nobr>/:w pat pat/            # match word sequence<br>Should have been<br>/pat\s+pat/<nobr> <wbr></nobr>/:w[]pat pat/            # match word sequence<br>or what?<br>and thus <br>/pat\s*pat/ should have been converted to<nobr> <wbr></nobr>/pat\s*pat/





</blockquote>


<h2>Can't wait</h2>
<h3><a href="/user/gbarr/">gbarr</a> on 2002-06-05T21:09:45</h3>
I don't know about expectations, it met most of mine. But then I was expecting large changes.<br> <br>I think Larry has done and excellent job and if he was to blame for the old RE syntax, he has certainly gone a long way to make up for his sins.<br> <br>While reading this I could not help myself from thinking how to rewrite Convert::ASN1 to use it for the parser. Heck, I could probably use it for the engine too.



<blockquote>

<h2>Re:Can't wait</h2>
<h3><a href="/user/pdcawley/">pdcawley</a> on 2002-06-06T09:11:37</h3>
I have the feeling that a2p6 is going to be a <em>doddle</em> to write. Tweak the grammar so that the awk source generates a humungous regex, wrap a 'while () {...}' around it and away you go.





</blockquote>


<h2>is it \Q or \q  (or will either work?)</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-05T21:52:05</h3>
<tt> <br>the backslash sequences table used both \q and \Q<br>to quotemeta and I couldn't tell from the rest of the apo whether their interchangable or whether it was just a typo.<br> <br>-matt<br> </tt>



<h2>suggestion for the perl6 camel and pod</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-05T22:03:02</h3>
<tt> <br>&gt; If you want matching brackets for the delimiters<br>&gt; I'd suggest that you use square brackets, since<br>&gt; they now mean grouping without capturing.<br> <br>Tips like the following would probably be good to<br>gather up for the perl6 perlstyle pod, and for use<br>in the rest of the pod and the first perl6 camel.<br> <br>'twould be a fine thing if all the docs followed<br>recomended practice. I think there may still be some<br>examples of $a and $b in the perl5 pod which don't<br>have any association with sort().<br> <br>I haven't closely followed the perl6 lists, but I<br>recall initially that there was discussion of RFC<br>guidelines, and that WRT parot there has been thought<br>given beforehand to PDD guidelines, and to coding style,<br>so my suggestion is probably quite redundant.<br> <br>Just in case though, I thought I'd throw it out: draft<br>perlstyle first, then have the rest of the pod follow<br>that<nobr> <wbr></nobr>:)<br> <br>-matt<br> </tt>



<h2>I'd just like to say three things...</h2>
<h3><a href="/user/koschei/">koschei</a> on 2002-06-05T22:14:22</h3>
<p>I'd just like to say three things:</p>

<ol>
 <li>This is a wonderful Apocalypse. Probably the best so far. Comprehensible, clearly makes things simpler, yet more powerful. And guaranteed to rile some people. Probably quite a few.</li>
  <li>Kudos to Damian and Larry --- reading the Apocalypse, it's hard to see where one man's ideas begin and another's end. An elegant synthesis.</li>
  <li>I'm just happy I'm not <a href="http://www.oreilly.com/catalog/regex/" title="oreilly.com">Mr Friedl</a oreilly.com>, particularly since <a href="http://www.oreilly.com/catalog/regex2/" title="oreilly.com">the new edition</a oreilly.com> is coming out quite soon. <i>[I was going to ask when a new edition was coming out but found that when getting the url for #1. I like how its Perl section is 5.8. If anyone knows: does it still use the gorgeous, intricate, custom typography?]</i> </li>
</ol>



<blockquote>

<h2>Re:I'd just like to say three things...</h2>
<h3><a href="/user/gnat/">gnat</a> on 2002-06-10T05:33:13</h3>
Jeff's got nothing to worry about.  I don't see an implementation of perl6 regular expressions arriving any time soon.  Bits and pieces, perhaps, but I imagine that it'll be done roughly at the time that perl6.0.0 is released.  Naturally, I'd be delighted to be proven wrong!<p>

And yes, lots of gorgeous intricate custom typography.  So much, in fact, that we can't convert it to DocBook and put it on <a href="http://safari.oreilly.com/" title="oreilly.com">Safari</a oreilly.com>.  Lots of new typography, too, if my eyes don't deceive.  It looks even more like the book has been decorated by spiders walking through ink<nobr> <wbr></nobr>:-)</p><p>

<i>--Nat</i></p>



<blockquote>

<h2>Re:I'd just like to say three things...</h2>
<h3><a href="/user/koschei/">koschei</a> on 2002-06-10T19:49:16</h3>
Mmm. Can't wait until next month (particularly if I get a job). Even if I did just buy 1st ed 6-7 months ago. Expansions look good.<br> <br>I'll probably sign up to Safari one of these days. Seems like a very good deal, even if it's not all local or on paper.





</blockquote>

</blockquote>


<h2>typo in :u0 :u1 :u2 :u3 table?</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-05T22:15:53</h3>
<tt> <br>:u1<nobr> <wbr></nobr>..<nobr> <wbr></nobr>:u3 are all defined to indicate Level 1 support.<br>Should that instead read as level 1<nobr> <wbr></nobr>.. 3<br> <br>-matt<br> </tt>



<blockquote>

<h2>Re:typo in :u0 :u1 :u2 :u3 table?</h2>
<h3><a href="/user/TimToady/">TimToady</a> on 2002-06-06T18:45:08</h3>
Yes, the final set of typo fixes didn't actually make it in, and that was one of them.





</blockquote>


<h2>typo, or my misunderstanding of p6 context types?</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-05T22:22:22</h3>
<tt> <br>We have:<br> <br>&gt; A regex is executed automatically if it's<br>&gt; in a boolean, numeric, or string context.<br> <br>and we also have:<br> <br>&gt; @all = m:any<nobr> <wbr></nobr>/a.*?a/;<br> <br>Is that assignment in string context somehow (array of strings?), or should list context be added to the list of conditions under which a regex is executed automatically?<br> <br>-matt<br> </tt>



<blockquote>

<h2>Re:typo, or my misunderstanding of p6 context type</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-05T22:37:29</h3>
<tt>whoops!<br> <br>never mind<nobr> <wbr></nobr>:)<br> <br>I've been skimming ahead whenever I find a question<br>before posting it, but in this case I failed to skim<br>well enough.<br> <br>My question is explicitly addressed in the apo<nobr> <wbr></nobr>:)<br> <br>-matt</tt>





</blockquote>


<h2>do we need an rx for perl6?</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-05T22:33:08</h3>
<tt> <br> <br>I grok dumping qr() because a regex is no longer a<br>glorified string. I also grok being able to say<br> <br>&nbsp; &nbsp; my $r = rule {...};<br> <br>just as one would say<br> <br>&nbsp; &nbsp; my $s = sub {...};<br> <br>What I don't grok is why qr() was replaced with rx.<br>Why do we need rx? Isn't rule sufficient? If we do<br>need rx, then why don't we need sx for sub?<br> <br>I don't think that 'rx' is appreciably easier to type<br>than 'rule' (at least on a qwerty keyboard) because<br>'rule' uses more friendly reaches, and while it does<br>have more characters, they alternate between hands.<br> <br>My hunch is that rx was motivated by "well, we had qr<br>and it doesn't apply becuase it's not a string in the<br>land of perl6". If perl6 were being designed before the<br>qr had been introduced into perl5, would rx have been<br>invented, or would rule have been seen as sufficient?<br> <br>Do we need an rx for perl6?<br> <br>-matt</tt>



<blockquote>

<h2>Re:do we need an rx for perl6?</h2>
<h3><a href="/user/Damian/">Damian</a> on 2002-06-06T08:14:43</h3>
<tt>rx</tt> lets you choose your delimiters; <tt>rule</tt> doesn't.<br> <br> <tt>rule</tt> lets you name your regexes; <tt>rx</tt> doesn't.



<blockquote>

<h2>Re:do we need an rx for perl6?</h2>
<h3><a href="/user/jdporter/">jdporter</a> on 2002-06-11T16:32:48</h3>
What if I want to do both?<br>Why isn't there just one operator that lets you do both?<br> <br>





</blockquote>

</blockquote>


<h2>the topic is the subject of this post</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-05T23:17:41</h3>
<tt>&gt; Note that $_ within the closure refers to<br>&gt; this state object, not the original search<br>&gt; string. If you search on the state object,<br>&gt; however, it pretends that you wanted to<br>&gt; continue the search on the original string.<br> <br>What if I wanted to do something else to $_ ?<br> <br>Hmm... More precisely, I guess I'm wondering about two<br>separate things here.<br> <br>1) What if I wanted to do something to what<br>&nbsp; &nbsp;had been $_ before we were within the closure?<br> <br>2) What if I wanted to do something to the<br>&nbsp; &nbsp;current search string?<br> <br>Regarding #1, I can see that it just might not be<br>possible. If you intend to be accessing the old $_<br>within the regex, then you need to be sure to assign<br>that $_ to something else before entering the regex.<br> <br>Alternatively, if it's not too ugly, perhaps the $_<br>state object could have an _ method which returns<br>a reference to what $_ had been before the regex?<br> <br>&nbsp; &nbsp; m:i/^\#{._.comment()}$/ for @stringifiable_objects;<br> <br>Regarding #2, the above example just happens to have<br>$_ as the current search string. However, in some<br>cases, $_ will be busy doing other things, and the<br>current search string will be in some other variable.<br>In the case of a for my $x (@a) {...} loop, we know<br>that the string is $x, so our regex could be told to<br>tweak $x directly.<br> <br>However, we won't always be building our regexen<br>right near where they get used. In fact, they could<br>be quite far away. The regex could be used in several<br>places and need to tweak the current search string in<br>different bits of code where that search string has<br>different names in different instances.<br> <br>Can the regex state object have a method that returns<br>a reference to the current search string?<br> <br>&nbsp; &nbsp;<nobr> <wbr></nobr>.string<br>&nbsp; &nbsp;<nobr> <wbr></nobr>.current<br>&nbsp; &nbsp;<nobr> <wbr></nobr>.target<br>&nbsp; &nbsp;<nobr> <wbr></nobr>.cur<br>&nbsp; &nbsp;<nobr> <wbr></nobr>.str<br> <br>or something like that? In many cases, this would be<br>synonymous with<nobr> <wbr></nobr>._ (or whatever it would be called),<br>but in cases where the current search string is not<br>$_ (from before entering the regex), then the two<br>would be different.<br> <br>-matt<br> </tt>



<blockquote>

<h2>Re:the topic is the subject of this post</h2>
<h3><a href="/user/TimToady/">TimToady</a> on 2002-06-06T18:38:08</h3>
<tt>By the time you get into a regex, you're always<br>dealing with $_.&nbsp; Even =~ behaves as a topicalizer<br>for its right side.&nbsp; So, while the $_ inside a<br>closure is the search state object, it's always<br>related intimately to the outer $_, which is always<br>an alias for whatever you're currently searching.<br>Any string operations on the inner $_ should be<br>delegated to the original string.&nbsp; Providing an<br>explicit method to get at that string should be a<br>no-brainer, though if you mess with the string,<br>there's no guarantee that the regex will continue<br>to make sense.</tt>



<blockquote>

<h2>Re:the topic is the subject of this post</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-07T10:31:40</h3>
<tt>&gt; though if you mess with the string,<br>&gt; there's no guarantee that the regex<br>&gt; will continue to make sense. <br> <br>I kinda figured that would be the case. I was thinking<br>of methods on strings or stringifiable objects which<br>don't change the string. A trivial example might be<br>getting the length of the target string, when the regex<br>may not know the name of the variable containing the<br>string to which is being applied.<br> <br>It sounds like it won't need to know, which sounds good!<br> <br>-matt<br> </tt>





</blockquote>

</blockquote>


<h2>additional access to subrule state</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-05T23:30:08</h3>
<tt>&gt; So I think the return object behaves either like a<br>&gt; hash or an array as appropriate. (Note that such an<br>&gt; array might be declared to have an origin at 1<br>&gt; rather than 0.)<br> <br>How about if index 0 had the state object of that<br>subrule? That way you could dig into the subrule's<br>guts just as deeply as you can into the current rule's<br>guts?<br> <br>The list-ification of the array could be special-cased<br>to return indices from 1 on up.<br> <br>...alternatively, the subrule's state could just be a<br>method on the magical array/hash subrule return value.<br> <br>-matt<br> </tt>



<h2>yummy!</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-05T23:40:14</h3>
<tt>mkay, just finished reading...<br> <br>My questions/comments above do not reflect my overall<br>opinion. They're really just things I didn't get and a<br>nit pick or two.<br> <br>Overall, although my brain is dripping a bit from one<br>ear, I quite like perl6-flavoured regexen<nobr> <wbr></nobr>:)<br> <br>I think I need to watch some mind-numbing TV though...<br>my head hurts a wee bit<nobr> <wbr></nobr>:)<br> <br>-matt<br> <br> </tt>



<h2>negating character classes</h2>
<h3><a href="/user/OddHack/">OddHack</a> on 2002-06-06T19:31:14</h3>
I noticed that on A5p12, Larry gives this equivalence:
<p>
<tt>[^[:alpha:]] &nbsp; &lt;-alpha&gt;</tt>
</p><p>
I expected <tt>&lt;!alpha&gt;</tt> -- is there a difference between <tt>&lt;-alpha&gt;</tt> and <tt>&lt;!alpha&gt;</tt>?</p>



<blockquote>

<h2>Re:negating character classes</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-06T23:17:54</h3>
<tt>&gt; difference between &lt;-alpha&gt; and &lt;!alpha&gt;? <br> <br>I think that &lt;!alpha&gt; can match nothing,<br>while &lt;-alpha&gt; can match only a non-alpha<br>character.<br> <br>So the first can match a zero-length substring<br>while the second must match a one-character<br>substring.<br> <br>-matt<br> </tt>



<blockquote>

<h2>Re:negating character classes</h2>
<h3><a href="/user/wickline/">wickline</a> on 2002-06-07T10:28:31</h3>
<tt>... but I'm really not entirely sure<nobr> <wbr></nobr>:)<br> <br>-matt</tt>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

