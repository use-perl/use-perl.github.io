<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org story by brian_d_foy: Building a &quot;useful Perl 6&quot;</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Building a &quot;useful Perl 6&quot;</h1>
<h2><a href="/user/brian_d_foy/">brian_d_foy</a> on 2009-08-07T04:26:00</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>The most common question I get from people who aren't generally
involved with Perl 6 development is:<blockquote><div><p> <em>"When will Perl 6 be finished?"</em> </p></div></blockquote><p>In some ways the wording of this question bugs me a bit,
because the word "finished" implies there's a point at which
we all say "We're done" and development ceases (or at least
moves to some other phase).  But there really isn't a "finish
line" for Perl 6, there are just stages of development at which
more and more people are able to make use of whatever is currently
available.
</p><p>So, once we eliminate the notion of "finished", the wording is
often changed to try to make it more tractable, often by asking
when there will be a "stable release", or when the specification
will be frozen so an implementation can be completed, or many other
variations on the theme.  I understand the assumptions behind
questions like these, but at the same time part of me thinks
"Huh?  Those questions don't really fit with the way things
really happen in language development..."
</p><p>The truth is that language design is an evolutionary process,
with the design and implementation efforts serving to influence
and guide further progress in the other.  (See "whirlpool model".)
</p><p>But there's another important input to the process: "real-world"
application programs.  We need to know how Perl 6 is actually
being used in order to finish parts of the specification and
implementation.  Indeed, there are parts of Perl 6 (e.g.,
concurrency) where the specification is incomplete or
underspecified precisely because we need input from people
writing Perl 6 applications.
</p><p>But this poses a problem of sorts, because if programmers are
waiting for Perl 6 to "finish" before they start using it
to write programs, and if Perl 6 is blocking on feedback from
applications and implementations before it can progress, then
we have a deadlock of sorts.
</p><p>So, we need a way to break the deadlock.  To me, one good answer
is to start making releases of Perl 6 that may not implement
the entire Perl 6 specification, but that application writers
will feel comfortable enough to start using in their projects.
I've started to call these "useful releases" or "usable releases".
While it might not have every feature described in the Perl 6
synopses, enough features will be present that can make it a
reasonable choice for application programs.
</p><p>In doing this, I'd like to also refocus conversations to avoid
words like "finished" and "stable", because they have such
varied and strong meanings in this context.
</p><p>So, here's what the Rakudo Perl project is going to do:
</p><blockquote><div><p>We will make an "official", intermediate, <em>useful</em> and <em>usable</em>
release of Perl 6 (an appropriate subset) by Spring 2010.</p></div></blockquote><p>Of course, we have to decide what will will be included (and
<em>excluded</em>) in this intermediate "official release".  At
the Rakudo BOF on Monday we held a lively discussion about
what the release could look like, what needed to be present,
and how it could be packaged.  During the hackathons and days
following YAPC::EU we'll be drafting and publishing the more
detailed blueprint for the release.  But one of our guiding
principles will be to "under-promise and over-deliver",
to make it clear what <em>can</em> be done with the release,
and to make it very clear which parts of Perl 6 are not yet
supported in the release.
</p><p>A short list of things we <em>know</em> will be in the release (that
Rakudo doesn't already have):  use of the STD.pm grammar for parsing,
laziness, better support for modules, fewer bugs, better error
messages, better speed.  Again, our goal is to make something that
is reasonable for people to start using, even if it doesn't
meet all of the requirements for Perl 6.0.0.
</p><p>We've also had discussions about what to call the intermediate
release.  We've considered tagging it as "Rakudo 1.0", but some
of us think that the "1.0" name might tend towards "overpromise".
We also considered things like "0.5" or "0.9", but these come with
the message of "not ready for use", and that's not what the impression
we want to make either.
</p><p>So, yesterday morning I finally got around to thinking about it
as "Rakudo 'whatever'".  In Perl 6 the <code>*</code> term is used to signify
"whatever", so that leads to a working name of "Rakudo *"  (or
"Rakudo Star").
</p><p>So, the focus of the Rakudo project is to release "Rakudo Star"
in Spring 2010 as a <em>useful</em> (but incomplete) implementation
of Perl 6.  More details about the features, milestones, and roadmap
for this release will be forthcoming over the next few days.
</p><p>Pm
</p><p>P.S.:  Several of our "down-under" community members have pointed out that "Spring 2010" can be a bit ambiguous.  I'm using a season (instead of a month) to leave a month or two of wiggle room, but my intention is April 2010.  As we get a bit more detail into the plan, we'll identify a specific month.</p></p>
<p></p>


<hr/>



<h2>very exciting; one request</h2>
<h3><a href="/user/rjbs/">rjbs</a> on 2009-08-05T20:21:58</h3>
<p>Maybe I'm behind the times and this works, but lately it seems like enough of Perl 6 is there for me to mess around and have fun, except for one thing:  I don't think I can do 'make install' and have it in my path, which leads to a few annoying patterns of behavior being required.</p><p>I hope that whatever else you do, we end up with an installable Rakudo.</p><p>Good luck!</p>



<blockquote>

<h2>Re:very exciting; one request</h2>
<h3><a href="/user/moritz/">moritz</a> on 2009-08-05T20:35:42</h3>
<p>I'm pretty sure that will be done, because we have a branch for that already.</p><p>If you want to help us, check out rakudo, then run 'git checkout ins2', and follow the usual build instructions. Then tell us if that worked for you, and if you can run a simple Perl 6 program with it (perl6 -e 'say "Hello, world"' or so).</p><p>(I checked that it works for me with an installed parrot, but I didn't try to install Rakudo itself)</p>



<blockquote>

<h2>Re:very exciting; one request</h2>
<h3><a href="/user/rjbs/">rjbs</a> on 2009-08-05T20:54:55</h3>
<blockquote><div><p> <tt>~/code/hub/rakudo/parrot$ cd<nobr> <wbr></nobr>../parrot_install/<br>~/code/hub/rakudo/parrot_install$ ls<br>bin/&nbsp; include/&nbsp; lib/&nbsp; share/&nbsp; src/<br>~/code/hub/rakudo/parrot_install$<nobr> <wbr></nobr>./bin/perl6 -e 'say "hello world"'<br>hello world</tt></p></div> </blockquote><p>Works.  I should look harder at how to have it install to<nobr> <wbr></nobr>/usr/local, but cool.</p>



<blockquote>

<h2>Re:very exciting; one request</h2>
<h3><a href="/user/moritz/">moritz</a> on 2009-08-20T08:32:58</h3>
<p>You'll be pleased to know that the ins2 branch has been merged into trunk, and that the August release of Rakudo can now be installed.</p>



<blockquote>

<h2>Re:very exciting; one request</h2>
<h3><a href="/user/rjbs/">rjbs</a> on 2009-08-20T11:13:22</h3>
<p>Awesome, Perl 6 is done!</p>





</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Two things</h2>
<h3><a href="/user/Alias/">Alias</a> on 2009-08-06T03:05:35</h3>
<p>1. If you need wiggle room, use Q2 2010. That's a part of why companies do it.</p><p>2. Naming a release based on an injoke for a new language isn't very engaging or informative.</p>



<blockquote>

<h2>Re:Two things</h2>
<h3><a href="/user/pmichaud/">pmichaud</a> on 2009-08-06T05:29:49</h3>
<blockquote><div><p> <i>1. If you need wiggle room, use Q2 2010. That's a part of why companies do it.</i></p></div> </blockquote><p>"Spring" had a few other connotations that I liked for my purposes, but your point is well taken.  After this week I'll likely just use a month to refer to the expected delivery date.</p><blockquote><div><p> <i>2. Naming a release based on an injoke for a new language isn't very engaging or informative.</i></p></div> </blockquote><p>* I think "Rakudo Star" probably has enough merits to stand on its own without the injoke.</p><p>* It's really just a "working name" until/if we come up with one we like better.</p><p>* I'm not sure that designations really need to be very informative at this stage -- we could've just said "Rakudo X" or "Rakudo <i>n</i>", but I personally find "Star" a bit more engaging than those.</p><p>* I think it's least as engaging or informative as names like "Longhorn", "Dapper Drake", "Leopard", "Tiger", etc.  Perhaps you disagree with those names also, but clearly there's already a precedence and tradition for this sort of thing by some well-respected organizations.</p><p>Thanks!</p><p>Pm</p>



<blockquote>

<h2>Re:Two things</h2>
<h3><a href="/user/ysth/">ysth</a> on 2009-08-06T07:15:48</h3>
Makes me think "rising star"; not a bad thing at all.



<h2>Re:Two things</h2>
<h3><a href="/user/cosimo/">cosimo</a> on 2009-08-08T19:13:15</h3>
Rakudo Genesis?





</blockquote>

</blockquote>


<h2>do not use 1.0</h2>
<h3><a href="/user/deckard/">deckard</a> on 2009-08-06T09:34:33</h3>
well, do not use 1.0 for sure or we might have PR disaster, just like KDE 4.0<br/><br/>(that was release aimed at developers, but being<nobr> <wbr></nobr>.0 release, many users/reviewers tried it and were very disappointed. afaik fedora labeled and distributed it even as a stable release, so many users were f*d)



<h2>What about forward compatability?</h2>
<h3><a href="/user/Deven/">Deven</a> on 2009-08-06T21:38:45</h3>
Give some thought to forward compatability.  People will be much more likely to use "Rakudo Star" for real-world applications if they can be guaranteed that the version of the language they're writing to will remain supported after the language evolves in future releases.  If upgrading Rakudo will break real-world applications because the language semantics evolved, that will discourage anyone from writing those applications in the first place, especially serious ones that can't necessarily be rewritten every time the language evolves...



<blockquote>

<h2>Re:What about forward compatability?</h2>
<h3><a href="/user/clintp/">clintp</a> on 2009-08-12T16:37:17</h3>
I think you're addressing the more practical nature of Perl 6 which still seems premature, as I read this thread.<br/><br/>There are applications to be written, libraries to be ported, packages to be bundled, books to be written, training classes to be prepared.  Until it syntax/semantics are stable (not necessarily code stable) then it's pretty much impractical to do most of these things.  And some have *long* lead-times (books, porting projects).  Some can't be undone (releasing an app into the wild).<br/><br/>Software has stages: Dev, Alpha, Beta, RC, RTM and Release.  We're all adults here, call it what it is.  It's still very much a development product.



<blockquote>

<h2>Re:What about forward compatability?</h2>
<h3><a href="/user/revdiablo/">revdiablo</a> on 2009-08-13T21:27:02</h3>
<p>So, riddle me this.  What would an adult prefer: shoehorning all software projects into a 6 stage development model, or looking at the dynamics of a community and trying to find a development model that works well and produces the best result?  Your stages are mighty fine for a lot of situations, but I'd hate to be as inflexible to think it's the only way to succeed.</p>





</blockquote>

</blockquote>


<h2>Perl6 &quot;finished&quot;</h2>
<h3><a href="/user/gdonald/">gdonald</a> on 2009-08-07T20:56:57</h3>
Here, I'll explain since you don't seem to get it.
<br> <br>
When people ask "When will Perl6 be finished?", they want to know when there will be a Perl 6.0 release.  Of course everyone realizes development will still continue, who ever said it wouldn't?  The question doesn't imply that at all, at least not to me.
<br> <br>
If you don't want to answer the question then don't.  But don't act like it's some huge imposition to be asked.
<br> <br>
As a software developer I'm asked about my ETAs every single day.  It's really not that huge of a deal to make an estimate, even if it's not correct.



<blockquote>

<h2>Re:Perl6 &quot;finished&quot;</h2>
<h3><a href="/user/cjfields/">cjfields</a> on 2009-08-07T22:03:38</h3>
<p>No need to be snarky.</p><p> As a frequent denison of #perl6, the impression I get when this is asked on IRC is the same as what pmichaud finds.  Maybe it's not intended that way, but asking is something is 'finished' to me implies 'is the spec completed', not 'is the spec at 6.0', no matter the actual intent.</p><p>Just to add: the folks on #perl6 are very accommodating to new users, including ones that ask that question.  It's probably the nicest IRC channel I've been on.</p>



<blockquote>

<h2>Re:Perl6 &quot;finished&quot;</h2>
<h3><a href="/user/gdonald/">gdonald</a> on 2009-08-07T22:37:27</h3>
I would imagine the people who ask about Perl6's ETA don't care much about the Perl6 spec completion date.  It's probably safe to assume they mean when can they do something like `apt-get install perl6`.



<blockquote>

<h2>Re:Perl6 &quot;finished&quot;</h2>
<h3><a href="/user/cjfields/">cjfields</a> on 2009-08-08T03:33:43</h3>
<p><div class="quote"><p>I would imagine the people who ask about Perl6's ETA don't care much about the Perl6 spec completion date.</p></div><p>Yes, but the spec and the test suite define what Perl 6  is, not a single implementation.  Anything that passes the test suite is considered Perl 6, so Perl 6 can have many implementations.

As the article states, having a 'useful Perl 6' will help drive the spec to completion, but it likely won't be the only implementation in the long run.</p><p><div class="quote"><p>It's probably safe to assume they mean when can they do something like `apt-get install perl6`.</p></div><p>Agreed, and that's the disconnect.  It'll probably be something more like 'apt-get install rakudo' or similar.</p>



<blockquote>

<h2>Re:Perl6 &quot;finished&quot;</h2>
<h3><a href="/user/gdonald/">gdonald</a> on 2009-08-08T16:06:32</h3>
Then why isn't the article called "a useful rakudo"?  Why not try and close the "disconnect" rather than perpetuate it?
<br> <br>
Seriously, the Perl6 spec isn't even nailed down yet?  What is the hold-up on that?  Design by committee?
<br> <br>
Seems like Perl6 might be going the way of GNU/Hurd, eternally under development, and never to land.



<blockquote>

<h2>Re:Perl6 &quot;finished&quot;</h2>
<h3><a href="/user/cjfields/">cjfields</a> on 2009-08-08T18:06:04</h3>
<p><div class="quote"><p>Then why isn't the article called "a useful rakudo"?  Why not try and close the "disconnect" rather than perpetuate it?</p></div><p>I think b/c it's the only implementation far enough along to get new users interested (and maybe allow them to jump in on other spots NYI).</p><p><div class="quote"><p>Seriously, the Perl6 spec isn't even nailed down yet?  What is the hold-up on that?  Design by committee?</p></div><p>Much of the spec is implemented in Rakudo, enough to make it quite 'usable', and Rakudo is passing around 12000 tests.  If anything much of the spec has changed due to actual attempts at implementing it, either via Pugs, Rakudo, smop, etc. (the removal of <tt>want()</tt> comes to mind)</p><p>Again, as mentioned in the article that may be the push needed to flesh out spots in the spec (concurrency for instance) that need real-world use cases as examples.  I've already started coding some stuff using Rakudo myself, and have contributed code.  It's very nice, just slow (and that should improve soon).</p><p><div class="quote"><p>Seems like Perl6 might be going the way of GNU/Hurd, eternally under development, and never to land.</p></div><p>Nah, I think it will eventually reach a 'stable' specification version (with updates after that).  Seems to be enough interest to push it there.</p>



<h2>Re:Perl6 &quot;finished&quot;</h2>
<h3><a href="/user/pmichaud/">pmichaud</a> on 2009-08-09T02:27:46</h3>
<p>I've written a response to this thread in a <a href="http://use.perl.org/user/pmichaud/journal/39424" title="perl.org">separate article</a perl.org>.</p><p>Pm</p>





</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>tortoise loses to hare due to lack of concurrency</h2>
<h3><a href="/user/attlee/">attlee</a> on 2009-08-15T01:53:18</h3>
Well, don't wait for user input, just go ahead and
finalize sine qua non's like concurrency policy/implementation.
Perl6 is already getting lost in the flurry of
announcements about new JVM lingos.
Something like concurrency support has to be seen
as an absolute top priority for any
"current" lingo.  Perl6 (hopefully) was not
conceived of as a nifty-er compiler of
digested text reports!



<blockquote>

<h2>Re:tortoise loses to hare due to lack of concurren</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2009-08-17T05:01:13</h3>
<p>That sounds like a design principle guaranteed to make <em>everyone</em> from language designers to implementers to users unhappy with the results.</p><p>What do <em>you</em> want from a concurrency system?</p>





</blockquote>


<h2>Why not just use alpha, beta, etc</h2>
<h3><a href="/user/mugwumpjism/">mugwumpjism</a> on 2009-08-27T05:38:42</h3>
<p>I really don't get this argument.  It's like, you want a release which you want to advertise to people as ready for consumption, but you don't want to "use up" the 1.0 number delivering something which isn't "finished".  Forget the overpromising, it's years too late for that.

</p><p>Honestly, no-one will care if the complete Perl 6 is not there, so long as the implementation is good, it's debuggable, you can start making bindings for C libraries easily, and there is an effective module deployment system it should be great.

</p><p>Why not start calling each release from then 1.0alpha1, 1.0alpha2 etc, until the major kinks are ironed out.

</p><p>Well, anyway, just another pot-shot from the sideline.</p>



<blockquote>

<h2>Re:Why not just use alpha, beta, etc</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2009-08-27T08:29:33</h3>
<p>No one cares about &#8220;alpha&#8221; versions. Look at how much testing even the Perl&#160;5 Release Candidates get: it&#8217;s barely distinguishable from none.</p><p>Which is no surprise, and is even less so for alphas. The typical meaning of &#8220;alpha&#8221; is &#8220;we&#8217;ve picked a feature set but the features aren&#8217;t done yet and we&#8217;ve not even started on the bugs&#8221; &#8211; miles away from production stability.</p><p>That&#8217;s not what Rakudo* is about. Quite the opposite: the idea is that it&#8217;s aiming for production quality, but the feature set is limited. In some sense it&#8217;s the inverse of an alpha. The point of the product naming exercise here is to communicate to people that they can use this without fear that their working code will suddenly blow up in weird ways due to bugs and &#8220;under construction&#8221; signs in the language and runtime: &#8220;it&#8217;s good enough to entrust it with real work&#8221;.</p><p>And because the limitation of this product is not in the degree of completion of the features, or the rate of bug discoveries (as in a beta), but rather the extent of the feature set, then it becomes completely arbitrary to draw a line between what&#8217;s (quasi-)alpha and what&#8217;s not.</p><p>So from several perspectives, calling it an alpha doesn&#8217;t make much sense.</p><p>Personally I think this choice of name was really smart.</p>



<blockquote>

<h2>Re:Why not just use alpha, beta, etc</h2>
<h3><a href="/user/mugwumpjism/">mugwumpjism</a> on 2009-08-31T22:50:57</h3>
<p>And what the heck number are the distribution packagers going to give it?

</p><p>It's matching the "Whatever" to the wrong side of the argument.  "Rakudo *" to me means the version that a particular person starts using it, not a fixed release.

</p><p>Why not just call it 1.0, make it clear to everyone what's finished and what's not, then there is no over-promising.</p>





</blockquote>

</blockquote>


<h2>great program...</h2>
<h3><a href="/user/jamesd/">jamesd</a> on 2010-04-19T23:42:10</h3>
perl is great, no matter what its version.
i am not a professional programmer, but have found perl gets small jobs done fast, and easy (when i am not so rusty).<br/><br/>people may say its "noise" but i find all the features and unique ways of doing things of 5.10.0 great. I love that it is NOT java and not C# etc.  a person doesnt have to learn all of perl to use perl productively. I think Mr. Wall said that once too....<br/><br/>here's my vote for progress (perl 6) but hope you can stick to the roots too (ok...i just cant stand "strong typing" )!!<br/><br/>thanks so much for all the efforts...to all of you,<br/><br/>James Danforth, president
iProlog Corp





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

