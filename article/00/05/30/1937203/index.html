<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org story by chip: Putting the ``Backwards'' in ``Backwards Compatibility''?</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Putting the ``Backwards'' in ``Backwards Compatibility''?</h1>
<h2><a href="/user/chip/">chip</a> on 2000-05-30T19:22:58</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>Every time we upgrade Perl, it seems that something breaks.  Sometimes that something is very small, but occasionally it's large like "@" in strings.  Sometimes it's on purpose; usually it isn't.  But what is the ideal?  What can we -- and users -- reasonably expect from Perl?</p>
<p>This is a subject I'm obviously interested in because I'm working on <a href="http://topaz.sourceforge.net/">Topaz</a>, which will become Perl 6 if it works out.  And reimplementing a whole language makes breakage almost inevitable.  So since some things are going to break, it could be argued that we shouldn't worry about it.  And maybe that's true for an upgrade from Perl 5 to Perl 6...  In particular, Larry has said that for Perl 6, everything that's officially deprecated in Perl 5 is fair game for deletion.
<p>
But there's another perspective that's worth considering.  I recently had a mail exchange with a programmer who loves Perl but decided not to use it for his product, because he couldn't rely on every Perl program he writes today continuing to work for the indefinite future on all upcoming versions of Perl.
</p><p>
I think there are three major questions raised by this story.
</p><p><ul> <li>Is it appropriate to expect <i>all</i> Perl programs to work <i>forever</i> with all future versions of Perl?</li>
<li>If not, what does that mean for Perl advocacy?  Should we really be encouraging people to use Perl for systems that are deployed far from maintenance programers?</li>
<li>Would it be worthwhile to resynchronize the documentation and the regression tests so that <i>every</i> documented behavior is tested?</li>
</ul>
<p>I invite perspectives on these issues from everyone....</p></p>


<hr/>



<h2>C?</h2>
<h3><a href="/user/pudge/">pudge</a> on 2000-05-30T19:58:08</h3>
I think it is worth noting that not all C programs work forever, either.  Compilers and libraries -- even *gasp* standard ones! -- change.  Very well-written C programs should continue to run on modern compilers, but sloppy ones won't.  C programs that exploited hidden or undocumented features can break.  Hey, this is beginning to sound familiar<nobr> <wbr></nobr>...
<br>
<br>Perl might be in worse shape than C in this regard, but it is something to ponder.



<h2>But C can be compiled...</h2>
<h3><a href="/user/chip/">chip</a> on 2000-05-30T20:06:05</h3>
... and the compiled form is likely to work for a very, very long time.
<p>
Maybe what we're seeing is that byte-compiled Perl is more important for reliability than anything else.</p>



<h2>Clean out the cruft</h2>
<h3><a href="/user/kirbyk/">kirbyk</a> on 2000-05-30T20:10:00</h3>
It's fairly important, IMO, to be able to clean out old code every now and then.  This means rewriting, and that means things will break.<br><br/><br/>However, so what?  If someone has some code that won't work in Perl 6, they can keep running perl 5.x indefinitely.  It's not like we're taking anything away from anyone.  Odds are fairly high that if something breaks, they'd be well advised to rewrite it anyway.<br/><br/>I'd rather have a language that was well maintained and up to date, with efficient code, than one that was backwards compatible to every idea anyone ever stuck into it.



<h2>Re:Clean out the cruft</h2>
<h3><a href="/user/chip/">chip</a> on 2000-05-30T20:15:26</h3>
But can we really tell them to keep Perl 5 and Perl 6 forever?
<p>
What if a security problem arises with Perl 5 ten years from now.  Will we care?  Do we care if someone finds a (new) security problem today with Perl 4?
</p><p>
I think it's inevitable that, at some point, bit rot will set in and Perl 5 itself will be deprecated.  The key questions are (1) how long that can be delayed, (2) how long we think it <i>should</i> be delayed, and (3) how that should affect what we do and recommend for users.</p>



<h2>Re:But C can be compiled...</h2>
<h3><a href="/user/pudge/">pudge</a> on 2000-05-30T20:28:35</h3>
Sure, but how many unchanged, compiled programs from 10 years ago still work?  And how many of those do you still use?



<h2>Re:But C can be compiled...</h2>
<h3><a href="/user/chip/">chip</a> on 2000-05-30T20:36:09</h3>
Aren't there people still using SunOS 4 binaries under Solaris?  Isn't it possible for those binaries to be ten years old?  How about commercial apps for Xenix that still run under emulation today?
<p>
A raw count of old binaries doesn't really address the point, IMO, because the whole universe of computing has expanded so quickly that even if all old binaries were still used, they'd be outnumbered by the new ones.
</p><p>
More to the point: For those who have chosen as their goal the creation of code that works for ten years, can we recommend Perl as an appropriate tool?  If so, what constraints does that place on them and us?</p>



<h2>Re:But C can be compiled...</h2>
<h3><a href="/user/pudge/">pudge</a> on 2000-05-30T20:55:56</h3>
I just use the "count" as an illustration: for the overwhelming majority of code out there, such longevity is not an issue.  Even sometimes when the compiled code is still to be used, the OS has been upgraded and the binaries break.  Unless you are going to make sure the OS stays the same, you probably count on a program of significance still working in 10 years.  And who is going to be using the same OS in 10 years?
<br>
<br>Yes, some people will.  And I'd have to say that unless you can compile a Perl program, then no, unless you are willing to not upgrade your Perl, which is perfectly fine.  What if a security hole is discovered?  Well, what if there is a security hole in your OS somewhere?  What if you have a compiled C binary and in 10 years you find a security hole, but you lost the source?<nobr> <wbr></nobr>:-)
<br>



<h2>Ten-year-old MPE programs are common</h2>
<h3><a href="/user/ashted/">ashted</a> on 2000-05-30T23:04:03</h3>
<p>Working under MPE, we have a <em>lot</em> of programs compiled 10 years ago which are still happily working every day.  I'm pretty sure we even have one or two which were compiled in the 70s and which still run today.

</p><p>For a shop like ours with lots of inhouse code, the idea that upgrading the language may suddenly cause widespread breakage is a pretty scary thing.

</p><p>At the very least, getting the test suite as complete as possible so that we can tell people what is going to break is important.</p>



<h2>Re:Ten-year-old MPE programs are common</h2>
<h3><a href="/user/chip/">chip</a> on 2000-05-30T23:38:45</h3>
Wow, MPE.  That brings back memories....
<p>
If modern MPE is anything like the MPE IV (?) I used in the early 80s, it's extraordinarily stable--just the kind of system you'd expect to be upgraded about once per decade.
</p><p>
I heard a story about an MPE system that got turned off in the middle of a really long COBOL compilation.  When the system was repowered, the OS started doing lots of active disk stuff but didn't generate any output.  Thinking that it was wedged, the operator write-protected the hard drive in preparation for shutdown.  (Back then, disks were diskwasher-sized and had their own power and write-protect buttons.)  The MPE kernel beeped--and MPE never beeps.  But it didn't just beep once.  It beeped three times.  Then it printed the hard disk equivalent of: ``Put The Candle Back!''  The startled operator complied.  Soon thereafter, the system resumed operation as if the power had never been lost.
</p><p>
I don't know if the story is true, but it's certainly believable to this MPE user.
</p><p>
PS: Does the HP-3000 architecture still live?
<br>
PPS: Does MPE still ship with a ``ttymon'' program?  }:-)</p>



<h2>Can the likelyhood of breakage be classified?</h2>
<h3><a href="/user/jzawodn/">jzawodn</a> on 2000-05-31T00:32:21</h3>
Can anyone (from p5p, maybe) look at Perl today, and tell us what the likely breaking points are? Functions will change their return values? Syntax changes? Garbage collection?
<br>
<br>Maybe a line should be drawn clearly in the documentation between what you can rely on and what behaviour is considered "undefined" or a "mere side-effect of a particular operation which you really can't rely on".
<br>
<br>Hmm. It is an interesting question.
<br>
<br>Maybe "Perl" should be defined separately (somehow) from "perl". Much like there are several implementations of Java, there *could* be several compliant implementaions of Perl. In the process of doing that, you'd know what Topaz must not break.
<br>
<br>Would that be practical? I wonder...



<h2>Re:Can the likelyhood of breakage be classified?</h2>
<h3><a href="/user/chip/">chip</a> on 2000-05-31T01:35:02</h3>
Larry doesn't want to separate Perl and perl.  There would be drift and differences, and that would be more harmful than the variety would be beneficial.  Or so he surmises.  I think he's right, too.
<p>
We already have some classification of breakage.
</p><p><ul> <li>Bugs.  Oops.  'Nuff said.</li>
<li>New keywords can be introduced at any time, so calling non-imported subroutines without using "&amp;" is asking for trouble.</li>
<li>Indirect object syntax for method calls is particularly fragile in the face of new keywords.</li>
<li>Some features are officially deprecated and may go away, like <tt>$[</tt> and <tt>$*</tt>.</li>
<li>Action at a distance may surprise existing code; for example, it's possible that a new warning or warning-related feature could confuse  a <tt>$SIG{__WARN__}</tt> function.</li>
</ul>
<p>
More?</p>



<h2>Re:Can the likelyhood of breakage be classified?</h2>
<h3><a href="/user/pudge/">pudge</a> on 2000-05-31T02:24:13</h3>
&gt;New keywords can be introduced at any time, so calling non-imported
<br>&gt;subroutines without using "&amp;" is asking for trouble.
<br>
<br>I thought it was asking for non-avoidance of prototypes and cleaner looking code.  Sigh.



<h2>Break, Broke, Broken</h2>
<h3><a href="/user/AutoPerl/">AutoPerl</a> on 2000-05-31T12:30:05</h3>
The chief problem is time -- I need to use Perl, not nursemaid it. I use Perl partially because it is a RAD language that lets me write a lot of features in a short time, and because it is so portable. I lost an entire weekend when I upgraded to Perl 5.6 and it broke my DBI and DBD modules! I had to dig out the old Perl, reinstall it, install my database modules again. In short, I don't have time to do full regression testing on every line of code I've ever written in Perl. I need to know Perl won't break, or I'll just never upgrade. Right now, I'm going to be on 5.005 for a long, long, long time because I don't have time to dig around and upgrade all my modules and stuff.<br/><br/>And, if Perl 6 won't run existing Perl 5 code as-is, it's utterly useless and will die a horrible death like COBOL 9x and FORTRAN 9x that no one uses because they're not backwards compatible. Even the new C 9x standard is going to die horribly because there's zillions of ANSI C code in use, and zero lines of C 9x code. All these languages are great improvements, but useless because the code won't work with old compilers.<br/><br/>Perl is the ISP code of choice, and either 1) ISPs will ignore Perl 6 because it breaks everyone's code and stay with Perl 5, or 2) they'll upgrade and break everyone's code -- you can guess which is more likely to happen. People are going to standardize on Perl 5 just like they did COBOL II, and like they will ANSI C 89. These new languages will just die from not being used.<br/><br/>Perl 6's mission has to be to run every valid Perl 5 program FIRST -- this has to be the goal for Perl to survive. Learn the history lesson from these other languages!



<h2>RE: Backwards Compatibility</h2>
<h3><a href="/user/drbob/">drbob</a> on 2000-05-31T12:34:28</h3>
Backwards compatibility is GOOD.  I can still run (re-compile) most of my FORTRAN-IV programs, and yes, I consider F90 an abomination.<br/><br/>However, some of my F-IV programs didn't work, but I was able fix them because the changes in the language were well documented.  That's OK, provided simple, routine structures aren't changed (for example, I would assume that $_ in Perl 6, Topaz, etc. would still be modified by the s/.../.../ command.<br/><br/>Bob



<h2>Some thoughts ...</h2>
<h3><a href="/user/alleria/">alleria</a> on 2000-05-31T12:53:05</h3>
Like others have pointed out, it's not necessarily appropriate for all current Perl code to work in all future versions, although it's also obvious that breaking 'basic' features would cause lotsa angst. <br> <br><br/><br/>Besides, aren't deprecated features the icky stuff like allowing the user to set what the first element of an array is, etc. that really <i>should</i> go away anyhow?<br> <br><br/><br/>It's true that Perl is now being used in large-scale projects in many cases, sometimes replacing huge chunks of C/C++/Java, but one would suspect that in such large-scale projects, maintainance programmers should be nearby.<br> <br><br/><br/>Conversely, for situations where there are no maintainance programmers, one would expect a dearth of sysadmins as well, and thus no upgrade from Perl 5 to Topaz (and thus, no compatibility problems).<br> <br><br/><br/>Some have mentioned the situation of 'what happens if Perl 5 has a big security bug that gets fixed in Topaz and people want to upgrade?'<nobr> <wbr></nobr>... And I think that probably the best solution would be to just have Perl 5 continue to be maintained until it is Perl 4 caliber in terms of stability/security, and then just freeze it at that.<br> <br><br/><br/>(I seem to remember Larry, I think, saying how some shops are still using Perl 4 because Perl 5 isn't stable, and causes some breakage? I don't really see how the difference between 5 and Topaz would be that great, unless you're really planning to break a truly <i>huge</i> amount of current features.<br> <br><br/><br/>One last thought comes to mind: ensuring compatibility with modules on CPAN. A lot of Perl users will want to upgrade to Topaz, but keep on using their dear CPAN modules. Suffice it to say that if CGI.pm broke, then "hell hath no fury<nobr> <wbr></nobr>... "<nobr> <wbr></nobr>;)   <br> <br><br/><br/>But even in lesser cases, a user might be inhibited from upgrading to Topaz because his modules don't work with it. Again, it's probably the module's author's responsibility to update, but that doesn't always happen as much as we'd like, especially in the case of unsupported modules of various sorts. <br> <br><br/><br/>(and I do shudder to think what any module that currently links to a C library will have to have done to it to work under Topaz<nobr> <wbr></nobr>...)<br> <br><br/><br/><br><br/><br/>But I mean, overally, Topaz is just the greatest thing! Hopefully you're thinking of things like line disciplines, compiler hints, and possibly spinning formats off into a separate module that may even allow more flexible usage? <br> <br><br/><br/>I know that some of the above, for example, might break compatibility (screams of outrage at those that actually use formats, hehe), but IMHO the benefits outweigh the potential problems.<br> <br><br/><br/>My $0.02,<br/><br/>-- Alleria



<h2>Re:Ten-year-old MPE programs are common</h2>
<h3><a href="/user/ashted/">ashted</a> on 2000-05-31T12:56:42</h3>
Modern MPE is still extraordinarily stable<nobr> <wbr></nobr>:-).  The HP3000 has become the HPe3000 and is generally built around a PA-RISC processor (the same hardware, pretty much, that HP-UX runs on) and will be available on IA-64.
<br>
<br>The story you tell sounds typical.  I was recently talking to a linux fan about the stability of the box and went back and pulled the power loose from our 947.  The box, of course, went immediately silent.  Then I plugged the power back in.  Once the drive spun up, and was active for a short bit, the console commented that there had been a power failure and life went on with no other effects.  Logged-in sessions were still logged in and sitting exactly where they were before, etc<nobr> <wbr></nobr>:-).
<br>
<br>These days, though, MPE has not only the extraordinary stability and numerous features which MPE users have long loved, it also has Perl, Java, Apache, Sendmail, etc. and is continuing to provide a rock-solid foundation for business in the "Information Age".
<br>
<br>P.S.  Nope, so far as I know, the "ttymon" is gone.



<h2>Re:Can the likelyhood of breakage be classified?</h2>
<h3><a href="/user/ashted/">ashted</a> on 2000-05-31T13:10:58</h3>
I'll second that.



<h2>CPAN Compatability</h2>
<h3><a href="/user/pudge/">pudge</a> on 2000-05-31T13:13:48</h3>
The problem is so much code on CPAN is poorly written.  Not most of it, but a significant enough amount of it to mention.  Much of the time, when perl "breaks" something on CPAN, it is the CPAN author's fault.
<br>
<br>This is not always the case, especially with a major update like perl 5.6.  However, I think making sure things on CPAN don't break is not a worthy goal for perl porters; it is a worthy goal for CPAN authors and <a href="http://testers.cpan.org/" title="cpan.org">CPAN testers</a cpan.org>.
<br>
<br>Oh, and the CGI module ships with perl; I think it is clear that it will always be a goal that modules that ship with perl will work with that version of perl.



<h2>Re:Can the likelyhood of breakage be classified?</h2>
<h3><a href="/user/chip/">chip</a> on 2000-05-31T14:03:16</h3>
You know, now that you say it that way<nobr> <wbr></nobr>....
<p>
I wonder if it might be possible to reverse the current rules someday.  It's probably more robust over the long term to default to calling a subroutine with the same name as an operator.</p>



<h2>Re:Some thoughts ...</h2>
<h3><a href="/user/chip/">chip</a> on 2000-05-31T14:07:56</h3>
Yes, the deprecated features are the ``yucky bits''.
<p>Your point about CPAN is well-taken.  I think cpan-testers will help a lot.
</p><p>As for interfacing with C, I'm expecting to create a compatibility layer so many existing XSs can continue to work, albeit with some efficiency hit.  Fortunately, writing the equivalent of an XS for Topaz will be a lot simpler than XSs today.</p>



<h2>Silent Changes are the Worst</h2>
<h3><a href="/user/chip/">chip</a> on 2000-05-31T14:11:04</h3>
I hope not only to document language changes, but to detect any potential breakage at compile time.
<p>
I know I don't mind language changes much, as long as there are <i>no silent killers</i>.</p>



<h2>Re:But C can be compiled...</h2>
<h3><a href="/user/doug/">doug</a> on 2000-05-31T14:12:27</h3>
I think a lot of this depends upon the platform.
<br>
<br>At work I use Solaris, and we expect things to continue as they've been for quite a long while.  At home I use Linux, and I don't get bothered when things stop working.  It is a cultural issue.  Some people prefer that everything remains stable, even at the expense of new features/functions.  I usually prefer to update code and spend the time keeping my software up-to-date if I feel that I'm getting something for it (p6 must be better than p5).  If I may (over)generalize: I think that my attitude is more common the Linux community.
<br>
<br>I image that the same split exists in the Perl community.  There will be some people who want new features and will pay whatver price, while there are those who want yesteryear's code to run without any problems.  There is no way of making both groups happy, so you will have to pick your battles carefully.
<br>
<br>When you're talking about breaking things, what do you mean?  I've wanted a
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; use depreciated;
<br>
<br>type command to allow $[ and all the other out of date concepts, but then again I'd like
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; use anonymous;
<br>
<br>to enable $_ because I prefer to name things.
<br>
<br>But I think you mean more than that.  Any concrete examples?
<br>
<br>Getting back on topic, I don't think it is that big of a deal if p6 is not 100% backwards compatable with p5 as long as the p5 source is available.  If someone wants to use the old stuff, go for it.  It would be better if p5 were maintained a bit after p6.  I don't mean new releases, I mean more of fixes/updates to keep the existing stuff working.



<h2>Peoples failings shouldnt hold back development</h2>
<h3><a href="/user/jns/">jns</a> on 2000-05-31T14:32:40</h3>
<p>
<i>
Is it appropriate to expect all Perl programs to work forever with all future versions of Perl?
</i>
</p>
<p>
Well yes and no.  I mean that there was a lot of chat in <a href="news:comp.lang.perl.misc" title="perl.misc">comp.lang.perl.misc</a perl.misc> after the release of 5.6.0 that would indicate that people never tested the new version of Perl with their existing programs before going live with the new release - this is quite simply bad practice. People blundering into the installation of a new version of <b>anything</b> without a proper implementation plan deserve everything they get and I dont think that Perl is any different - in the end you cant hold back the development of a piece of software simply in order to allow those people to carry on in their own sweet oblivious fashion.  Of course perhaps a release might be made with greater caveats as regards the testing of pre-existing programs<nobr> <wbr></nobr>...</p>



<h2>Re:Can the likelyhood of breakage be classified?</h2>
<h3><a href="/user/pudge/">pudge</a> on 2000-05-31T14:57:54</h3>
I don't know if that is the answer, either.  Talk about confusion.  But maybe it is the best answer.



<h2>Backwards compatibility's a must</h2>
<h3><a href="/user/Elian/">Elian</a> on 2000-05-31T15:58:49</h3>
<blockquote><div> <i>Is it appropriate to expect all Perl programs to work forever with all future versions of Perl?</i> </div></blockquote>

All the ones that use documented features, yep. It's one of the things that marks a solid, well-engineered piece of sofware

<blockquote><div> <i>If not, what does that mean for Perl advocacy? Should we really be encouraging people to use Perl for systems that are deployed far from maintenance programers?</i> </div></blockquote>

The existence of maintenance programmers is reasonably irrelevant here. Perl's a language, and that's a low-level-enough thing that it ought to change rarely and with great thought. Features can be added, but should not be removed if at all possible. (They probably ought to remain in the language for ages after they've been removed from the docs)
The only thing that ought to change even less frequently is the user-level interface to an OS.

<p>
C's been brought up as an example of languages changing, but you'll notice that it's only gone through two major changes (if you want to count ANSI as major) in thirty or so years)

</p><blockquote><div> <i>Would it be worthwhile to resynchronize the documentation and the regression tests so that every documented behavior is tested?</i> </div></blockquote>

Yes! Absolutely and without a doubt. (Heck, if we had that we'd have caught bugs in the 5.6.0 release...) We can't tell if perl is doing what it ought to be doing if we don't have test cases to check everything. This is another hallmark of well-engineered software.



<h2>Standards are the key</h2>
<h3><a href="/user/jjohn/">jjohn</a> on 2000-05-31T19:07:58</h3>
<p>If Perl has a standard spec which defined its behavior, then topaz's implementation shouldn't
break user scripts. Usually, programs that break do so because they were exploiting a marginal feature. Perl is a reasonably mature these days.
It might be time to set some of it in stone.

</p><p>There is an upcoming interview with Larry Rosler on www.perl.com in which he advocates strongly for the standardization of Perl. Governments and large businesses like standardized languages.

</p><p>Anyway, this is just a thought.</p>



<h2>Re:Clean out the cruft</h2>
<h3><a href="/user/jerryl/">jerryl</a> on 2000-05-31T19:26:18</h3>
I agree that if a new version of Perl breaks an existing program then simply keep the old version of Perl installed until you have time to rewrite.
<br>
<br>You can always have multiple versions of Perl installed at the same time and then gradually switch over.  At least this is what I am doing for the move to 5.6.0.
<br>
<br>JL
<br>



<h2>backwards-incompatible + write-only = trouble</h2>
<h3><a href="/user/sethg/">sethg</a> on 2000-05-31T21:53:38</h3>
I'm not concerned about Perl 6 breaking the scripts and modules that <em>I</em> write.  I am concerned about it breaking stuff <em>that other people write and that I depend on</em>.
<p>
In order to get stuff done in Perl, I use code from other people -- sometimes modules from CPAN, and sometimes home-grown code from people who have moved on to other projects.  If there <em>weren't</em> so much code like this available for me, or if making the code work on my system required more than a few "make" commands, I would probably not be doing much with the language at all.  I suspect a lot of other novice/journeyman Perl hackers are in the same position.
</p><p>
If this code-from-elsewhere works, I don't care what it looks like.  If it doesn't work, making it work right is a time-consuming and painful task.  Fixing bona fide bugs in this code, and discovering undocumented quirks in its interfaces, and patching what breaks when I try to bolt on new functionality, keeps me quite busy enough, thank you very much.  I don't want to compund my troubles by having the language semantics shift under my feet, especially since the part of the code most likely to be affected by such a shift would probably be the part that's hardest for me to decipher.  You can blame the original authors for bad writing or for using deprecated features, but that blame doesn't help <em>me</em> any.
</p><p>
Look at C++.  If the designers of C++ had been willing to break backwards-compatibility with C, it could have been a much more elegant language -- but it would have also been a much less widely used language.  Or look at Linux.  If Linus hadn't modelled his kernel's API on Unix, it would be harder for both applications and human developers/sysadmins to move between Unix and Linux.  Or look at Perl; it came (still comes?) with scripts that convert awk/sed scripts into Perl scripts.
</p><p>
Organizations that depend on a large base of installed Perl code are great advertisements for Perl.  If these organizations can upgrade to Topaz without putting a significant workload on their in-house Perl hackers, then they'll be great advertisements for Topaz.  And remember that when these hackers have a lot of other work on their agendas, it won't take much of a workload to make them say, "oh, the heck with it, we've got better things to do than upgrade".
</p><p>
The essay <a href="http://joel.editthispage.com/stories/storyReader$117" title="editthispage.com">"Chicken and Egg Problems"</a editthispage.com> discusses how backwards compatibility can make or break a software platform; it's not 100% applicable to free software, but I commend it to your attention anyway.</p>



<h2>Re:Can the likelyhood of breakage be classified?</h2>
<h3><a href="/user/Abigail/">Abigail</a> on 2000-06-01T00:12:04</h3>
<em>It's probably more robust over the long term to
       default to calling a subroutine with the same name as an operator. </em>
<p>
Perhaps. On the other hand, AFAIK, there are no keywords in Perl that start with a capital letter, followed by a lowercase letter. If it isn't already formalized that Perl will never have mixed case keywords, it won't break anything to do so. Which means that people who want to protect themselves against suddenly have a keyword with the same name as a subroutine can use mixed case subroutines.
</p><p>
-- Abigail</p>



<h2>Re:Break, Broke, Broken</h2>
<h3><a href="/user/Abigail/">Abigail</a> on 2000-06-01T00:15:07</h3>
<em>People are going to standardize on Perl 5 just like they did COBOL II, and like
       they will ANSI C 89. </em>
<p>
People have never standardized to an old version of perl, regardless of how many code was broken. Perl 5.004 was even maintained for quite some time after perl 5.005 came out, but there wasn't any sign people were going to "standardize" on perl 5.004.
</p><p>
-- Abigail</p>



<h2>Case by case basis</h2>
<h3><a href="/user/Abigail/">Abigail</a> on 2000-06-01T00:40:13</h3>
My position is <em>it depends</em>. When I was still participating in p5p,
in almost any discussion the <em>compatability with older versions</em>
argument was being raised.
<p>
However, I found that it was used very often as a political argument.
When a chance in Perl was proposed, someone opposing the feature would
come with a construct that was claimed to be used in thousands and
thousands of programs and those programs would break. Of course, the
quoted construct you would never see in Perl usenet groups, web sites,
journals, CPAN modules or on p5p, except as an argument agains a
proposed chance. But if there was another proposal said person would
like, said person wouldn't have a twisted construct up the sleeve.
</p><p>
In the discussion about the <tt>??</tt> operator, it was pointed out to
Larry when he proposed the name <tt>??</tt> that there it was theoretically
possible a program would break. He said that for such seldomly used
constructs, he didn't care if a few programs would break.
</p><p>
And that's basically my viewpoint. It's a trade-off. Compatability is
important, but it's not the ultimate goal. If a change in Perl breaks
a very seldomly seen construct, and it has a lot to be gained, then
that shouldn't stop the change. The few programs that will break should
either be rewritten, or on a few hard disks, people will keep an older
version of Perl around. If that keeps a handful of people from programming
Perl, so be it; a lot more people will be happy.
</p><p>
But there is no point in breaking compatability if there's nothing to
be gained. <tt>$[</tt> is an often quoted example of something that can
disappear. Granted, it doesn't seem to be used often, and most people
think that assigning to <tt>$[</tt> is bad coding anyway. But what is
to be gained from removing <tt>$[</tt>? If there's nothing to be
gained, than there's no reason to break compatability. On the other
hand, introducing <tt>??</tt> might break a few programs, but there's
lots to be gained. It's one of the most requested features I've seen
in the past years.
</p><p>
Compatability changes should be considered on a case by case basis, and
the plusses and minusses should be compared. Unfortunally, I think those
are hard to quantizes objectively; only discussion could lead to an answer.
</p><p>
-- Abigail</p>



<h2>Keyword cases</h2>
<h3><a href="/user/chip/">chip</a> on 2000-06-01T01:51:41</h3>
I think it's already formalized that Perl keywords never include upper-case letters.
<p>
But I hope we can recommend a prettier style than "Myfunc($x)", because I know the mere idea of having to capitalize every function name gives me the screaming heebie jeebies.</p>



<h2>Re:Standards are the key</h2>
<h3><a href="/user/chip/">chip</a> on 2000-06-01T01:54:07</h3>
Well, Larry has basically considered defining Perl separately from the perl manpages a Bad Idea.  His comment was, IIRC: ``I will be certified before Perl is.''
<p>
Besides, if you think the C++ standardization process was a mess, just imagine an ISO Perl committee trying to decide which regex features to bless...!</p>



<h2>Re:backwards-incompatible + write-only = trouble</h2>
<h3><a href="/user/chip/">chip</a> on 2000-06-01T01:58:07</h3>
Your point is well-taken; and I had originally hoped for 100% compatibility.  Who knows, I may actually achieve it.
<p>
I think it's clear that language evolution will have to be marked in the source code.  We already have <tt>use strict</tt>, so someday we may have <tt>use large</tt> for programming-in-the-large (i.e. no language features that facilitate quick hacks at the expense of maintenance).</p>



<h2>Re:Keyword cases</h2>
<h3><a href="/user/Abigail/">Abigail</a> on 2000-06-01T04:10:44</h3>
<em>I think it's already formalized that Perl keywords never include upper-case letters.</em>
<p>
Perhaps not keywords, but there are words in Perl that have special meaning, and are written in full caps (which is why I suggested mixed case, and not full caps). CHECK might technically not be a "keyword", but if you had a sub called CHECK in your pre-5.6 Perl program, it didn't work quite as well when running it with Perl 5.6. Perl 5.005 introduced INIT. And if your program breaks because of a change like this, the technical detail of the change being a keyword or a special case identifier is of little help.
</p><p>
-- Abigail</p>



<h2>Re:Break, Broke, Broken</h2>
<h3><a href="/user/AutoPerl/">AutoPerl</a> on 2000-06-01T14:03:06</h3>
&gt;&gt;&gt; People have never standardized to
<br>&gt;&gt;&gt; an old version of perl
<br>
<br>Not yet -- but there hasn't been a version of Perl that breaks all that much, either. Version 5.6 is the first one I've upgraded to that completely destroyed my Perl development environment (and I admit I did not compile it myself but installed a binary).
<br>
<br>I'm just trying to point out the history of other languages, like C, FORTRAN, and COBOL, and how some later versions of some of these got to be largely ignored and used only in specialized cases because they broke or changed the language enough to cause problems with existing code and implementations. It's worth looking at the fate of COBOL 9x and FORTRAN 9x (and I'm sure C 9x will be similar with all the ANSI C code and compilers out there) before deciding how radical to get with Perl.
<br>



<h2>Re:Keyword cases</h2>
<h3><a href="/user/chip/">chip</a> on 2000-06-01T19:16:06</h3>
Yup, you're right.  INIT and CHECK are counterexamples.
<p>
On the other hand, if the parser could distinguish between "INIT" and "sub INIT", we could add new INIT-like features without breaking compatibility.</p>



<h2>Glitches in 5.6 upgrade?</h2>
<h3><a href="/user/chip/">chip</a> on 2000-06-01T19:18:39</h3>
Perl 5.6 ``completely destroyed'' your environment?
<p>
Would you please spell out the problems you had?  The examples could be instructive for the future.
</p><p>
Besides, I'm curious<nobr> <wbr></nobr>... I haven't deployed 5.6 myself yet, and I'd like to know what to expect.
</p><p>
On the other hand, language adaptation is much slower than language development, so just because there's an N month delay in deployment of 5.6 doesn't mean that 5.6 is doomed.</p>



<h2>Re:Break, Broke, Broken</h2>
<h3><a href="/user/glauber/">glauber</a> on 2000-06-01T22:20:36</h3>
It could be because i compiled it, but upgrading to 5.6 didn't break anything here (though i had some fun when installing a new version of DBI, later, because Makefile.PL didn't find the old DBI directory).
<br>
<br>All in all, it was painless.
<br>
<br>Of course, i ran 5.6 on a "development" machine for about 1 month before installing it on production.
<br>
<br>glauber



<h2>Don't break anything that's documented...</h2>
<h3><a href="/user/glauber/">glauber</a> on 2000-06-01T22:44:44</h3>
<p>If Topaz will be successfull, it shouldn't break any <i>documented</i> behavior. If it breaks any hacks and exploits, or if it breaks deprecated stuff so be it...</p>

<p>If you are antecipating serious compatibility problems, perhaps there could be a tool to scan a Perl 5 program and flag potential problems.</p>

<p>One of the things you are up against is, Perl 5 is <strong>very good</strong>. If Topaz breaks things, people won't have a very compelling reason to use it.</p><p>

glauber.</p><p>



<h2>Re:Break, Broke, Broken</h2>
<h3><a href="/user/Dullman/">Dullman</a> on 2000-06-02T00:04:46</h3>
There is something vaguely un-perlesque about this entire subject.  There is laziness enough, and impatience, certainly.  I think what it lacks is hubris.  Unfortunately, AutoPerl is quite right.  Out in the trenches, this is no small issue.  I, for one, shepherd a small number of perl scripts on many hosts in a large distributed environment.  They will be, I'm afraid, around for a comparatively long time.  (Hopefully, longer than their creator).  It's a major manufacturing environment and breakage is simply not an option.  I would be greatly annoyed at having to roll major changes just to upgrade perl; (such annoyance is, I believe, de rigor for perl programmers).  However, a minor change, such as "use depricated;" would not make hard what should be easy.  Surely, the language should be able to evolve without turning to a pillar of salt just for looking back; this should not have to be one of those "hard fatherly choices" which, by their very nature, upbraid the LIH philosophy.  I would feel cruelly disillusioned if the honored keepers of the flame did not rise to this challenge and give the yearning masses a technical solution that will make the hairs on the backs of their necks stand up.  There is glory and honor to be had here.  This is the hubris we have come to cherish -- and expect.



<h2>Re:Break, Broke, Broken</h2>
<h3><a href="/user/chip/">chip</a> on 2000-06-02T00:45:53</h3>
For some reason, while reading Dullman's comment, I heard The Star Spangled Banner playing in the background.
<p>
Played on kazoos.
</p><p>
Maybe I should have that looked at.</p>



<h2>Re:Don't break anything that's documented...</h2>
<h3><a href="/user/chip/">chip</a> on 2000-06-02T00:46:57</h3>
Yes, Sarathy et al set a high standard.  I wouldn't have it any other way.



<h2>Re:Glitches in 5.6 upgrade?</h2>
<h3><a href="/user/Abigail/">Abigail</a> on 2000-06-02T01:17:25</h3>
<em>Besides, I'm curious<nobr> <wbr></nobr>... I haven't deployed 5.6 myself yet, and I'd like to know what to expect.</em>
<p>
The only problem I had was that one of my JAPHs no longer works in 5.6. Unfortunally, it's one of the JAPHs I intended to include in my YAPC talk.
</p><p>
I perlbugged the issue a while ago, but there wasn't any response (not even "that's not a bug, that's actually a bugfix!") so far.
</p><p>
For the curious, the issue is that if you have <tt>*foo = *bar;</tt>, and then call <tt>foo()</tt> while neither <tt>sub foo</tt> or <tt>sub bar</tt> are defined, hence triggering <tt>AUTOLOAD</tt>, the value of <tt>$AUTOLOAD</tt> differs between 5.005 and 5.6. But I highly doubt that that is a showstopper for rolling out 5.6 in production.
</p><p>
-- Abigail</p>



<h2>Re:Glitches in 5.6 upgrade?</h2>
<h3><a href="/user/chip/">chip</a> on 2000-06-02T06:24:44</h3>
WRT interactions of glob assignment and AUTOLOAD:
<p>
To be honest, I don't <i>know</i> whether that's a bug or a bugfix.</p>



<h2>Re:Clean out the cruft</h2>
<h3><a href="/user/rodgerd/">rodgerd</a> on 2000-06-02T21:09:20</h3>
<p>You can keep running perl 4 indefinitely, too, and some people do.  But you'll notethat there are well known bugs, including security issues, with perl 4, and no-one is going to fix them.  I don't think this is a particularly valid argument; it works as a compatibility strategy while people make modifications to code to help get perl 6 going, but that's about it.</p>



<h2>Re:backwards-incompatible + write-only = trouble</h2>
<h3><a href="/user/alleria/">alleria</a> on 2000-06-02T22:36:58</h3>
While this doesn't exactly solve the problem of the already-written and only marginally supported existing codebase, it would be really nice if the core Perl 5 Porters and Perl 6 Porters could get together, and outline amount, types, of breakage. At least then warnings can be inserted into existing 5.6.x or later versions about things that might cause breakage when Topaz comes?<br> <br><br/><br/>Might smooth out the upgrade path, I think.<br> <br>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

