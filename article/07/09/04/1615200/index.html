<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org story by brian_d_foy: Jonathon Rockway throws down the gauntlet on Object::Tiny</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Jonathon Rockway throws down the gauntlet on Object::Tiny</h1>
<h2><a href="/user/brian_d_foy/">brian_d_foy</a> on 2007-09-04T11:33:00</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>In what I'm sure he meant to be a <a href="http://cpanratings.perl.org/dist/Object-Tiny">throwaway rhetorical question</a>, Jonathon asks:<p><div class="quote">&gt; Why bother when Class::Accessor::* already does the same thing?</div>  <b>OH IT'S SO ON! :)</b></p>
<p>So after writing some quick benchmarks (in the examples directory of the new Object::Tiny 1.03) and doing some investigations and tweaking (stole a small trick from Class::Accessor::Fast to make my accessors slightly faster), here is the answer to Jonathon's question, from the Object::Tiny docs.<br> <br>------------------------------------------------------------------------------<br> <br> <b> <i>Why bother when Class::Accessor::* already does the same thing?</i> </b> <br> <br>As a class builder, <a href="http://search.cpan.org/perldoc?Object::Tiny"> Object::Tiny</a> inevitably is compared to<br> <a href="http://search.cpan.org/perldoc?Class::Accessor">Class::Accessor</a> and related modules. They seem so similar, so why would<br>I reimplement it?<br> <br>The answer is that for experienced developers that don't need or want<br>hand-holding, Object::Tiny is just outright better, faster or cheaper<br>on every single metric than <a href="http://search.cpan.org/perldoc?Class::Accessor::Fast">Class::Accessor::Fast</a>, which<br>is the most comparable member of the Class::Accessor::* family.<br> <br> <b>Object::Tiny is 93% smaller than Class::Accessor::Fast</b> <br> <br>Class::Accessor::Fast requires about 125k of memory to load.<br> <br>Object::Tiny requires about 8k of memory to load.<br> <br> <b>Object::Tiny is 75% more terse to use than Class::Accessor::Fast</b> <br> <br>Using Object::Tiny requires the least possible number of keystrokes<br>(short of making the actual name Object::Tiny smaller).<br> <br>And it requires no ugly constructor methods.<br> <br>I mean really, what sort of a method name is 'mk_ro_accessors'. That sort<br>of thing went out of style in the early nineties.<br> <br>Using Class::Accessor::Fast...<p><blockquote> <div> <tt>&nbsp; package Foo::Bar;<br>&nbsp; use base 'Class::Accessor::Fast';<br>&nbsp; Foo::Bar-&gt;mk_ro_accessors(qw{ foo bar baz });</tt> </div> </blockquote> Using Object::Tiny...<p><blockquote> <div> <tt>&nbsp; package Foo::Bar;<br>&nbsp; use Object::Tiny qw{ foo bar baz };</tt> </div> </blockquote> You'll note I've been a little generate there. The alternative to<br>Repeating Yourself (which is one of those things you Don't do) is to<br>use the longer (in this case) and even uglier __PACKAGE__ compiler flag.<br> <br>Further, Object::Tiny lets you pass your params in directly, without<br>having to wrap them in an additional HASH reference that will just be<br>copied ANYWAY inside the constructor.<br> <br>Using Class::Accessor::Fast...<p><blockquote> <div> <tt>&nbsp; my $object = Foo::Bar-&gt;new( {<br>&nbsp; &nbsp; &nbsp; foo =&gt; 1,<br>&nbsp; &nbsp; &nbsp; bar =&gt; 2,<br>&nbsp; &nbsp; &nbsp; baz =&gt; 3,<br>&nbsp; } );</tt> </div> </blockquote> Using Object::Tiny...<p><blockquote> <div> <tt>&nbsp; my $object = Foo::Bar-&gt;new(<br>&nbsp; &nbsp; &nbsp; foo =&gt; 1,<br>&nbsp; &nbsp; &nbsp; bar =&gt; 2,<br>&nbsp; &nbsp; &nbsp; baz =&gt; 3,<br>&nbsp; );</tt> </div> </blockquote>  <b>Object::Tiny constructors are 110% faster than Class::Accessor::Fast</b> <br> <br>Object::Tiny accessors are identical in speed to Class::Accessor::Fast<br>accessors, but Object::Tiny constructors are TWICE as fast as<br>Class::Accessor::Fast constructors, DESPITE C:A:Fast forcing you to pass<br>by reference (which is typically done for speed reasons).<p><blockquote> <div> <tt>&nbsp; Benchmarking constructor plus accessors...<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rate accessor&nbsp; &nbsp; &nbsp;tiny<br>&nbsp; accessor 100949/s&nbsp; &nbsp; &nbsp; &nbsp;--&nbsp; &nbsp; &nbsp;-45%<br>&nbsp; tiny&nbsp; &nbsp; &nbsp;182382/s&nbsp; &nbsp; &nbsp; 81%&nbsp; &nbsp; &nbsp; &nbsp;--<br>
&nbsp; <br>&nbsp; Benchmarking constructor alone...<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rate accessor&nbsp; &nbsp; &nbsp;tiny<br>&nbsp; accessor 156470/s&nbsp; &nbsp; &nbsp; &nbsp;--&nbsp; &nbsp; &nbsp;-54%<br>&nbsp; tiny&nbsp; &nbsp; &nbsp;342231/s&nbsp; &nbsp; &nbsp;119%&nbsp; &nbsp; &nbsp; &nbsp;--<br>
&nbsp; <br>&nbsp; Benchmarking accessors alone...<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rate&nbsp; &nbsp; &nbsp;tiny accessor<br>&nbsp; tiny&nbsp; &nbsp; &nbsp;81.0/s&nbsp; &nbsp; &nbsp; &nbsp;--&nbsp; &nbsp; &nbsp; -0%<br>&nbsp; accessor 81.0/s&nbsp; &nbsp; &nbsp; &nbsp;0%&nbsp; &nbsp; &nbsp; &nbsp;--</tt> </div> </blockquote>  <b>Object::Tiny pollutes your API 95% less than Class::Accessor::Fast</b> <br> <br>Object::Tiny adds two methods to your class, <i>new</i> and <i>import</i>. The<br> <i>new</i> constructor is so trivial you can just ignore it and use your own<br>if you wish, and the <i>import</i> will shortcut and do nothing (it is used to<br>implement the <i>"use Object::Tiny qw{ foo bar baz };"</i> syntax itself).<br> <br>So if you make your own import, you can ignore the Object::Tiny one.<br> <br>Class::Accessor::Fast isn't quite as light, adding all sorts of useless<br>extra public methods. Worse, it adds them as public methods!!!<br> <br>Why on earth would you want to allow your users to add more accessors to the classes they are using at run-time?<br> <br>Here's what the classes used in the benchmark end up like.<p><blockquote> <div> <tt>&nbsp; &nbsp; DB&lt;1&gt; use Class::Inspector<br>
&nbsp; <br>&nbsp; &nbsp; DB&lt;2&gt; x Class::Inspector-&gt;methods('Foo_Bar_Tiny');<br>&nbsp; 0&nbsp; ARRAY(0xfda780)<br>&nbsp; &nbsp; &nbsp;0&nbsp; 'bar'<br>&nbsp; &nbsp; &nbsp;1&nbsp; 'baz'<br>&nbsp; &nbsp; &nbsp;2&nbsp; 'foo'<br>&nbsp; &nbsp; &nbsp;3&nbsp; 'import'<br>&nbsp; &nbsp; &nbsp;4&nbsp; 'new'<br>
&nbsp; <br>&nbsp; &nbsp; DB&lt;3&gt; x Class::Inspector-&gt;methods('Foo_Bar_Accessor');<br>&nbsp; 0&nbsp; ARRAY(0xfdb3c8)<br>&nbsp; &nbsp; &nbsp;0&nbsp; '_bar_accessor'<br>&nbsp; &nbsp; &nbsp;1&nbsp; '_baz_accessor'<br>&nbsp; &nbsp; &nbsp;2&nbsp; '_carp'<br>&nbsp; &nbsp; &nbsp;3&nbsp; '_croak'<br>&nbsp; &nbsp; &nbsp;4&nbsp; '_foo_accessor'<br>&nbsp; &nbsp; &nbsp;5&nbsp; '_mk_accessors'<br>&nbsp; &nbsp; &nbsp;6&nbsp; 'accessor_name_for'<br>&nbsp; &nbsp; &nbsp;7&nbsp; 'bar'<br>&nbsp; &nbsp; &nbsp;8&nbsp; 'baz'<br>&nbsp; &nbsp; &nbsp;9&nbsp; 'best_practice_accessor_name_for'<br>&nbsp; &nbsp; &nbsp;10&nbsp; 'best_practice_mutator_name_for'<br>&nbsp; &nbsp; &nbsp;11&nbsp; 'follow_best_practice'<br>&nbsp; &nbsp; &nbsp;12&nbsp; 'foo'<br>&nbsp; &nbsp; &nbsp;13&nbsp; 'get'<br>&nbsp; &nbsp; &nbsp;14&nbsp; 'make_accessor'<br>&nbsp; &nbsp; &nbsp;15&nbsp; 'make_ro_accessor'<br>&nbsp; &nbsp; &nbsp;16&nbsp; 'make_wo_accessor'<br>&nbsp; &nbsp; &nbsp;17&nbsp; 'mk_accessors'<br>&nbsp; &nbsp; &nbsp;18&nbsp; 'mk_ro_accessors'<br>&nbsp; &nbsp; &nbsp;19&nbsp; 'mk_wo_accessors'<br>&nbsp; &nbsp; &nbsp;20&nbsp; 'mutator_name_for'<br>&nbsp; &nbsp; &nbsp;21&nbsp; 'new'<br>&nbsp; &nbsp; &nbsp;22&nbsp; 'set'</tt> </div> </blockquote> Object::Tiny adds 2 extra methods to your class.<br> <br>Class::Accessor adds 16 extra methods, plus one extra for every accessor.<br> <br>B<br> <br>When you call B it isn't treated as some<br>sort of complete specification for the class, it's just a list of accessors<br>you want made for you.<br> <br>So if you want to customize <i>foo</i> you don't need to get into contortions with<br>"pure" base classes or calling alternate internal methods. Just make your own<br> <i>foo</i> method and remove <i>foo</i> from the list passed to the <i>use</i> call.<br> <br> <b>Object::Tiny is more back-compatible than Class::Accessor::Fast</b> <br> <br>Class::Accessor::Fast has a minimum Perl dependency of 5.005002.<br> <br>Object::Tiny has a minimum Perl dependency of 5.004.<br> <br> <b>Object::Tiny has no module dependencies whatsoever</b> <br> <br>Object::Tiny does not load ANYTHING at all outside of it's own single .pm file.<br> <br>So Object::Tiny will never get confused in odd situations due to old or weird<br>versions of other modules (Class::Accessor::Fast has a dependency on base.pm,<br>which has some caveats of it's own).<br> <br>--------------------------------------------------------------------<br> <br>So yes, Object::Tiny kicks Class::Accessor's ass all over the interpreter.<br> <br>Now personally, the question <b>I</b> think is more relvant is...<br> <br>&gt; If all you want is a bunch of simple accessors, why use a helper class at all?<br> <br>The answer is convenience. And that's why Object::Tiny exists, for times when I'm lazy and in a hurry, and I just want to press less buttons to get the same thing as I would have typed anyway.<br> <br>And for me, Class::Accessor doesn't deliver on that need.</p>


<hr/>



<h2>I'm convinced!</h2>
<h3><a href="/user/jrockway/">jrockway</a> on 2007-09-04T04:40:41</h3>
Thanks for the response<nobr> <wbr></nobr>:)<br><br>BTW, s/on/an/ in my name.



<blockquote>

<h2>Re:I'm convinced!</h2>
<h3><a href="/user/yDNA Barak/">yDNA Barak</a> on 2007-09-04T20:14:58</h3>
Janathon?





</blockquote>


<h2>Looks great!</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2007-09-04T05:49:43</h3>
<p>Regrettably, it still requires a blessed hashref, but that's a small price to pay for a prototyping tool.</p>



<h2>Passing hashref to constructor</h2>
<h3><a href="/user/melo/">melo</a> on 2007-09-04T10:10:44</h3>
Hi,

regarding<p><blockquote><div>Further, Object::Tiny lets you pass your params in directly, without
having to wrap them in an additional HASH reference that will just be
copied ANYWAY inside the constructor.</div>
</blockquote>

and<p><blockquote><div>Object::Tiny accessors are identical in speed to Class::Accessor::Fast
accessors, but Object::Tiny constructors are TWICE as fast as
Class::Accessor::Fast constructors, DESPITE C:A:Fast forcing you to pass
by reference (which is typically done for speed reasons).</div>
</blockquote>

<p>Speed is not the only reason, and I believe its not the mains reason even.</p>

<p>My reason to always pass hashrefs is that if I leave out one of the arguments, the error message from perl will tell me the exact line number where I made the mistake, and not the line inside your constructor where you assign @_ to an hash (the common approach).</p>

<p>Having said that, if your constructor checks for a even number of parameters and croaks (or Carp::Clan croaks), then the message will show the correct line number again.</p>

<p>I haven't check the Object::Tiny yet, but I will. And this will probably the first think I'll look for<nobr> <wbr></nobr>:)</p>

<p>The module looks great BTW.</p>



<blockquote>

<h2>Re:Passing hashref to constructor</h2>
<h3><a href="/user/mr_bean/">mr_bean</a> on 2007-09-05T02:42:01</h3>
<nobr> <wbr></nobr>..the error message from perl will tell me the exact<br>
&nbsp; &nbsp; &nbsp; line number where I made the mistake, and not the line inside your<br>
&nbsp; &nbsp; &nbsp; constructor where you assign @_ to an hash (the common approach).<br><br>That's what Perl Best Practices recommends too, I think,<br>although it looks terrible.



<blockquote>

<h2>Re:Passing hashref to constructor</h2>
<h3><a href="/user/melo/">melo</a> on 2007-09-05T09:57:40</h3>
Yes it is... As for the syntax, it grows on you.<br><br>But truth be told, there is no need to use that trick to get the proper error line. If module authors that accept hashes add this line:<br><br>
&nbsp; &nbsp; croak('FATAL: odd number of parameters, ') if @_ % 2;<br><br>(Use Carp qw( croak ) at the top also)<br><br>It would also work.<br><br>Best regards,





</blockquote>

</blockquote>


<h2>Object::Tiny accessors are read-only</h2>
<h3><a href="/user/dagolden/">dagolden</a> on 2007-09-04T12:12:01</h3>
<p>Unfortunately, Object::Tiny accessors are read-only.</p>

<p>So there's one little thing that Class::Accessor has over Object::Tiny.  (For about 30 seconds until Adam goes and adds it.)</p>

<p>Otherwise, Object::Tiny++</p>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/Alias/">Alias</a> on 2007-09-04T16:58:59</h3>
Accessors ARE read-only...<br><br>Frankly, I don't get this obsession people have with mutators.<br><br>90% of the time, you want to make a data object of some sort with the attributes fixed at create-time.<br><br>90% of the time, it makes little to no sense to have values changing after the object is created.<br><br>This sort of thing is silly.<br><br>my $object = Foo-&gt;new;<br>$object-&gt;param1('foo');<br>$object-&gt;param2('bar');<br><br><br>It leaves the code in a transitional state that may will be illegal.<br><br>FAR better to just provide it to the constructor, ensure the object is legal, and then keep it that way.<br><br>So in this case, no Object::Tiny won't be getting read-write accessors. It's feature bloat<nobr> <wbr></nobr>:)



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-04T18:57:47</h3>
<p>It&#8217;s not like it&#8217;s hard to write them manually. What O::T provides <em>is</em> just a simple hash-bashed object after all.</p>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/Alias/">Alias</a> on 2007-09-05T00:43:34</h3>
Exactly. The times when I do need something more complex than a trivial hash-based object with simple accessors, I don't mind writing it by hand.



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/schwern/">schwern</a> on 2007-09-05T06:01:55</h3>
You're all insane.





</blockquote>

</blockquote>


<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/schwigon/">schwigon</a> on 2007-09-05T07:26:18</h3>
&gt; Accessors ARE read-only...<br>
&gt; Frankly, I don't get this obsession people have with mutators. <br>
&gt; 90% of the time, you want to make a data object of some sort with the attributes fixed at create-time. <br>
&gt; 90% of the time, it makes little to no sense to have values changing after the object is created. <br>

<p>
I <b>strongly</b> disagree.
</p>

<p>
Accessors are invented to get control over accessing the object attributes. From where did you derive the restriction to read-only or write-only? I have <b>never</b> read such restriction in OO-related literature before.
</p>

<p>
If the user of a class starts accessing the hash elements directly, then why shouldn't he also use hash access to read them?
</p>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/runrig/">runrig</a> on 2007-09-05T21:11:47</h3>
<p><blockquote> <div><em>f the user of a class starts accessing the hash elements directly, then why shouldn't he also use hash access to read them?</em></div> </blockquote>
<p>So I don't make <code>$object-&gt;tyops()</code>. Though a tied hash would also take care of that...oh, well (without the parens, it also saves some typing)</p>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/schwigon/">schwigon</a> on 2007-09-06T06:55:30</h3>
<p>
Ha! I waited for this answer.<nobr> <wbr></nobr>:-)
</p>

<p>
So why would one protect against typos in read access but accept their chance when writing to the members?
</p>

<p>
And why don't you also want save some typing in writing?
</p>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/Alias/">Alias</a> on 2007-09-06T07:30:32</h3>
&gt; And why don't you also want save some typing in writing?<br><br>Because, at least for the things I write, writing generally Has Implications.<br><br>By having the object ALWAYS be valid and correct while in existance, it means both that anyone taking an object never has to check it, it is always correct.<br><br>But it also means that anything where they are writing to an attribute requires param-checking, validation, potentially deeper implication (flushing caches when you move a source directory) and so on.<br><br>Reading is a simple task, writing is not always so.<br><br>So I don't want to save typing there.<br><br>Or if I REALLY want to, I go up to something like Moose.<br>





</blockquote>

</blockquote>

</blockquote>


<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/malte/">malte</a> on 2007-09-05T17:52:48</h3>
Accessors are not read only. For a polymorphic system that allows transparent overloading of setter methods, writing to objects must be done via accessors too.

<p>
I would actually to so far as to that the initialization should use the accessors too (encapsulation of validation, rocket engine startup, etc.).
</p><p>
Object::Tiny should be renamed Object::Immutable::Tiny</p>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-05T19:16:56</h3>
<p>I&#8217;m not sure I follow. Did I miss the fact that O::T hides the hash from you or locks it? Or does the fact that it only provides read-accessors but not mutators somehow prevent you from writing mutators? Or something? How are O::T objects immutable?</p>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/malte/">malte</a> on 2007-09-05T19:32:50</h3>
Well, I follow one simple rule. I don't care about the object representation (Hashref, Arrayref, InsideOut, esoteric stuff,<nobr> <wbr></nobr>...) and never access instance vars accept through accessors<nobr> <wbr></nobr>... and I haven't written a simple accessor myself since 1999. So an object that doens't have setters is immutable.



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-05T21:01:13</h3>
<p>That&#x2019;s just smoke and mirrors. <em>Someone</em> has to create those mutators, and that someone needs to know about the underlying implementation.</p>

<p>It does not buy you much either. Even if you are using a method maker module to pretend not to know anything, your objects are not subclassable without knowledge of their guts any more than they would be with any other approach: subclasses must use the same method maker module to add their own accessors, so they need to need to know how the superclass is implemented. This isn&#x2019;t technically any different from subclasses containing custom-written accessors that expect a hashref as the underlying implementation.</p>

<p>Inside-out objects are the only way out of this situation, but I kinda doubt you&#x2019;ve been writing those since 1999.</p>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/schwigon/">schwigon</a> on 2007-09-06T07:09:13</h3>
<p>
Hm, you are basically arguing that I can subclass to add write accessors. For that, of course I need knowledge about internal representation.
</p>

<p>
But if O::T already <b>had</b> read/write accessors, all your subclassing would <b>not</b> have to fiddle with internal representation of members.
</p>

<p>
And if one argues, that I can add write accessors by myself, why not create an <b>Object::Really::Tiny</b> that simply does <b>nothing</b> but is <b>even more faster</b> and <b>more lightweight</b>? Think of all the freedom you get from the possibility to create all your functionality by simply subclassing from an empty class. That would be fun!
</p>

<p>
Am I getting sarcastic? Yes. Sorry for that.<nobr> <wbr></nobr>:-) Basically I mean it constructive but don't want to loose the entertaining factor of sarcasm.
</p>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-06T12:35:43</h3>
<p>I&#8217;m not sure what point your sarcasm is supposed to make. It misses the point entirely.</p>

<p>O::T is just supposed to save a bit of typing. Now how often do you need straight mutators that just assign to a variable with no validation whatsoever? If often, then something is wrong with your OO designs. If very rarely, as it should be, there&#8217;s not much point to including that functionality in O::T, since, well, it&#8217;s rarely needed.</p>

<p>So if you wanted to include mutator generation, it would require a way to specify validation. So either there is a validation API &#8211; which takes 5&times; as much code as the entire rest of the module, so you can&#8217;t call it<nobr> <wbr></nobr>::Tiny anymore &#8211;, or you let the client pass in coderefs &#8211; which does not make the client code any shorter than just writing the mutator manually.</p>

<p>Do you see any problems with that idea yet?</p>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/schwigon/">schwigon</a> on 2007-09-06T14:03:07</h3>
<p><div class="quote">I&#8217;m not sure what point your sarcasm is supposed to make. It misses the point entirely.</div>  <p>
No. I don't miss the point. And especially not "entirely". I hate it when you say that.<nobr> <wbr></nobr>:-)
</p>

<p>
Object::Tiny is by its own doc about "Class building".
</p>

<p>
"Class building" is OO. Accessors are OO. This is a good moment to repeat my question:
</p>

<p>
Please show me literature about OO where "accessors" are introduced as a read-only concept. They are used to decouple the access to the members from their implementation (hash, array, whatever).
</p>

<p><p><div class="quote">Now how often do you need straight mutators that just assign to a variable with no validation whatsoever?</div>  

<p>
Validation checks have nothing to do with the final step of assigning a value to a member.
</p>

<p>
We talk about the difference between</p><p><blockquote> <div><tt> $foo-&gt;{a} = 'bar';</tt></div> </blockquote> vs.<p><blockquote> <div><tt> $foo-&gt;a('bar');</tt></div> </blockquote> In the latter case, $foo's internal object representation can be changed from hash to whatever. In the first case not.



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-06T14:47:16</h3>
<p>So what? The only code that should need changing when you change the internal representation is the code inside the class, anyway. So for use inside the class, non-validating mutators protect against a change that is rare and involves only code that you have control over. What&#8217;s the point?</p>

<p>And exposing non-validating mutators to API clients is <em>bad</em>. I&#8217;m not sure whether you are confusing literature about Java with literature about OO, but OO is not about structs with loosely associated procedures. Objects that have no behaviour, only state, are a sign of broken OO design.</p>

<p>So is <code>$foo-&gt;a('bar');</code> supposed to do validation or not? If not, it&#8217;s either mostly pointless or you have a problem. If yes, you have no way of easily specifying validation, at least without bloating O::T.</p>

<p>So the point of generating mutators is&#8230;?</p>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/schwigon/">schwigon</a> on 2007-09-06T15:15:33</h3>
<p><div class="quote">So what? The only code that should need changing when you change the internal representation is the code inside the class, anyway.</div> This is plain wrong, at least for write access to members, which is what we are talking about. But let's start at the beginning.

<p>
Even <b>if</b> I <b>had</b> read too many Java books, the "accessor" thing is quite common. To make it more understandable I will try to explain what I understand as (one aspect of) OO. In my OO world I can change the internal representation e.g. from hashes into an ordered array.

My member "a" becomes, for instance, the 5th element of a blessed array.

Without write accessors the user of my class <b>has</b> to change his code from</p><p><blockquote> <div><tt>&nbsp; $foo-&gt;{a} = 'bar';</tt></div> </blockquote> into<p><blockquote> <div><tt>&nbsp; $foo-&gt;[4] = 'bar';</tt></div> </blockquote> If I had an write accessor "a" the user of my class can always write<p><blockquote> <div><tt>&nbsp; $foo-&gt;a('bar')';</tt></div> </blockquote> independently from whether I implemented/overloaded it as<p><blockquote> <div><tt>package Foo;<br>sub a {<br>&nbsp; my $self = shift;<br>&nbsp; my $arg&nbsp; = shift;<br>&nbsp; $self-&gt;{a} = $arg;<br>}</tt></div> </blockquote> or<p><blockquote> <div><tt>package Foo;<br>sub a {<br>&nbsp; my $self = shift;<br>&nbsp; my $arg&nbsp; = shift;<br>&nbsp; $self-&gt;[4] = $arg;<br>}</tt></div> </blockquote> That's what accessors are about. Most of the time they are hashes in the Perl world, of course. That's why it is nice to have modules that provide this, <i>Class::MethodMaker</i>, <i>Class::Accessors</i>. Once I have accessors, it's easy to subclass them or overwrite or whatever to change the behaviour of "a".

<p>
I can even add a validation to the class, and I can do this <b>transparently</b> so that even then the user of my class does not need to think about the API.
</p>

<p>
So now you may explain <b>your</b> OO.
</p>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-17T08:20:18</h3>
<p>Never ever did I say the user should write <code>$foo-&gt;{a} = 'bar';</code>. That&#8217;s wrong. But <code>$foo-&gt;a('bar')';</code> is just as wrong in terms of OO design. It increases encapsulation a tiny bit, but it does not decrease coupling. Mutators that do not validate the value they are passed are almost never necessary in a good OO design.</p>

<p>And if you do need such a mutator, then knowing that <code>$self</code> is a hash ref and using it to implement the mutator is not a problem, since that knowledge remains isolated to the class itself.</p>

<p>So there&#8217;s not much point in bloating the API of a hashref-based class builder with mutator support.</p>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/schwigon/">schwigon</a> on 2007-09-17T09:27:02</h3>
<p>
Could you please name a particular book or article where I can learn more about your often cited coupling of writing to members with forced validation provided by a general base mechanism? I'm really willing to learn about that.
</p>

<p>
In the meantime, I stick with <a href="http://search.cpan.org/user/kasei/Class-Accessor/" title="cpan.org">Class::Accessor</a cpan.org>.
</p>





</blockquote>

</blockquote>

</blockquote>


<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/Alias/">Alias</a> on 2007-09-07T08:34:54</h3>
In the entire time I have been writing Perl, I can remember changing the internal object structure (from a HASH to a SCALAR ref from memory, for speed reasons) exactly twice.<br><br>I have no problem rewriting a bunch of code in that case.





</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/Alias/">Alias</a> on 2007-09-06T00:20:34</h3>
Nope, it doesn't lock anything.<br><br>It's just that the DEFAULT implementation does not allow for -&gt;method('foo'), Object::Tiny only implements -&gt;method.<br><br>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-06T00:38:25</h3>
<p>I knew that. My question was, uhm, socratic.<nobr> <wbr></nobr><tt>:-)</tt> </p>





</blockquote>

</blockquote>

</blockquote>


<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/schwigon/">schwigon</a> on 2007-09-06T07:42:15</h3>
<p><div class="quote">90% of the time, it makes little to no sense to have values changing after the object is created.<br>
<br>
This sort of thing is silly.<br>
<br>
my $object = Foo-&gt;new;<br>
$object-&gt;param1('foo');<br>
$object-&gt;param2('bar');<br>
<br> </div>  <p>
If you would be so kind to add write accessors to <i>Object::Tiny</i> you could improve even your own code once you come to those last 10%, e.g. <i>Module::CGI::Install</i> line 130:
</p> <p><blockquote><div>$self-&gt;{cgi_path} =<nobr> <wbr></nobr>...</div>
</blockquote>

<p>
Once it had write accessors I for myself would switch to that module in favour of <i>Class::Accessors</i> which I currently had a closer look to in order to substitute an overblown <i>Class::MethodMaker</i> based module because <b>that</b> really pollutes my namespace.
</p>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/Alias/">Alias</a> on 2007-09-07T08:45:41</h3>
I find your use of "Improve" interesting, mostly because it implies both that it would be better, and additionally that there is a need to make it better.<br><br>For simple module that won't accumulate a large diversity of subclasses, I have no problem whatsoever writing to the hash element directly from within the same class that defines the property itself (You'll note I work directly with it in the <i>new</i> constructor as well).<br><br>Also, that value can also be passed in directly.<p><blockquote> <div><tt>Module::CGI::Install-&gt;new( cgi_path =&gt; '/some/path' );</tt></div> </blockquote> This is intentional.<br><br>I did consider "write accessors" (maybe we just have a terminology mixup here, I'd call that a mutator) but I couldn't see a way to implement it concisely.<br><br>If you would like to propose a patch that allows the implementation of write accessors in 3 lines of code or less, that does not require any additional characters to be used in the line...<p><blockquote> <div><tt>use Object::Tiny qw{ foo bar baz };</tt></div> </blockquote> ... then I would be happy to listen, and possibly even take the patch.<br><br>But I for one don't see any obvious way to do it, without inducing either code or API bloat (for<nobr> <wbr></nobr>::Tiny's typically aggressive use of the term 'bloat')<br>



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/schwigon/">schwigon</a> on 2007-09-07T10:25:10</h3>
<p><div class="quote">I find your use of "Improve" interesting, [...]</div>  <p>
Please pardon my way of becoming personal. I originally wanted to show code that uses O::T to make it obvious what I mean and your module was the only one I found. I did not originally intend to let it sound as personal as it does, the way I phrased it in the end.
</p>

<p>
To become more concrete, what I mean, is the following patch.

Full patch with tests is at <a href="http://renormalist.net/misc/object_tiny_write_accessors.patch" title="renormalist.net">http://renormalist.net/misc/object_tiny_write_accessors.patch</a renormalist.net>.</p><p><blockquote> <div><tt>diff -ur Object-Tiny-1.03/lib/Object/Tiny.pm Object-Tiny-1.04/lib/Object/Tiny.pm<br>--- Object-Tiny-1.03/lib/Object/Tiny.pm 2007-09-04 05:06:48.000000000 +0200<br>+++ Object-Tiny-1.04/lib/Object/Tiny.pm 2007-09-07 12:03:29.000000000 +0200<br>@@ -3,7 +3,7 @@<br> # use strict; # Enable during dev and testing<br> BEGIN {<br>&nbsp; &nbsp; &nbsp; &nbsp; require 5.004;<br>-&nbsp; &nbsp; &nbsp; &nbsp;$Object::Tiny::VERSION = '1.03';<br>+&nbsp; &nbsp; &nbsp; &nbsp;$Object::Tiny::VERSION = '1.04';<br> }<br> <br> sub import {<br>@@ -16,7 +16,7 @@<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defined and ! ref and<nobr> <wbr></nobr>/^[^\W\d]\w*$/s<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or die "Invalid accessor name '$_'";<br>-&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"sub $_ { return \$_[0]-&gt;{$_} }\n"<br>+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"sub $_ { if (defined \$_[1]) { \$_[0]-&gt;{$_} = \$_[1] } ; return \$_[0]-&gt;{$_} }\n"<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } @_;<br>&nbsp; &nbsp; &nbsp; &nbsp; die "Failed to generate $pkg" if $@;<br>&nbsp; &nbsp; &nbsp; &nbsp; return 1;</tt></div> </blockquote> It is a naive implementation, but maybe it therefore even fits to the definition of "tiny".



<blockquote>

<h2>Re:Object::Tiny accessors are read-only</h2>
<h3><a href="/user/Alias/">Alias</a> on 2007-09-10T02:18:55</h3>
I have two problems with that sort of change.<br><br>1. It makes EVERY accessor writable, which is a BAD idea. I generally require that all objects are valid at all times, so allowing anything to arbitrarily change accessors is really really nasty.<br><br>2. It makes the accessors slower (I think) because of the extra conditional.<br><br>The change I was looking for was more for keeping the default read-only, but to add additional read/write accessors.





</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>abuse of import</h2>
<h3><a href="/user/perrin/">perrin</a> on 2007-09-04T16:23:11</h3>
Class::Accessor has the advantage that it doesn't abuse import() to do something other than importing just to get a more compact syntax.



<blockquote>

<h2>Re:abuse of import</h2>
<h3><a href="/user/Alias/">Alias</a> on 2007-09-04T17:00:26</h3>
Last time I checked though, the abuse of import is hardly considered a cardinal sin on the level of, say, adding UNIVERSAL:: methods.<br>



<h2>Re:abuse of import</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-04T19:38:12</h3>
<p>Does it matter?</p>

<p>In fact, since O::T creates accessors with the given names, it&#8217;s arguable whether it&#8217;s even abuse in the first place.</p>



<blockquote>

<h2>Re:abuse of import</h2>
<h3><a href="/user/perrin/">perrin</a> on 2007-09-04T19:48:59</h3>
I find it unnecessarily confusing to use import for non-importing tasks.  It's usually done only as syntactic sugar, not because it actually needs to happen at that stage.  It's not a huge problem, but I appreciate the fact that modules like Test::More let's me use a more traditional alternative syntax.



<blockquote>

<h2>Re:abuse of import</h2>
<h3><a href="/user/jonswar/">jonswar</a> on 2007-09-05T10:18:25</h3>
What about pragmas, like strict?<br/><br/>   use strict qw(refs);<br/><br/>Would you prefer<br/><br/>   use strict;
   BEGIN { strict-&gt;enable(qw(refs)) }<br/><br/>Imports seem like a general way to parameterize the use of a module. The historical choice of the name import() shouldn't necessarily be taken as a permanent restriction on usage.



<blockquote>

<h2>Re:abuse of import</h2>
<h3><a href="/user/perrin/">perrin</a> on 2007-09-05T13:54:06</h3>
As an actual pragma, strict is kind of a special case.  It also has an actual need to get the information at compile time, unlike many uses of import which would work fine with a standard sub call.  I'd still prefer it if strict didn't look it was about to create a sub called "refs", but it's kind of too late now.



<blockquote>

<h2>Re:abuse of import</h2>
<h3><a href="/user/bart/">bart</a> on 2007-09-05T19:48:22</h3>
I like the idea of generating the accessors at compile time. In that regard, is is a <em>lot</em> like importing.





</blockquote>


<h2>Re:abuse of import</h2>
<h3><a href="/user/ysth/">ysth</a> on 2008-01-07T02:15:57</h3>
Well, since strict "refs" is lexically scoped, there <em>is</em> no BEGIN { } equivalent possible (see the block there?).  Perhaps use constant is a better example.





</blockquote>

</blockquote>

</blockquote>


<h2>Re:abuse of import</h2>
<h3><a href="/user/dagolden/">dagolden</a> on 2007-09-04T19:47:03</h3>
<p>To be clear, the abuse in import is the @ISA manipulation.</p>

<p>Otherwise, the import is passed a list of methods and Object::Tiny creates them in the caller's namespace.  That they happen to be created on the fly instead of mapped to subroutines defined in Object::Tiny doesn't really matter, in my opinion.</p>



<blockquote>

<h2>Re:abuse of import</h2>
<h3><a href="/user/Alias/">Alias</a> on 2007-09-05T00:47:07</h3>
base.pm manipulates @ISA in it's import method...<br>





</blockquote>

</blockquote>


<h2>POD</h2>
<h3><a href="/user/miyagawa/">miyagawa</a> on 2007-09-04T18:08:46</h3>
You might want to move the POD document to a separate<nobr> <wbr></nobr>.pod file or inline them before __END__, so it doesn't increase the memory usage.<br><br>The document is a few kilobytes but apparently that would be a bit siginificant for your<nobr> <wbr></nobr>::Tiny module if you want to claim the small memory footprint<nobr> <wbr></nobr>:)



<blockquote>

<h2>Re:POD</h2>
<h3><a href="/user/miyagawa/">miyagawa</a> on 2007-09-04T20:36:47</h3>
Well, scratch this silly comment<nobr> <wbr></nobr>:) I remember I've heard that Perl allows a run-time access to the POD document tree in some of the past YAPCs but cant find the reference to it anymore. I guess it doesn't matter as long as you use __END__. I might be wrong again<nobr> <wbr></nobr>:)



<blockquote>

<h2>Re:POD</h2>
<h3><a href="/user/Alias/">Alias</a> on 2007-09-05T00:48:03</h3>
It's probably a good idea anyway, it might save reading an extra block from the filesystem<nobr> <wbr></nobr>:)





</blockquote>

</blockquote>


<h2>Spelling/etc mistakes</h2>
<h3><a href="/user/Alias/">Alias</a> on 2007-09-05T00:55:36</h3>
I should comment for anyone reading this on the use.perl.org front page that I tend not to proof journal entries, because I don't expect them to end up on the front page<nobr> <wbr></nobr>:)<br><br>There's a cleaned up revised version in my actual journal page.<br>



<h2>accessors.pm</h2>
<h3><a href="/user/srezic/">srezic</a> on 2007-09-05T08:06:36</h3>
Can you make a similar comparison between Object::Tiny and accessors.pm? At least this module uses the same syntax as Object::Tiny, declaring accessors in the "use" line.



<blockquote>

<h2>Sure</h2>
<h3><a href="/user/Alias/">Alias</a> on 2007-09-05T15:45:37</h3>
Will do, stay tuned.<br>





</blockquote>


<h2>Hmm...</h2>
<h3><a href="/user/siracusa/">siracusa</a> on 2007-09-08T00:15:28</h3>
Object.pm in Rose::Object has fewer lines of code and does even less!  It's no Object::Really::Tiny, though<nobr> <wbr></nobr>;)



<h2>Class::Accessor::Classy</h2>
<h3><a href="/user/Eric Wilhelm/">Eric Wilhelm</a> on 2007-09-09T06:15:13</h3>
1.  You can subclass it -- subclass<nobr> <wbr></nobr>:= customize.<br><br>2.  It is ridiculously fast.<br><br>3.  The new() method is optional (think multiple inheritance.)<br><br>4.  Immutable (set-once) mutator support.<br><br>5.  Terse, declarative syntax.<br><br>6.  It doesn't want to be your subclass.<br><br>7.  Zero namespace pollution.<br><br>8.  Properly named setters.<br><br>9.  Supports truly private methods.<br><br>10.  Class accessors, constants, etc.<br><br>
&nbsp; &nbsp; package My::Class;<br>
&nbsp; &nbsp; use Class::Accessor::Classy;<br>
&nbsp; &nbsp; with 'new';<br>
&nbsp; &nbsp; ro qw(foo bar);<br>
&nbsp; &nbsp; rs baz =&gt; \ (my $set_baz);<br>
&nbsp; &nbsp; rw qw(bop boop bip);<br>
&nbsp; &nbsp; ri qw(this that);<br>
&nbsp; &nbsp; ro_c suitcase =&gt; 'red';<br>
&nbsp; &nbsp; constant seven =&gt; 7;<br>
&nbsp; &nbsp; constant eight =&gt; this-&gt;seven + 1;<br>
&nbsp; &nbsp; no Class::Accessor::Classy;<br><br>I designed it to be usable in a large system with lots of inheritance (dotReader) and it is rather battle-hardened at this point.<br><br>No, it is not as fast as Object::Tiny, but it is faster and does more than Class::Accessor::Fast.<br><br><a href="http://scratchcomputing.com/tmp/object_tiny_benchmark.pl" title="scratchcomputing.com">http://scratchcomputing.com/tmp/object_tiny_benchmark.pl</a scratchcomputing.com>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

