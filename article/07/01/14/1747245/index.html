<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org story by brian_d_foy: Perl 6 Design Team Minutes for 10 January 2007</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Perl 6 Design Team Minutes for 10 January 2007</h1>
<h2><a href="/user/brian_d_foy/">brian_d_foy</a> on 2007-01-14T18:07:00</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>The Perl 6 Design team met via phone on 10 January 2007. Larry, Damian, Allison, Jesse, Nicholas, and chromatic attended. These are the notes.</p>
<p><p> <strong>Allison:</strong> </p> <p><ul>
<li>things are quite well</li>
<li>worked on Punie some</li>
<li>adding a few more features: subroutines in specific</li>
<li>went astoundingly quickly</li>
<li>a few small IO questions remaining</li>
<li>sort of a lazy evaluation on the list</li>
<li>thank you for your comment yesterday</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>I sent another one today</li>
<li>how much abstraction do you want?</li>
<li>there are ways to hide things that may or may not buy you any performance</li> </ul>

<p> <strong>Allison:</strong> </p> <p><ul>
<li>the next thing we need before implementing the PDD is the objects PDD</li>
<li>I've been working on that this week</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>things are quiet here</li>
<li>took some time off</li>
<li>doing a lot of family stuff</li>
<li>that'll continue into the foreseeable future</li>
<li>sending tiny bits of feedback to Larry on occasion</li>
<li>mostly very happy with what I've seen</li>
<li>otherwise starting to gear up for the year ahead</li>
<li>want to get the POD 6 parser out</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>seems to be some demand for that</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>it's high on my priority list</li>
<li>taking some down time to feel better and ramp up</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>mostly recovered from my own bout with the crud</li>
<li>this one seems to asymptotically approach asymptomatic</li>
<li>alternately horrifying and pleasing Damian in absentia</li>
<li>have most of the re-think of smart matching done</li>
<li>moved on to reading and re- and re-re-reading the MMD draft</li>
<li>is it possible, optimizable, and teachable?</li>
<li>is there a different angle to approach it that's easier to explain but has well-defined semantics and is teachable that I can understand?</li> </ul>

<p> <strong>c:</strong> </p> <p><ul>
<li>is it Luke's pure proposal?</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>a bunch of people hashed it out based on that</li>
<li>you don't calculate distance</li>
<li>that doesn't work well with roles and subtypes</li>
<li>you can just say that this is narrower or wider than this one</li>
<li>you have to avoid too many ties</li>
<li>we've always had these semicolons that do this Australian preference voting</li>
<li>count my vote here only if there's a problem with my first preference</li>
<li>seems to be a decent notional way to solve these things</li>
<li>but the devil is in the details</li>
<li>the current draft lets all of the candidates vote</li>
<li>they each have to keep their own scorecard as to what they think counts</li>
<li>there may be a different way of looking at the same thing that involves going forward with a series of semicolons terminating</li>
<li>then finding a tie and backing up to a previous set of semicolons and revote</li>
<li>I'm trying to reformulate that in words to see if it means the same thing and is easier to grok</li>
<li>also trying to keep Flavio on track for the MiniPerl bootstrap</li>
<li>hopefully his direction will also be complementary to the world of Parrot</li> </ul>

<p> <strong>Jesse:</strong> </p> <p><ul>
<li>has he been making much progress?</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>he's sort of a Lewis and Clark type</li>
<li>blazing the initial trail</li>
<li>it's hard to stop him</li>
<li>he's working on KP 6, or Kinda Perl 6</li>
<li>next step of getting a compiler written in Perl 6 that looks like Perl 6</li>
<li>coming at it orthogonally</li>
<li>trying to get a platform-agnostic bootstrap</li>
<li>Patrick and Allison have more or less a bottom-up bootstrap</li>
<li>Haskell was the top-down bootstrap</li>
<li>but it's hard to find people who like Perl and work on Haskell</li>
<li>it does seem like it's converging and will happen eventually</li>
<li>the holidays were tough for sickness and holidays and the Taiwan earthquake</li>
<li>Audrey's been out of touch</li>
<li>the MOP folks have been on hiatus</li>
<li>I suspect they'll pick up shortly</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>the semicolon thing sounds ambiguous and hard to understand</li>
<li>it scares me that it'll end up in the C++ problem</li>
<li>is it a function declaration or what?</li>
<li>those ambiguities make C++ hateful</li>
<li>maybe some of these optional things shouldn't be</li>
<li>but you know better than me</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>it may be best practice, by convention at least, to avoid putting semicolons in contradictory places</li>
<li>we have to give Damian something to work with for <em>Perl 6 Best Practices</em> </li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>I was just hoping it would be a pamphlet</li> </ul>

<p> <strong>Jesse:</strong> </p> <p><ul>
<li>the People's Coup of Parrot appears to be proceeding cleanly</li>
<li>Jerry will cut the next release next week</li>
<li>we'll have a new pumpking every month</li>
<li>the cabal now has Parrot permissions</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>you just pass the pumpkin and when the music stops, you make a release?</li> </ul>

<p> <strong>Jesse:</strong> </p> <p><ul>
<li>that's right</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>Jerry's sure demonstrated that he's a trooper</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>just observations about the current MMD resolution proposal</li>
<li>I echo Larry's concerns about the high probability of ambiguity</li>
<li>under the scheme, the proposed solution is "insert more semicolons"</li>
<li>that leads to a leftmost-argument wins scheme</li>
<li>other languages have tried that and found it wanting</li>
<li>many of the few languages that have multi-methods use that scheme</li>
<li>look at the first argument and choose the best match at that point, then the next point, then....</li>
<li>that's unsatisfactory</li>
<li>it biases the selected method toward the first argument</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>doesn't get you much over nested switch statements</li>
<li>S12 still talks about marking the default</li>
<li>I don't think we would lose that</li>
<li>it's not in the proposal, but I think they say that when you end up with a tie that no one specified a default</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>if your only resolution mechanisms are to go to a global default or to go with left- (or, equally right-) most wins</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>I was thinking of the default being local to the current ambiguity set</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>multiple defaults for current semicolon levels?</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>sort of orthogonal to whether there are semicolons there or not</li>
<li>number + int versus int + number</li>
<li>there's a num + num too</li>
<li>maybe this is a bad example</li>
<li>you could mark one of the two symmetrical ones as the default</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>for that particular ambiguity set</li>
<li>I'd really like to see a syntax for that</li>
<li>challenging</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>just an "is default" declaration maybe</li>
<li>if you get an ambiguity, you'll always take the most specific default that is in the list of permissible candidates</li>
<li>I think that works</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>and if they're ambiguous?</li>
<li>they will be</li>
<li>I can see two equally specific defaults turning up</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>then you're no worse off than you were before</li>
<li>to some extent, I want to say that we can define all of this mechanism, but most multimethods will only have two things with named options maybe</li>
<li>most people will put a prototype in their so their compiler can figure out what the call will look like anyway</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>we're definitely dealing with edge cases here</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>how much embroidery do we want to handle to nail down the edge cases?</li>
<li>if we can figure out the most specific candidate, we'll call that</li>
<li>if we can't, we won't</li>
<li>it's usually obvious, when you compare any two things, which is strictly narrower than the other one</li>
<li>beyond that, you're getting into heavy magic and you want to learn some more</li>
<li>most people don't want that</li>
<li>those specific rules might not even go in the Camel book</li>
<li>go read this file for the nitty-gritty details</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>do we have to nail down all the edge cases yet?</li>
<li>if it dies with ambiguity, then people using Perl 6 will start to produce ambiguities</li>
<li>we'll have a lot of use cases to work out which way it should be</li>
<li>there may be a danger of picking arbitrary rules that surprise people</li>
<li>you have to treat this as an N-dimensional search</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>we probably don't know enough yet</li>
<li>the fact that we defined this to start with lexical scope</li>
<li>we can substitute in different policies in lexical scopes</li>
<li>maybe deprecate the current policy in favor of a new policy in a new version</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>but pointing people to a file might get you to the Perl 5 problem where the implementation specifies the behavior</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>unless you version the file</li> </ul>

<p> <strong>Jesse:</strong> </p> <p><ul>
<li>I thought it would be a Synopsis</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>I thought you meant a source file!</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>there is a conflict between the definer of a set of multimethods and the user of the set</li>
<li>they could expect different semantics</li>
<li>we have to make some minimal attempt at defining some mechanism that will work from the view of the person defining the set</li>
<li>we can't leave it only up to the user</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>when you said "lexical scope" I thought you meant the person defining</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>and I thought calling, but....</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>just hate to get into the Perl 5 trap of having to worry about changing anything because it breaks someone's code</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>if you rely on an old semantic, then you have to request that that interface give you that version of semantics</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>how do you know when the current becomes old?</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>either you default to the current</li>
<li>or if the current changes, you start a deprecation cycle</li>
<li>we'll change the semantics, but we'll pay attention to the requested version of the semantics</li>
<li>that and a higher bar for CPAN modules specifying their version</li>
<li>we require anything going into the library to have a version number</li>
<li>you can build a Foo.pm without a version number and use it</li>
<li>but installing anything into an official library requires a version number</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>regardless of the MMD algorithm that you choose, you can always resolve ambiguities by declaring another variant</li>
<li>if your application defines a number of variants and you get ambiguities, you can always define more specific variants</li>
<li>even if they do nothing more than wrap a particular variant that you want</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>that's perhaps the best way to do it</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>maybe "is default" means "autogenerate this for me"</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>you get one of those for free</li>
<li>any more you have to pay for yourself</li>
<li>in that regard, we don't have to get all of the edge cases</li>
<li>different people will have completely different intuitions</li>
<li>people will think about this in entirely different ways</li>
<li>the current proposal uses a voting metaphor</li>
<li>the earlier proposals I had thought in terms of multidimensional vectors</li>
<li>they're two entirely different approaches to the thing</li>
<li>maybe 80% of the time they end up with the same answer</li>
<li>it's not necessary for us to define the edge cases, except to document that writing another variant will do what you expect</li>
<li>the deeper problem is teachability</li>
<li>even if you don't give them an algorithm, you have to give them a metaphor</li>
<li>one comes from sociology and one comes from physics</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>a lot of people think they understand voting, but they don't</li>
<li>a lot of people know they don't understand vector math</li> </ul>

<p> <strong>c:</strong> </p> <p><ul>
<li>is there a lightweight way to declare a specific variant signature that aliases to a general case?</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>you'd have to use the &amp;name variant which includes an addendum</li>
<li>doesn't look like a normal variation of a new sub</li>
<li>or maybe we allow you to start with a normal declaration but instead of a body it's <code>::=</code> something else</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>or when you have an MMD variant whose body consists of entirely a call or a magic goto, you optimize it</li>
<li>it'd be nice to have a proper syntax with the referential nature</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>but with the dynamic wrapping, someone can change the definition and expect its definition to be the one</li>
<li>hopefully the binding type thing will cause the compiler to cause hissy fits</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>the other problem with doing the thing in the body is that you'll do the dispatch again</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>notionally it's done with the magic goto</li>
<li>you'll expect the call frame on the stack</li>
<li>or you're lying and inconsistent</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>a compile-time referential assignment is an excellent idea</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>we have syntax, but it may not be optimal</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>has Sage shown any more interest in 5 to 6?</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>he's pretty busy with school</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>is he still in contact?</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>I see him on IRC rarely</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>Damian, has it really been that quiet for the Perl 6 POD reception?</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>yes</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>good</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>yes</li>
<li>I did have a couple of offline comments which I addressed in the second draft</li> </ul>

<p> <strong>c:</strong> </p> <p><ul>
<li>have you given any thought to using metaroles instead of metaclasses in the objects PDD?</li> </ul>

<p> <strong>Allison:</strong> </p> <p><ul>
<li>I'm still thinking of separating those currently</li>
<li>although...</li>
<li>I hadn't been thinking of making separate metaobjects for both</li>
<li>I thought of making them a single core meta thing</li>
<li>I wasn't going to call it meta</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>anything you can do, I can do meta</li> </ul>

<p> <strong>c:</strong> </p> <p><ul>
<li>I never meta-model that wasn't obsessed with reflection</li> </ul>

<p> <strong>Damian:</strong> </p> <p><ul>
<li>that's why I took a month off</li> </ul>

<p> <strong>Nicholas:</strong> </p> <p><ul>
<li>the existence of interfaces in Java lessens the need for multiple inheritance</li>
<li>does the existence of roles in Perl 6 make multiple inheritance less necessary?</li> </ul>

<p> <strong>Larry:</strong> </p> <p><ul>
<li>yes</li> </ul>

<p> <strong>c:</strong> </p> <p><ul>
<li>hope so</li>
</ul></p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

