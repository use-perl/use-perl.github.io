<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of luqui: The fourth paradigm is...</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>The fourth paradigm is...</h1>
<h2><a href="/user/luqui/">luqui</a> on 2005-11-19T09:26:48</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>Okay, I thought about this some.  I walked around the house, talked to myself, played with some fresh fruit (moving them here and there, describing their properties), and I think I've come up with a very vague idea of this fourth control paradigm.<br/><br/>First, here's how I started.   I figured, I'm trying to classify the three existing control paradigms (imperative, functional, logical) into two orthogonal properties.  Well, it has to be one of these:<br/><br/><pre>
      A              B
X | Imperative | Functional |
Y | Logical    | ???        |<br/><br/>      A              B
X | Functional | Imperative |
Y | Logical    | ???        |<br/><br/>      A              B
X | Logical    | Functional |
Y | Imperative | ???        |
</pre><br/><br/>That covers all the possible cases.  I then did a little scanning back and forth, and settled on the second diagram, where A ~~ "doesn't change anything" and B ~~ "does change something".  Then I did some brainstorming to figure out what X and Y were based on that.<br/><br/>And I think this is it:  You give a functional program an object, and it tells you some property of the object (these can be very complex objects and properties, but it ultimately reduces to that).  You give a logical program a property, and it gives you an object that satisfies that.<br/><br/>Then, the imperative parallel is:  You give an imperative program an *action* and it tells you the result.  So, the fourth paradigm is the converse of this; a generalized inverse kinematics engine: you give it a result, and it tells you the action.<br/><br/>A prime example of this kind of paradigm is the UNIX <tt>diff</tt> program.  You give it a file, and the result of some action on that file, and it tells you how to modify the original to get the result.  Also, in gaming, pathfinding and inverse kinematics (the process of finding how to move, say, a human body from one position to another in a physically sound way) are both examples of this paradigm.<br/><br/>So what does a language that enables this paradigm look like?  And what would you name it?</p>


<hr/>



<h2>FWIW</h2>
<h3><a href="/user/cog/">cog</a> on 2005-11-19T13:26:08</h3>
FWIW, back at Uni we actually have the following classes: Programming Paradigms I, II, III and IV.<br><br>What we learn in these classes is, respectively, Functional, Imperative, Logic and OO programming.<br><br>In my case, this was done mostly with Haskell, C, Prolog and Java (sometimes they change the languages).<br><br>There was also a teacher who used to say that databases are a paradigm on its own.<br><br>Also, I was first introduced to Perl in the classes of "Scripting as a Programming Paradigm".



<blockquote>

<h2>Re:FWIW</h2>
<h3><a href="/user/luqui/">luqui</a> on 2005-11-19T22:51:17</h3>
&gt; What we learn in these classes is, respectively,<br>&gt; Functional, Imperative, Logic and OO programming.<br><br>Yep, those are the four that I identified in my last post.  However, I argue that OO is an "abstraction style", and not a "control style", which is what I'm looking for.



<blockquote>

<h2>Re:FWIW</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2005-11-22T01:04:49</h3>
<p>If you want a control style, where does event-driven programming fit?  What if it's asynchronous?</p>



<blockquote>

<h2>Re:FWIW</h2>
<h3><a href="/user/luqui/">luqui</a> on 2005-11-23T09:00:22</h3>
&gt; If you want a control style, where does<br>&gt; event-driven programming fit? What if it's<br>&gt; asynchronous?<br><br>I define the control paradigm by the input (code) and the output (what happens when you run it).  In the event driven case, you give it actions to execute when certain things happen.  But the first part is the important part, you're giving it actions, and it tells you what happens when those actions are executed, even though those actions are triggered rather than sequenced.  Therefore, I think event-driven programming is a form of imperative, which isn't surprising, since most programming these days is imperative (it is a, er, logical thing to program in, because it maps most closely to what the computer actually does).<br><br>However, the point of this little exercise was to identify the binary dimensions on which the different languages lie.  So maybe event-driven programming is one of those dimensions:<br><br>
&nbsp; &nbsp; &nbsp; &nbsp; Event-driven functional: Compute what properties of the world change as objects are introduced and removed  (this is what I called <a href="http://luqui.org/blog/archives/2005/08/03/logically-backwards-and-forwards/" title="luqui.org">forward-chaining logic</a luqui.org>, and I want a system that does it badly!)<br>
&nbsp; &nbsp; &nbsp; &nbsp; Event-driven logical: Compute the set of objects satisfying a property continually as objects are introduced and removed<br>
&nbsp; &nbsp; &nbsp; &nbsp; Event-driven imperative: Do stuff to the world as you detect it change<br>
&nbsp; &nbsp; &nbsp; &nbsp; Event-driven logiparitive (or whatever this fourth control style is called):  Compute the changes the world is undergoing as it changes<br><br>Some of those are a little bit stretchy, but it kinda seems to work.<br><br>As far as asynchronous programming, I think that's definitely a binary dimension, as it is referring to the *order* in which things are done (which serial or parallel), and the control style doesn't refer to that at all.  I have also seen asynchronous functional languages and logic engines, so it seems like it can be put into any paradigm (though async Haskell is all within the IO monad, so it's arguable whether it really fits in the functional world).





</blockquote>

</blockquote>

</blockquote>


<h2>Hmm...</h2>
<h3><a href="/user/autrijus/">autrijus</a> on 2005-11-20T15:26:11</h3>
I'll probably call it <em>autonomous</em> programming, or even <em>proof-assisted</em> programming.



<blockquote>

<h2>Re:Hmm...</h2>
<h3><a href="/user/Ruud/">Ruud</a> on 2005-11-21T21:51:25</h3>
I was thinking in the direction of Genetic Algorithms: the programming is in the training.



<h2>Re:Hmm...</h2>
<h3><a href="/user/n1vux/">n1vux</a> on 2005-11-21T22:07:10</h3>
Genetic algorithms, and also perhaps other relaxation / constraint techniques like the Simplex method of Linear programming?



<blockquote>

<h2>Re:Hmm...</h2>
<h3><a href="/user/luqui/">luqui</a> on 2005-11-23T09:10:26</h3>
&gt;  Genetic algorithms, and also perhaps other<br>&gt; relaxation / constraint techniques like the<br>&gt; Simplex method of Linear programming?<br><br>The only thing I know about linear programming is that my grad-student friend is taking a course in it and he's working his ass off...<nobr> <wbr></nobr>:-)<br><br>Genetic algorithms are an interesting idea for this control style.  My thinking (and my <a href="http://svn.luqui.org/svn/misc/luke/work/code/haskell/funlog/" title="luqui.org">toy implementation</a luqui.org>) was that you would specify a class of functions, and it would find which function in that class that mapped a given input to a given output.  But it could be argued that that's just logic programming (find me function objects that satisfy the constraint that they map this input to this output).  Genetic algorithms take a bunch of inputs and outputs and try to find the most general function that covers all of them, which seems closer to the mark, in that it is farther from logic programming.  Genetic algorithms are a specific "solution method" to this style of problem.  I wonder what the others are...





</blockquote>

</blockquote>


<h2>I should have read this before replying before</h2>
<h3><a href="/user/Crag/">Crag</a> on 2005-11-27T20:32:35</h3>
I like your logic, but I don't know how you'd make a programming language out of that fourth type.  But then, I don't grok logical programming either, so maybe it's just me.



<h2>The fourth paradigm</h2>
<h3><a href="/user/Trieu/">Trieu</a> on 2005-12-01T04:59:20</h3>
I liked the logic. When you give the fourth paradigm a result. There might be so many *actions* corresponding to that unique result.
So, the next step is that, which actions should be the best. --&gt; Optimization?<br/><br/>(Hey, assume that the 4th paradigm was made<nobr> <wbr></nobr>:-)





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

