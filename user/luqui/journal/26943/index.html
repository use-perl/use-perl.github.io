<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of luqui: Silly Academia</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Silly Academia</h1>
<h2><a href="/user/luqui/">luqui</a> on 2005-09-30T01:53:31</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>While reading "Ordered Attribute Grammars, Uwe Kastens, 1980", I came across this description of one of the functions he was using in his example:<br/><br/>include(a,d): "a" is a set of descriptions, "d" is a description; the result is "a U {d}" if a does not contain a description "d'" for the same identifier described by "d", "{a\{d'}} U {d}" otherwise.<br/><br/>(I used U for union and \ for difference)<br/><br/>Stare at that for a little while.  You can probably figure out what it's saying within a few minutes.  But how about:<br/><br/>include(set,desc): "set" is a set of descriptions, "desc" is a description; if "set" already contains a description with "desc"'s identifier, it returns "set" with that description replaced by "desc".  Otherwise it returns "set" with "desc" added.<br/><br/>If the author weren't so attached to keeping everything set-theoretic, you could say that a is a dictionary from names to descriptions, and make it even easier to read. <br/><br/>More recent papers have the same kind of purely mathematical language, formulating everything in terms of sets, using single uppercase letters for set names and single lowercase letters for variables.  Anybody who programs that way is scolded by the community for producing unreadable and unmaintainable code.  Yet academic papers, which have much more respect than programmers, continue to use this cryptic notation.  These papers don't deserve respect.<br/><br/>It's because of this mathematical-notative culture that Haskell uses all the cutting-edge research and the dynamic languages are stuck re-inventing Smalltalk.  It's not that the new research is so hard to implement, it's that it's documented incomprehensibly.  PhDs in Haskell read papers and write the algorithms they describe just like everybody else, but they're trained in reading this dense academic language.<br/><br/>And of course, when I eventually do my dissertation, if I don't write this way my dissertation will be rejected and I won't get my degree.  I won't think of the problem I solve purely in terms of sets and single-letter variables, I'll think of it in terms of computer science concepts, which have English names.  I'll have to convolve my ideas into mathematical academic language, only to have other academics untangle them back into everyday computer science concepts as they read.<br/><br/>Computer science academics need to retake Freshman writing.</p>


<hr/>



<h2>Much agreed</h2>
<h3><a href="/user/geoffrey/">geoffrey</a> on 2005-09-30T10:22:43</h3>
Totally right there.  I just don't have the attention span to read that crap, so I tend to miss out.<br><br>I think part of the problem is that academic papers are not yet optimized for the networked way of doing things.<br><br>Aside from way too many being in PDF (*SIGH*), most assume you're coming to them from a background in the field, rather than that you just came from a Google search or a link posted on IRC.<br><br>"No, thank you, I don't want to have to spend 15 hours trying to read enough Wikipedia articles to understand the obtuse jargon and silly formulas strewn throughout.  Yes, I'm sure it's nice and consise.  Waste a few thousand bits on some extra words.  They're cheap, you know."<br>



<h2>mixing the code and the documentation</h2>
<h3><a href="/user/jmm/">jmm</a> on 2005-09-30T13:30:46</h3>
An acedemic paper is a curious mix of (in programming terms) code and documentation.  It has to be a precise description that can be duplicated by others (i.e. code), but it also has to be understood intellectually by the reader (i.e. documentation).  The set theoretic notation is compact and precise, working better as the code formulation; your "translation" works better as the documentation formulation.  Best would be to have both, perhaps in a two column layout with the prose "documentation" in one column and the set theoretic "code" beside it in the other column.



<h2>Ideal point between &quot;verbose&quot; and &quot;cryptic&quot;?</h2>
<h3><a href="/user/naughton/">naughton</a> on 2005-09-30T17:31:05</h3>
<p>
<i>More recent papers have the same kind of purely mathematical language, formulating everything in terms of sets, using single uppercase letters for set names and single lowercase letters for variables. Anybody who programs that way is scolded by the community for producing unreadable and unmaintainable code. Yet academic papers, which have much more respect than programmers, continue to use this cryptic notation.</i>
</p>
<p>
Ironically, this reminds me of all those critics who dismiss Perl as "line noise."<nobr> <wbr></nobr>;^) Many of us dismiss that criticism as knee-jerk and ignorant, but I think it brings up serious questions: For a given audience, is there an ideal point between verbosity and cryptic, completely symbolic notation? If so, how do we find that point? I'd love to know @Larry's answers to those questions for Perl6.
</p>
<p>Here are some of my thoughts.</p>
<p>
Possibly due to my humble BS in Mathematics, I've never been scared by Perl's sigils and heavy use of symbolic operators, and often prefer such syntax. I often ask, would you really rather have this
</p>
<p> <code>two plus two equals four</code> </p>
<p>than this</p>
<p> <code>2 + 2 = 4</code> ?</p>
<p>Sometimes I suspect the "line noise" critics secretly want to make all languages look like COBOL. We often complain about not wanting to type such verbose code, but I often don't want to <i>read</i> it, either. In the above case I actually find the symbolic notation easier to read and understand.
</p>
<p>
I first started thinking about this when comparing modern re-statements of Euclid's proof of the inifitude of primes, like this one
</p>
<p><blockquote>
<div>Assume there are a finite number, n, of primes, the largest being pn. Consider the number that is the product of these, plus one: N = p1...pn+1. By construction, N is not divisible by any of the pi. Hence it is either prime itself, or divisible by another prime greater than pn, contradicting the assumption. [1]</div>
</blockquote>

<p>
to Euclid's original, much more <a href="http://aleph0.clarku.edu/user/djoyce/java/elements/bookIX/propIX20.html" title="clarku.edu">verbose version</a clarku.edu>. What this example also shows is that sometimes symbolic notation may help us to understand and/or express ideas that would be extremely difficult to handle otherwise:
</p>
<p><blockquote>
<div>Euclid sometimes wrote his "proofs" in a style which would be unacceptable today--giving an example rather than handling the general case.  It was clear he understood the general case, he just did not have the notation to express it.  His proof of this theorem is one of those cases. [2]</div>
</blockquote>

<p>
OTOH, these statements provoke opposing thoughts:
</p>
<p>
<i>It's because of this mathematical-notative culture that Haskell uses all the cutting-edge research and the dynamic languages are stuck re-inventing Smalltalk. It's not that the new research is so hard to implement, it's that it's documented incomprehensibly. PhDs in Haskell read papers and write the algorithms they describe just like everybody else, but they're trained in reading this dense academic language.</i>
</p>
<p>
<i>And of course, when I eventually do my dissertation, if I don't write this way my dissertation will be rejected and I won't get my degree.</i>
</p>
<p>
Despite what the "experts" may say, I often doubt that all the abstractions, symbolic and otherwise, in certain fields serve any useful purpose. I suspect some of them serve only as a high barrier to entry, keeping the wealthy and powerful free to pursue leisurely lives of intellectual musings, safe from competition from the rabble outside their gated, master-planned communities.
</p>
<p>1. <a href="http://www-users.cs.york.ac.uk/user/susan/cyc/p/primeprf.htm" title="york.ac.uk">http://www-users.cs.york.ac.uk/user/susan/cyc/p/primeprf.htm</a york.ac.uk>
</p>
<p>2. <a href="http://primes.utm.edu/notes/proofs/infinite/euclids.html" title="utm.edu">http://primes.utm.edu/notes/proofs/infinite/euclids.html</a utm.edu>
</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

