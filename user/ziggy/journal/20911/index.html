<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of ziggy: On Learning Smalltalk</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>On Learning Smalltalk</h1>
<h2><a href="/user/ziggy/">ziggy</a> on 2004-09-17T04:06:13</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>Hm.  The <a href="http://use.perl.org/user/Ovid/journal/20854">Smalltalk thread</a> continues.  Thankfully, it hasn't degenerated into a flame war.  
<p>
Ovid says <a href="http://use.perl.org/comments.pl?sid=22487&cid=34361">in a comment</a>: 
<blockquote><i>
In fact, the only reason SmallTalk really interests me right now is the "pure" OO model that I keep hearing people talk about. However, I'm brushing up on my Java because that's where the bulk of the work is. Until I hear convincing arguments about how SmallTalk can improve my professional life, I'll probably just wonder about it. I have a pretty active social life, so I don't have as much time for research as I would like. 
</i></blockquote>
Ovid, let me tell you without reservation, <b>learning smalltalk will improve your professional life</b>.  Here's why.
<p>
First of all, in <a href="http://www.pragmaticprogrammer.com/ppbook/"><i>The Pragmatic Programmer</i></a>, the authors recommend learning a new programming language every year, just to stay sharp.  Ideally, you would learn the syntax, the programming model, write a few beginner programs and finish a non-trivial application.  Find out how it feels under your fingers.  Get exposed to some new ideas.  See which ideas look good but really chafe, and which ideas look bad but work quite well in practice.  Your goal isn't to beef up your resume, but to learn and adapt.
<p>
Realistically, doing all that work is time consuming.  I've been doing my best to follow the intent of this dictum, and I try to read about one text per year on a language I do not use, or haven't used in years.  Once you've done the grand tour of programming (procedural, recursion and functional, OOP, and declarative programming), it should be easy to pick up <i>some</i> of the basic insights a new language brings.  It may take weeks or months for the ideas to fully sink in, but in time they will.  You'll start looking at your code differently, and start seeing better ways to write in the language of your choice that make your programs more robust and less tedious to write.
<p>
Yes, this is the Evelyn Wood School of Learning a Programming Language.  That's OK.  You'll learn something, and there's nothing preventing you from going back over a text, like <a href="http://mitpress.mit.edu/sicp/">SICP</a>, a second or third time.  Or taking an opportunity to write a little app with <a href="http://www.rubyonrails.org/show/HomePage">Rails</a> instead of <a href="http://www.masonhq.com/">Mason</a>.
<p>
&nbsp;
<p>
That aside, the second key point: if you are going to try and learn a new language to broaden your horizons, pick something <i>different</i>.  Most programming languages out there today inherit something from the big Ur-language known as ALGOL.  If you've learned one ALGOL derivative, you've learned most of them.  So, for example, if you already know C, spending time on Pascal isn't a great investment.  Better spend your time on something very different or unique, like a Lisp, Smalltalk, Forth (including PostScript), Self, *ML, Haskell or Prolog.  There are many more ideas to mine there than there are in the language next door.

<p>
Third, with all of the programming languages out in the world today, there are very few <i>great</i> languages -- stuff that lasts for decades.  Many of those great languages are <i>sui generis</i>, like Lisp/Scheme, Smalltalk and Forth.  These languages are a programmer's Latin, Greek, and Aramaic.  Many of the ideas that come into Objective-C, Java, Ruby and Tcl can trace their origins back here.  If you want to learn a new language, focus here before you kick the tires on something newer like Python, PHP, Tcl or Ruby.

<p>
Fourth, why Smalltalk?  Even if you don't fire up an image, the whole model behind the language is wonderfully elegant.  Sure, there are warts in there (like the lack of an if statement), but every language has warts.  Get over it.  Look for the deeper values like Collections, blocks and metaclasses.  Stare at it long enough, and you'll wonder why <i>any</i> method in an object oriented system needs more than ~ten lines of code.  And the whole thing will be much easier to understand than you ever thought it could be.

<P>
One last note.  On the local XP list, someone mentioned cyclomatic complexity as a means to identify complex code in a project that needed to be refactored.  However, in an object oriented project, cyclomatic complexity doesn't work, so someone offered <i>lines per method</i> as a suitable replacement.  If most of your code is hovering around the 10 lines/method, you know methods that are 50+ lines long desperately need refactoring.  
<p>
This metric and the associated style of development come from Smalltalk.  Had I been stuck in a rut writing 500-line Windows event handlers in C (with case statements -- YUCK!), that suggestion would have floated over my head.  As it stands, I'm using that style to guide me in refactoring procedural code into object oriented code at work right now.  I'm moving Tcl code into XOTcl, but it doesn't matter -- I'm programming as if I were building a system in Smalltalk, and the new system is much better for it.  The codebase could just as easily be in Perl or Java, but the approach remains the same.
<p>
Learn Smalltalk.  I assure you, it will improve your coding life, even if you never manage to use it professionally.</p>


<hr/>



<h2>Smalltalk</h2>
<h3><a href="/user/jest/">jest</a> on 2004-09-17T13:07:21</h3>
ziggy++<br>
Terrific summary, thanks.



<h2>No &quot;if&quot; statement?</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2004-09-17T13:20:14</h3>
<p> <em>Sure, there are warts in there (like the lack of an if statement)...</em> </p>

<p>That alone makes me interested.  I can't tell you how many times I've stared at <tt>if {...} else {...}</tt> statements in code that are better handled via polymorphism or dispatch tables but I don't have the time to refactor them.</p>

<p>As for learning a new language, I suppose you're right and I should give it a try.  So far, I've done a fair amount of <a href="/user/Ovid/journal/6577" title="perl.org">dabbling in Prolog</a perl.org>, <a href="/user/Ovid/journal/18011" title="perl.org">a bit in Scheme</a perl.org>, and have a whole host of other languages that I've programmed in (Java, C, COBOL, Easytrieve, Focus, 6809 assembler, etc.)  I think all of these languages have benefitted me, if only to teach me what not to do -- COBOL being a prime example.</p>

<p>As for why I've never dived (dove?) into Smalltalk, I can't say.  There's much about it that appeals to me.  Maybe it's the "tuits" thing.  Yeah, that's it.</p>



<blockquote>

<h2>Re:No &quot;if&quot; statement?</h2>
<h3><a href="/user/zatoichi/">zatoichi</a> on 2004-09-17T21:29:04</h3>
<p>I love its simplicity in this:
<br>
ifTrue: [ doSomething ]<br>
ifFalse: [ doSomething ]
</p>
<p>Using it like this:</p> <blockquote><div> <tt>(3 &lt; 5) ifTrue: [ Transcript cr; show: 'It is true.'. ]<br>&nbsp; &nbsp; &nbsp; &nbsp; ifFalse:[ Transcript cr; show: 'It is false.'. ]</tt> </div></blockquote> <p>Cincom has a non-commercial version that you can get. I am *learning* it next.</p>





</blockquote>


<h2>Small methods</h2>
<h3><a href="/user/jdavidb/">jdavidb</a> on 2004-09-17T18:34:41</h3>
<p>So if I read you right, learning Smalltalk will make me write smaller (by LOC) methods?  That's a goal I'd like to achieve, so maybe I'll learn it.</p>

<p>Oh, and Forth is Postscript?  Thanks; I didn't realize.  I thought it was just open firmware.<nobr> <wbr></nobr>:)</p>



<blockquote>

<h2>Re:Small methods</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2004-09-18T07:07:55</h3>
Forth is not Postscript. Postscript is like Forth, except it has some "list as first class objects" ideas thrown in. It's a strange world, foreign, difficult, but also exotic and occasionally very beautiful.<nobr> <wbr></nobr><tt>:-)</tt>



<h2>Re:Small methods</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2004-09-18T18:54:12</h3>
<blockquote><div> <i>
So if I read you right, learning Smalltalk will make me write smaller (by LOC) methods? That's a goal I'd like to achieve, so maybe I'll learn it.
</i> </div></blockquote>
Actually, it's not a simple cause-and-effect relationship.
<p>
Learning how to write smaller methods is a result of learning how to write good abstractions.  If you get a good Smalltalk text written by someone who really understands the principles of writing good abstractions, then you should be able to see what good code looks like, and hopefully absorb good design.  Thankfully, most material written about Smalltalk is written by people who have a better-than-average ability to write good abstractions.
</p><p>
But you don't need Smalltalk for that.  You could learn how to write good abstractions from reading SICP and perhaps <a href="http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/" title="mit.edu">watching the lectures</a mit.edu>.  Or any other good text for that matter, regardless of language.  (If I knew a good Haskell, O'Caml or Ruby text with the same bias, I'd heartily recommend them as well.)
</p><p>
So, basically, writing good abstractions is something that people at the top of the bell curve do well.  These people also tend to use (and often create)  programming language that make it easier to write good abstractions.
</p><p>
I like to joke about Forth, because Forth is so esoteric, overlooked and unappreciated.  But one of the best things about Forth is that it forces you to write good abstractions.  The penalty of writing bad abstractions is pretty severe, and is easily the difference between a program that works, and a program that will never work.</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

