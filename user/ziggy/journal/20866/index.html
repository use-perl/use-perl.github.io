<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of ziggy: Programming Language Design</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Programming Language Design</h1>
<h2><a href="/user/ziggy/">ziggy</a> on 2004-09-14T03:46:24</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>Ovid <a href="http://use.perl.org/user/Ovid/journal/20854">raises</a> a very important permathread in programming language design theory:
<blockquote><i>
[T]here's a lot of envy -- perhaps animosity -- surrounding Perl because it's ugly, has all of these weird hacks, isn't "pure," and yet is enormously successful. At the same time, the Smalltalk and Scheme guys were trying to explain to the other camp that they solved our sorts of problems <b>decades</b> ago, so we should really listen to them.
</i></blockquote>
Yep.  This is what spurred <a href="http://ll1.ai.mit.edu/">LL1</a>, <a href="http://ll2.ai.mit.edu/">LL2</a> and <a href="http://ll3.ai.mit.edu/">LL3</a> to see if the "popular" languages could learn some of the lessons the old time academic languages had long since solved.

<p>

One reason why the academic languages never take off is because they are tied to a research agenda.  When the research folks were worried about virtual machines, garbage collection, JIT compilation, functional programming, type safety, generic programming, objects, patterns and whatnot, the average workaday programmer was worried about bytesexing, 16-/32-bit integer conversions, and just getting a program to fit in a PC with crazy small memory footprints.  It's only within the last few years that machines have gotten fast enough that working programmers can afford the indirection that many of these research languages bring with them.

<p>

It's obvious <i>now</i> that the academics were more focused on building the platform that people would use 5-, 10- and 15- years hence than the current limitations of whatever hardware came out last month.  (This has been Alan Kay's mantra for ~40 years.)  So it's no surprise now that hardware has caught up to where the academics planned, they're pissed off the rest of the world is still programming much as we did when we were using 286s and 68000s with 1MB of memory.

<p>

On the flip side, a lot of the kinds of problems that were interesting to academia decades ago were trivial compared to the kinds of problems working programmers faced, or at least they didn't have the same kinds of constraints.  So it was OK to use recursion, VMs and garbage collection in 1980 with "research languages", even if those languages were considered didn't scale up to solve the problems of the day.  (Or, rather, didn't scale up when used by average programmers instead of great hackers).

<p>

By and large, the features that the academic community pioneered are being adopted in bits and pieces.  Perl got reference counting memory management before it got closures and objects.  That trend will likely continue into the future; Parrot is being built with JIT in mind from day zero.  We're catching up with the past, albeit slowly.  (Guy Steele doesn't look at Java as a sucky language; he looks at it as slipping about half of Lisp into the minds of C/C++ programmers that were otherwise hostile to the lessons of Lisp.)

<p>

Finally, there is this issue as to why a popular, impure language like Perl is so successful, where pure, academic languages like Scheme never get widespread use.  My take is that there is a schism between the purity of the ivory tower, and the reality of the everyday world.  Perl is a dirty language because it's problem domain is dirty.  Better to adapt to the problem than impose a simulated simplicity on it.  And that's a bitter pill for academics to swallow.  I've looked and looked and then looked some more, but the applicative order Y-Combinator and <tt>((call/cc&nbsp;call/cc)&nbsp;(call/cc&nbsp;call/cc))</tt> in Scheme still makes no sense to me.  But when I see a gnarly piece of Perl syntax, I recognize it as a regular expression that simply and concisely captures exactly what I mean.  And I'll take a working regex over an elegant definition of recursion any day of the week.</p>


<hr/>



<h2>Very True</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2004-09-14T04:34:31</h3>
<p>I gave a mini talk about Parrot(and Perl 5)'s NCI mechanism this weekend.  A handful of people in the audience mentioned the problems that FFIs in Lisp-ish languages had encountered  and solved, in some cases.</p>

<p>(Of course, no one but Ziggy knows that that he'd already pointed me to some research on FFI a couple of weeks ago, thus helping me save a little bit of face.)</p>



<blockquote>

<h2>FFI?</h2>
<h3><a href="/user/htoug/">htoug</a> on 2004-09-14T06:45:29</h3>
FFI = Foreign Function Interface? or...



<blockquote>

<h2>Re:FFI?</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2004-09-14T12:50:03</h3>
Yep.  That would be the one.<nobr> <wbr></nobr>;-)





</blockquote>

</blockquote>


<h2>Academia as futurism</h2>
<h3><a href="/user/TorgoX/">TorgoX</a> on 2004-09-14T23:30:53</h3>
"It's obvious <em>now</em> that the academics were more focused on building the platform that people would use 5-, 10- and 15- years hence than the current limitations of whatever hardware came out last month."

<p>A stopped clock is right twice a day.</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

