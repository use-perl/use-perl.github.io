<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of ziggy: This Just In: Java Rots the Brain!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>This Just In: Java Rots the Brain!</h1>
<h2><a href="/user/ziggy/">ziggy</a> on 2005-12-29T22:18:34</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>Joel has released another <a href="http://www.joelonsoftware.com/printerFriendly/articles/ThePerilsofJavaSchools.html">essay</a>.  This time, he focuses on how all-Java curricula are a disservice to students, industry, and the field of computer science:<blockquote><i>Nothing about an all-Java CS degree really weeds out the students who lack the mental agility to deal with these concepts. As an employer, I've seen that the 100% Java schools have started churning out quite a few CS graduates who are simply not smart enough to work as programmers on anything more sophisticated than Yet Another Java Accounting Application, although they did manage to squeak through the newly-dumbed-down coursework. These students would never survive 6.001 at MIT, or CS 323 at Yale, and frankly, that is one reason why, as an employer, a CS degree from MIT or Yale carries more weight than a CS degree from Duke, which recently went All-Java, or U. Penn, which replaced Scheme and ML with Java in trying to teach the class that nearly killed me and my friends, CSE121. Not that I don't want to hire smart kids from Duke and Penn -- I do -- it's just a lot harder for me to figure out who they are.</i></blockquote>This reminds me of the lament in the 1990s that schools were integrating Java into their curricula, and somehow Perl was "losing out" as a result.  Since hundreds of students would graduate every 4 years with impressive backgrounds in Java, and employers wanted to hire Java programmers (and couldn't get enough them, to the point that it was common for CS majors to drop out after a little over a year to earn more than their professors).  And because Perl wasn't<tt>^W</tt>couldn't get wedged into that system, the benefits we Perl programmers could bring to the world would be lost, and we would gradually see ourselves edged out of work because of the flood of Java programmers, Java shops and the like.<br/><br/>Or so the thinking went.<br/><br/>Fast forward a few years, and it really was a tempest in a teapot.<br/><br/>Joel is repeating some of what Paul Graham talks about in some of <a href="http://www.paulgraham.com/avg.html">his</a> <a href="http://www.paulgraham.com/hundred.html">essays</a>, but from a different perspective.  Joel is looking at the problem as a hiring manager, and finding that Java (for example) levels the playing a little too much.  Java optimizes for the average -- less than average programmers are prevented from doing any serious damage, while better than average programmers are prevented from doing anything truly extraordinary (or do the extraordinary only with extreme amounts of effort).<br/><br/>This reminds me of an offhanded critique about Python: Python strives to have one (obvious) way to do it, which makes all source code "look" the same.  Thus, looking at a piece of random Python code, it's difficult to tell at a glance whether it's good or not.  (Somehow, Python acquired this property without the dampening property of Java.)<br/><br/>Perl, on the other hand, with its trademark TMTOWTDI, makes it <i>easier</i> to see when code is good or bad.  Because it blends aspects of C, Lisp, and OOP, a good Perl programmer will have to think at multiple levels of abstraction to get a complex job done.  Furthermore, an experienced Perl programmer will be able to just look at a random snippet of Perl code and determine whether an applicant is worth talking to, or should be shown the door at the first possible opportunity.<br/><br/>Java, on the other hand, throws all of that away in the name of safety.  Funny, that.</p>


<hr/>



<h2>Not buying it (quite)</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2005-12-30T06:31:03</h3>
<p>I don't quite agree with Joel on this one.  I've met plenty of incompetent CS graduates, there's no question about it.  But they get and hold jobs.  However, we need those mediocre programmers just as much as we need the great ones.  The reason is the same reason why we have more fry cooks than gourmet chefs.  The great programmers will not be happy with a simple job wring shell scripts.  Mediocre 9-to-5 programmers will take those jobs and and let the great programmers work in the programming equivalent of 4 star restaurants.</p>

<p>The problem, though, is that fry cooks typically have no illusions that they can produce the perfect coq au vin.  Mediocre programmers often don't know it.</p>



<blockquote>

<h2>Re:Not buying it (quite)</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2005-12-30T15:06:21</h3>
I take your point that there's a skills gradient, and there's a benefit in exploiting the skills gradient.<br><br>But the analogy that programmers are like fry cooks to 4-star chefs is somewhat specious.  Fry cooks are dead end commodity jobs that pay poorly and offer little value.  They exist because of a perfect storm of economics -- cheap ingredients, cheap wages, and low customer expectations.  If any one of those three changes, then the entire business model goes away.  From a programming perspective, these are the cheap, throwaway jobs that can deal with high turnover, low pay and few skills, because they really aren't programming jobs, but tech jobs that exist because it's cheaper to throw bodies at a problem than it is to fix the underlying process.  For example, look at the "HTML Programmers" that saw their jobs disappear when the VC money dried up, and managers began to realize that a template-driven CMS was better than a room full of people hand-editing HTML at upwards of $50,000/year.<br><br>If programming is a craft, then it's more like carpentry, where the skills gradient ranges from timber framer to cabinetmaker to master carpenter (with many points in between).  At the lowest levels, you have homeowners, day laborers, and factory workers, all of whom can wield a hammer and pound nails, but aren't really carpenters.  Similarly, fry cooks aren't really cooks in any real sense of the word.<br><br>I take Joel's point that (a) there is a gradient, and (b) in order to do <i>real</i> work, a programmer needs to possess certain minimum skills.  Anyone below that low water mark really isn't a programmer, just like a fry cook isn't a cook, and a mill worker isn't a carpenter, and someone with barely enough skills to write the next accounting package in Java really isn't a programmer.<br><br>The problem is that the all Java curriculum attempted to increase the quantity of "programmers" in the US to address the shortage in the industry, while totally ignoring the quality of the programmers it produced.  You wind up with the situation we have today, where we have fry cooks posing as short order chefs, because we really don't know how to distinguish between different levels of "programmer", and pitifully few 1- to 4-star chefs.





</blockquote>


<h2>Hmmpf.</h2>
<h3><a href="/user/Abigail/">Abigail</a> on 2005-12-30T13:34:09</h3>
What irretates me both about the Joel quote, and your reply is the assumption that a CS major at a university is about programming, or training programmers for the industry.
<p>
For me, the complaint is as unreal as a complaint that an avionics department goes "all Airbus - training pilots to fly Airbus only". The odd thing here isn't the "all Airbus" part - it's the fact they're training pilots.
</p><p>
A CS department on a university isn't there to produce programmers.</p>



<blockquote>

<h2>Re:Hmmpf.</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2005-12-30T15:22:32</h3>
I agree, but the definition of "computer science" is intentionally quite muddled in the US.  There are rigorous programs that train people to become computer scientists in the true sense of the word (i.e., people who can read Knuth and understand more than just the prepositions).  But there are also programs that churn out programmers -- people who can translate a poorly specified sequence of operations into a working program, eventually.<br><br>Unfortunately, universities that intend to produce one or the other both call their programs Computer Science.  The only consolation is that vocational schools that churn out vendor-certified technicians don't even pretend to teach computer science.<br><br>We do need both kinds of individuals because, frankly, someone who studied compiler theory should be applying those skills to solve some hard problems and not be stuck writing accounting systems or brain-dead CGI scripts.  And someone needs to write the accounting system.<nobr> <wbr></nobr>;-)<br><br>I also read Joel's lament as a plea for more computer scientists -- because that's what industry needs.  There are a lot of jobs where a mere programmer suffices, and it's sad that they come out with a Bachelor's in CS.  But there's also a tier of industry that needs real computer scientists, and we're not educating enough of them.  Some of these CS grads will stay in academia, but some won't.  And those that take their CS skills into industry can bring a lot of value.



<h2>Re:</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2006-01-01T17:14:32</h3>
<p>From said article:</p>

<blockquote>
<div><p>But what about the CS mission of CS departments? They&#8217;re not vocational schools! It shouldn&#8217;t be their job to train people to work in industry. That&#8217;s for community colleges and government retraining programs for displaced workers, they will tell you. They&#8217;re supposed to be giving students the fundamental tools to live their lives, not preparing them for their first weeks on the job. Right?</p>
<p>Still. CS is proofs (recursion), algorithms (recursion), languages (lambda calculus), operating systems (pointers), compilers (lambda calculus) &#8211; and so the bottom line is that a JavaSchool that won&#8217;t teach C and won&#8217;t teach Scheme is not really teaching computer science, either. As useless as the concept of function currying may be to the real world, it&#8217;s obviously a prereq for CS grad school. I can&#8217;t understand why the professors on the curriculum committees at CS schools have allowed their programs to be dumbed down to the point where not only can&#8217;t they produce <em>working programmers</em>, they can&#8217;t even produce CS grad students who might get PhDs and compete for their jobs. Oh wait. Never mind. Maybe I do understand.</p></div>
</blockquote>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

