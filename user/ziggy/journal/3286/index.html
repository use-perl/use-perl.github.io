<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of ziggy: XML Pipeline</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>XML Pipeline</h1>
<h2><a href="/user/ziggy/">ziggy</a> on 2002-03-04T19:49:24</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>I finished reading the XML Pipeline note on the train this morning.  Quite well thought out for an early draft.  Reading Sean McGrath's XML Pipe and playing with XML::SAX::Machines, it wasn't quite what I expected.
<p>
To be perfectly blunt, XML Pipeline is nothing more than a XMLified Makefile syntax designed for building XMLish streams.  That doesn't invalidate the good design and good thinking that went into this note.  However, it's not exactly what I thought I was going to be reading.  What I had oped for was something a little more low level -- an XML description for a single SAX machine for example that could scale to connecting processes that didn't necessarily communicate through SAX events.  Or perhaps just a generic Pipeline definition for something completely askew to XML processing (Hi, Piers!).
<p>
One thing that I did find disconcerting was the "implementation defined" punt that defers the definition of an processing step.  The example described in the abstract <i>was</i> a Makefile replacement, in that files were created and programs were called on the command line to build them.  Yet the note focuses on abstract connections that can be made between process (e.g. org.xml.XSLT, org.xml.XmlSchema, etc.) <i>and doesn't say how those connections are to be made</i>.  
<p>
That got me thinking that what we need here is another optional attribute to describe the API convention used by a process.  For instance, Java processes could adhere to the JXfoobar API (specified through the appropriate namespace name), while Perl or a C API might be conceptually similar, but fundementally incompatible (thanks to impedence mismatches).  A suitably challenged Perl hacker (or a suitably crazy one like Ingy) might even be able to write the bits of an XML Pipeline processor that understood multiple language linkage conventions -- passing opaque pointers between XML::LibXML and a C program using libxml or even adding a transparent impedence mismatch component through a Java native interface to plug into a Java transformation process...
<p>
That one additional attribute would buy a lot.  A pipeline processor could summarily ignore all processes conforming to foreign API conventions (e.g. Java processors ignoring Perl/Python processes).  For simplicity though, it might be necessary to define a default behavior - drop files on the file system and call CLI apps to do the processing...
<p>
Of course, this is still in the early days of development.  I don't see anything that makes it simple to declare "this process is a synchronous/asynchronous SOAP event", "this is a process defined by that WSDL description over there" or the like.  If an XML Pipeline processor is going to do as much as it sounds like, it doesn't sound too difficult to plug in an optional SOAP/XML-RPC/whatever peer-to-peer linkage into the whole mess.
<p>
One thing is for sure though. If this is nothing more than an abstraction over a Makefile, then I'm not particularly interested.  If it becomes a declarative language to define processing behaviors, then that's a different story all together.</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

