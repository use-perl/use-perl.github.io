<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of ziggy: The Tidal Wave Cometh!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>The Tidal Wave Cometh!</h1>
<h2><a href="/user/ziggy/">ziggy</a> on 2006-08-01T19:48:55</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>Eighteen months ago, Audrey was looking for something challenging and started writing <a href="http://www.pugscode.org/">pugs</a> in Haskell.  After the first three weeks, were nearly every day brought a blog post like "<i>Today was the most productive day of the pugs project ever!  I doubled the number of features again!</i>", lots of people started to notice.  Not only notice Audrey and pugs, but also Haskell.<br/><br/>I noticed.  Which is why when I was presented a project (for a previous employer) around the same time, for a parser with an unknown set of requirements and constraints, Haskell sounded like the way to go.  Indeed, it was; once I got my bearings, my ability to modify the code outstripped the ability of managers to add/change/contradict requirements.  In fact, it was not uncommon to spend 1-2 hours in a meeting with 3-8 people discussing a feature that took ~15 minutes to revise/implement.<br/><br/>Fast forward to last week, when I presented a tutorial at OSCon entitled <a href="http://conferences.oreillynet.com/cs/os2006/view/e_sess/8898">Introduction to Haskell</a>.  Based on the feedback from attendees, it went over pretty well.<br/><br/>Fast forward to today, when Joel Spolsky writes about <a href="http://www.joelonsoftware.com/items/2006/08/01.html">basic functional programming practices</a>, using JavaScript for his examples.  (Nothing that you haven't seen already in Dominus' <a href="http://hop.perl.plover.com/">HOP</a>.  What you don't have a copy?  Why not?)<br/><br/>At this rate<sup>*</sup>, by 2010 (2015 at the latest), all programming languages that <i>aren't</i> functional will be obsolete; the only kinds of jobs that will be open will be for functional programming, and the only kinds of people in the market will also be functional programmers.<br/><br/>Functional Programming.  Not just for eggheads anymore.<br/><br/><small>
*: This is the same logic that noticed a sustained annual 10x increase in Perl monger groups by early 1999, and predicted that there would be more Perl mongers groups than people on the planet by 2006/2007.
</small></p>


<hr/>



<h2>Functional languages</h2>
<h3><a href="/user/j3h/">j3h</a> on 2006-08-02T00:39:13</h3>
Couldn't agree more.<br/><br/>I think HASKELL and OCAML are well on the way to being the next big think in development and I wait with bated breath for ARC.



<h2>Concurrency</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2006-08-02T01:32:55</h3>
<p>Joel alludes to this, but I wonder if part of the growth of functional languages will be that they're much easier to optimize for concurrency than languages with side effects.</p>



<blockquote>

<h2>Re:Concurrency</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2006-08-02T02:42:37</h3>
I can't speak for Joel, but in my experience, a big reason why the wave is hitting now instead of 10 or 20 years ago, is because Moore's law has finally crossed some barrier that makes these languages workable.<br><br>Take ghc, for example.  On my 4-year old G3, ghc 6.4.2 took about 14 hours to bootstrap.  gcc, by comparsion <i>might</i> take as much as an hour or two to do a full 3-stage bootstrap (vs. ghc's 1.5/2 stages).  Also, on a "simple" Haskell program, there is a noticable amount of time to compile (either to produce<nobr> <wbr></nobr>.o files or load into the interpreter).  Nevertheless, that's a small price to pay to get high productivity and terse programs.<br><br>Another issue that there's an expectation that as languages evolve, we get ever increasing productivity.  There's little more that object-oriented languages can offer; dynamic languages have a little steam left in them, but not a 2x increase.<br><br>One of the only avenues left to pursue is functional programming, which is why dynamic languages (Perl/Python/Ruby/JavaScript) are clinging to functional features a lot moreso than, say 5-8 years ago.





</blockquote>


<h2>Cool, thanks!</h2>
<h3><a href="/user/excalibor/">excalibor</a> on 2006-08-02T12:59:29</h3>
Good entry, and the article referenced is cool as well (Joel is right sometimes<nobr> <wbr></nobr>:-)<br><br>Don't miss Joel link to Steve's Rant: <a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html" title="blogspot.com">http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html</a blogspot.com><br><br>Excellent as well.<br><br>And I'm on to your Haskell presentation!<br><br>As for concurrency, I know Erlang-like concurrency is perfect for declarative languages, you can get a similar thing (i.e. Communicating Sequential Processes: <a href="http://c2.com/cgi/wiki?CommunicatingSequentialProcesses" title="c2.com">http://c2.com/cgi/wiki?CommunicatingSequentialProcesses</a c2.com>) in Scheme (as the easiest language to see anything, probably, without really knowing the language: I've even understood monads (sorta) with a Scheme example!) and other similar languages... But side-effects are concurrency-killing, I wonder how they managed to do it in Oz/Mozart...<br><br>Anyway, great advice for perlers! As for MJD's HOP, as early reviewer, I can only recommend it!<br><br>best regards!<br><br>PS- any easy way to use hugs w/o emacs?? thx!



<blockquote>

<h2>Re:Cool, thanks!</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2006-08-02T13:33:02</h3>
<blockquote> <div><i>
As for concurrency, I know Erlang-like concurrency is perfect for declarative languages, you can get a similar thing (...) in Scheme (...)
</i></div> </blockquote>
<p>
Actually, you can get <b>exactly</b> the same thing in Scheme.  Just use <a href="http://toute.ca/" title="toute.ca">Termite</a toute.ca>.  (Probably not ready for prime time, but under actively development.)
</p>
<blockquote> <div><i>
any easy way to use hugs w/o emacs??
</i></div> </blockquote>
<p>
Um, yeah.  On the command line.  But I use ghc[i].
</p>



<blockquote>

<h2>Re:Cool, thanks!</h2>
<h3><a href="/user/excalibor/">excalibor</a> on 2006-08-03T17:06:30</h3>
Ah, that's really interesting! (Termite) I'll check it out, thanks!<br><br>Of course, having the source on a window and the CLI with readline or a similar line-editor in another (or different screen, anyway) will be all that's needed... forgot to<nobr> <wbr></nobr>:load *grin*<br><br>thanks!!<br><br>PS- off to try and understand Pugs!





</blockquote>

</blockquote>


<h2>please!! where can i see the tutorial???</h2>
<h3><a href="/user/grumpY!/">grumpY!</a> on 2006-08-02T16:17:22</h3>
is it possible to see the tutorial online?



<h2>10 years is _way_ too optimistic</h2>
<h3><a href="/user/UmberGryphon/">UmberGryphon</a> on 2006-08-02T19:34:06</h3>
You honestly think that in a mere 10 years, it will be impossible to get a job as a C programmer?  We'll have operating systems written in Haskell and word processors written in Erlang?
<p>C was being used to write operating systems 33 years ago, and it's still going strong.  There will always be a call for a language that lets you be somewhat platform-independent while still giving you the ability to get very close to the bare metal.
</p><p>There is a place for functional programming--many places, as a matter of fact--but to claim that it's the right tool for every job is just silly.</p>



<blockquote>

<h2>Re:10 years is _way_ too optimistic</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2006-08-02T20:13:40</h3>
<blockquote> <div><i>
You honestly think that in a mere 10 years, it will be impossible to get a job as a C programmer?
</i></div> </blockquote>
<p>
Um, read the footnote again.  That assertion is as valid (and as plausible) as the assertion that today, August 2006, the number of Perl Monger groups is very nearly the same as the number of people on the planet (+/- ~10%), and by this time next year, the number of Perl Monger groups will exceed the human population of the Earth by roughly 10x.
</p>



<h2>Re:10 years is _way_ too optimistic</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2006-08-03T02:57:00</h3>
<p>It doesn't seem too far off to me.  Bare metal gets further and further from the PDP-11 every day.</p>



<h2>10 years ago, people were still using turbo pascal</h2>
<h3><a href="/user/Julian Morrison/">Julian Morrison</a> on 2006-08-03T09:09:00</h3>
In 10 years time, if you're programming in C, it will be because you're programming a burglar alarm or a fridge. Possibly an operating system, although I suspect l4 style microkernels will have made inroads, and most OS code will be running in "user space" and might be written in Haskell.<br><br>However, a game, a word processor, a network daemon, you'd be writing in Haskell, Perl, or perhaps Java (but by then, Java will probably look very Haskelly, and Perl 6 already does).



<blockquote>

<h2>Re:10 years ago, people were still using turbo pas</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2006-08-03T13:16:00</h3>
<blockquote> <div><i>
However, a game, a word processor, a network daemon, you'd be writing in Haskell, Perl, or perhaps Java (but by then, Java will probably look very Haskelly, and Perl 6 already does).
</i></div> </blockquote>
<p>
I'm not so sure.
</p>
<p>
First, C will never completely die.  Assembly language is still useful, even if it isn't used by 99.44% of programmers.  But the <i>idea</i> of assembly language is still <i>very</i> useful, and still deserves to be one of many cornerstones of any good CS degree.  And, periodically, the idea of assembly is useful when it resurfaces in, say, SQLite's internal opcodes, or pasm.  C is useful because it is a convenient, portable, and "user friendly" form of assembly language.
</p>
<p>
The best proof against Java/Haskell/Perl being used for high performance, low latency projects is Microsoft's experience with C# and CLR.  Sure, it's good enough for their customers to write line-of-business code, but it's <b>not</b> good enough for them to write their operating systems or office applications.  (The CLR is missing a few important primitives for OS design, and the desktop apps are too important to turn into, well, OpenOffice.)
</p>
<p>
The key point to realize is that most projects <i>aren't</i> operating systems, network daemons, games or word processors.  C, and to some extent Java (and Perl), are really poor languages for line-of-business development.  So while 10 and 20 years ago, most software was written in C, Pascal, Fortran or Assembly, that's more a statement of the then-current state of the art, not the innate suitability of those languages for every domain.
</p>
<p>
When I say (with tounge firmly in cheek) that all non-functional languages will be obsolete in 5-10 years, it's an assertion that functional languages (or at least languages with functional features used in a semi-functional manner) will be where the focus is for most projects, especially green field development.  There are four main classifications of languages (imperative, functional, object oriented and declarative), and each has their use.  Functional languages will never be the one true way to write <b>all</b> code, nor should they be.
</p>
<p>
(Note that we're seeing that change today - look at ruby, rails and the heavy reliance on blocks.)
</p>



<blockquote>

<h2>Re:10 years ago, people were still using turbo pas</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2006-08-04T04:54:17</h3>
<p>Your argument against C# would be stronger if Microsoft had demonstrated that it could actually <em>write</em> software anymore.<nobr> <wbr></nobr>:)</p>





</blockquote>

</blockquote>

</blockquote>


<h2>Presentation</h2>
<h3><a href="/user/notmuch/">notmuch</a> on 2006-08-22T16:11:18</h3>
Couldn't find the presentation "Introduction to Haskell", do you have it online somewhere.





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

