<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of ziggy: Perl vs. Scheme</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Perl vs. Scheme</h1>
<h2><a href="/user/ziggy/">ziggy</a> on 2001-12-04T15:16:14</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>Time for a confession.
<p>
For the last two months, I've been spending a lot of time working in Scheme (DSSSL to be specific), and preciously little time working with Perl.  Like most Perlfolk, I'm taking an "All Things Must Pass" approach to coding in something other than Perl.
<p>
Coincidentally, there's been a blip of interest with Lisp the last few weeks.  I've come across Paul Graham's writings again, and he's starting work on a new Lisp dialect called Arc.  Strangely enough, he's learning from the lessons of Perl -- specifically that tersness and syntax matter.  I've also been reading some of Ken Pittman's writings, and some of the rants posted on the ll1-discuss list.
<p>
The feeling of the lisp community is that they have (by their own estimation, of course) created the most effective, productive, hackable, and worthwhile language in existance; all other languages should roll over and play dead because they are simply inferior.  (No one seems to follow this line of arrogance).  Someone on the ll1-discuss list even went as far as to say that various Scheme implementations have the same properties we're trying to engineer into Parrot, so how could it be a logical choice to develop new code from scratch instead of using an existing Scheme implementation?
<p>
That got to me.  It's a fair question, and conveniently ignores most of the practical and pragmatic issues behind 99.44% of all software written being written in something other than a Lisp dialect.  It got me thinking -- if Scheme is such a wonderful language for writing compilers and virtual machines, then why aren't there any compilers or virtual machines written in Scheme for something other than Scheme or some other Lispy dialect?
<p>
Then it occurred to me: if Scheme can produce code as good as C, compile it to machine code, and if Scheme is more expressive and flexible than other languages, then why don't we have any operating systems written in Scheme?  Surely they could be implemented more quickly and more reliably than they are implemented today in C and C++.  All that's really necessary are a few thin hooks to write interrupt service routines (which compile down to object code) and send interrupts (ditto), which are trivial hacks to make to a Scheme environment that can compile down to machine code.
<p>
The only thing I can conclude is that Scheme (and the Lisp family) is overrated by academics for use in the real world.  Creating real operating systems and compilers is a practical problem domain; understanding techniques for writing compilers is an academic domain.  So, when the Scheme hackers start to lobby us to use their language for our project, it feels like they are trying to get us to do their dirty work for them (and prove that Scheme has real-world uses), instead of trying to help us get our work done more quickly and efficiently.  Furthermore, if Scheme were truly useful, it would have been used to implement at least <b>one</b> operating system in the last 25 years[1]; by their own admission, all of the parts are there to create a portable and hackable framework for writing an operating system...
<p>
Add all that up, and what do you have?  Given that the pieces are there to write a full operating system in Scheme, it should be a SMOP to write a full operating system in Parrot in a few years' time.  (Of course, writing garbage collection , memory management and interrupt service routines in Perl or Parrot will be painful, but should be as theoretically possible as compiling them down to machine code....)
<p>
<br>
<br>
[1] There were two LISP machines that might be counted towards this, but the OSes were done in Lisp, not Scheme; furthermore it's difficult to come to any conclusions about those platforms because they were all-lisp, all-the-time.  If a general purpose OS could be written -- one that could host programs that "feel" like a standard UNIX interface -- then that would be saying something quite significant...</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

