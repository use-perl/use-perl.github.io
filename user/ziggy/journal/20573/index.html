<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of ziggy: Poisoning the Java well</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Poisoning the Java well</h1>
<h2><a href="/user/ziggy/">ziggy</a> on 2004-08-26T06:06:06</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>I'm a big fan of <a href="http://www.paulgraham.com/">Paul Graham</a>.  But his <a href="http://www.paulgraham.com/gh.html">latest essay</a> has me a little uneasy.  Specifically, where he says:
<blockquote><i>
For example, if your company wants to write some software, it might seem a prudent choice to write it in Java. But when you choose a language, you're also choosing a community. The programmers you'll be able to hire to work on a Java project won't be as smart as the ones you could get to work on a project written in Python. And the quality of your hackers probably matters more than the language you choose.
</i></blockquote>

Java programmers have taken great offense at this.  Specifically, when they refer to this part of the quote, almost entirely out of context:
<blockquote><i>
The programmers you'll be able to hire to work on a Java project won't be as smart as the ones you could get to work on a project written in Python.
</i></blockquote>


Why am I uneasy?  Because Paul is flirting with <a href="http://www.nizkor.org/features/fallacies/poisoning-the-well.html">poisoning the well</a>.  So Java programmers are dumb.  If you want proof, look at all the blather they have spouted arguing with Paul asserting how non-dumb they really are.  (Here is a <a href="http://www.alpha-geek.com/2004/08/24/java">list of links</a> into some of this discussion.)


<p>
Now, I happen to agree with the overall message Paul was <i>trying</i> to convey.  He has since <a href="http://www.paulgraham.com/pypar.html">clarified his point</a>.  It's not that Java programmers are dumb, it's that, on average, Python programmers are smart.<sup>*</sup>  
And, when this essay is taken in its entirety, Paul is really saying that he doesn't know any great Java hackers <i>personally</i>, but his opinion of J. Random Pythonhacker is generally much higher than J. Random Javahacker.

<p>
Furthermore, Paul was trying to be provocative and get us to accept that <i>variability of programmer skill is a fact of life</i>.  <a href="http://www.fotango.com/">Smart companies</a> will aim for the most skilled hackers, not the most widely accepted toolchain.  <a href="http://www.google.com/">Smart companies</a> will accept that there is great leverage paying a slight premium for great hackers (regardless of toolset).  That leverage that makes it very desirable to hire a small number of his so-called "great hackers" compared to a large number of middling programmers. <sup>**</sup>


<p>
But that doesn't excuse a logical fallacy, accidental though it may be.  

<p>

<small><sup>*</sup> I read somewhere that this is not a characteristic of Java as a language, but a characteristic of its mainstream status.  Some programmers don't care much about coding, and just want to collect a paycheck at the end of the week.  By definition, these are not great hackers.  Avoiding a mainstream language (like Java) goes a long way to avoiding these people a smart company does not want to hire.  Because Python is a boutique language, it's almost impossible to hire a Python hacker who is in it for an easy paycheck.  Similar statements can be made for Perl, or Perl + some CPAN modules.</small>

<p>

<small><sup>**</sup> I once worked in a shop where we had a team of "star programmers".  Our main tasks were to figure out the hard problems and do the heavy lifting so our projects could be shoved onto some entry level programmer's desk.  Because it was dirt simple to hire a floor full of entry level programmers, our manager saw his job as getting his star programmers to fire on all cylinders all the time, and shuffle the mostly completed project onto entry level programmers.  Because entry level staff was cheaper, he could afford to let them spin their wheels for a week, or just sit idle.
<p>
A smarter manager wouldn't hire by body count, and would have replaced the stable of entry level programmers with a few great hackers.  Entry level programmers, when hired, would pair with their more skilled colleagues to become great hackers themselves.  Keeping a bench of entry level programmers ready to spin their wheels doesn't do anyone any good, and hurts the projects as well.</small></p>


<hr/>



<h2>LISP hackers are smart too.</h2>
<h3><a href="/user/brian_d_foy/">brian_d_foy</a> on 2004-08-26T16:25:01</h3>
I took his comment to mean the same thing he's been saying for years about LISP people.  The higher end of the bell curve migrates to the niche tools.



<h2>Stupid Programmers, Java is for Kids!</h2>
<h3><a href="/user/scrottie/">scrottie</a> on 2004-08-29T01:15:08</h3>
Re: smart programmers gravitating towards
niches, yes, that's absolutely
<i>one</i> part of it - perhaps the most
significant part.
<br> <br>
Smart programmers working in an
environment safe from the effects of failure, separated from conflicting views,
will develop egos and fall pray to
"bad hubris".
Programmers not "held to fire" by programmers
using competing languages will tend to
assume by default that their language and
methodologies must be the best.
For lack of competing standards of excellence,
their benchmarks for quality and productivity
will drift until they're radically out of whack.
<br> <br>
Microsoft hires the best and the brightest -
everyone knows that. Most people in the trade
know someone who has interviewed there.
People have compiled the legendary Microsoft
interview riddles.
Why is the largest softare vender also
stigmitized with a reputation for poor quality?
Lots of reasons, but reading
<a href="http://blogs.msdn.com/rick_schaut/archive/2004/05/19/135315.aspx" title="msdn.com">Anatomy of a Software Bug</a msdn.com>
the other day, I was floored by the hubris.
And no, not the good adventurous, optimisitic hubris we all love.
This hubris was a frightened, cynical hubris.
<br> <br>
I'm going to bash Microsoft in this article.
There are plenty of software companies that
charge a lot, leave their customers in the
lurch, and feel as though they have no
accountability to anyone, but Microsoft
is the best known of these, and it was
artifacts from them that prompted this line
of thought. I's somewhat unfair that I'm not
roasting a less hated but just as deserving
company.
<br> <br>
Chris Pratley, also a Microsoft well-known
blogging on the same, had also written an
article earlier with repeated assertitions
that Microsoft should not be held to the fire,
the readers just don't understand, and
we're no one to question Microsoft.
These assertitions were separate from the
technical information, and the technical
information was extreme interesting, as far
as looks into the quiet software giant.
<br> <br>
The "Anotomy" article had the same theme of
asserting that Microsoft is doing a good job
but the readership of the article just doesn't
understand what it's like, and that's where
it went wrong - I do so know what it's like
working on very large projects. I've seen
hosed large projects and large projects that
stretched you every inch but were fundamentally
sane.
<br> <br>
The "Anotomy" article asserted a lot of
things as technical absolutes
that didn't sit well with me, and
these were things I recognized from failed
software projects.
It's little wonder Microsoft hadn't opened
up before, but opening up is usually the
best way to avoid demonization, and I'm not
sure which is worse in this case.
<br> <br>
Quotes come from the article:
<br> <br>
"Nonetheless, the developer took a different approach. Knowing that the undo document was very likely to be involved, one could walk through the undo document, and copy the text for any pieces that pointed to the previously-saved version of the documents file to the scratch file. He coded up the solution, and handed a buddy-build off to the tester."
<br> <br>
"very likely?" No. You don't apply "fixes" without understanding *exactly* where and why things are going wrong - even if you must refactor the whole project. If no one there
can understand why it's failing, it almost
certainly needs to be refactored.
<br> <br>
"In order to understand this, we have to understand a basic principle of fixes. You make the simplest code change required to fix the problem. This reduces the chances that the fix will cause some other problem that is, potentially, worse than the one youre trying to fix."
<br> <br>
No. This is not a "basic principle of fixes".
This causes cruft accumulation - especially in this case where a design limitation is being hit,
which is the case that this article describes! That goes back to my first point. The _best_ fix should be applied, with a thorough understanding of the entire subsystem or system. The system should be modular and use very little global state to make it easy to understand everything related. This guy is describing voodoo coding.
He's describing the greatest minds at Microsoft voodoo coding. That's scary.
<br> <br>
The error they're having is a "Disk full" error, but the real problem is that the process cannot open any additional files. Users are often confused by cryptic, vague, or incorrect error messages, but that developers took 10 years to figure out that the process was running out of file descriptions is really, really frightening. As a software developer, were I to walk into a large project cold, I expect that I'd be able to diagnose a file descriptor leak within a day. Maybe two days if the first day was an off day.
<br> <br>
"Well, you might as well ask why police departments continue to have a large number of unsolved crimes on the books. The issue is the same: the investigation stalls for the lack of any further leads to follow."
<br> <br>
He can't debug something without a groundswell of ultra-specific reproducable steps from your users, and you get more bug reports than any other software company on Earth, and they still aren't enough? This is amazing. Free Software developers, when resolved to fix a hard problem, will take core dumps and stack back traces from the field and effectively use those to solve the hardest of problems. In a crime investigation, you can't search every location, find every suspect, and monitor every action. When programming, you most certainly _can_. This is a poor analogy - or rather, a weak excuse.
<br> <br>
Back to hubris.
Stories of the hard-to-solve bugs are
usually intesting. They're like detective
novels. But this one reads more like a tragedy
of errors.
They can't debug something for 10 years.
Yet hubris tells them that this is a _fine_
pace to debug at, even with leigons of
programmers.
<br> <br>
Developers, working on projects with
like-minded developers, are seldom made
aware of the limitations of their tools
or methods.
A Perl programmer is confronted daily by
PHP programmers ("PHP is easy! I bought this
book and now I make more money than you!"),
Python programmers ("You should be fired
for writing code like that"), and a host of
others, including Java programmers ("our
specifications are of the formal variety!
Want to see the UML?"), C# programmers
("C# is now the preferred language - didn't
you hear?"), and so on.
<br> <br>
Java programs are seldom one-man efforts.
Java programs are almost always the result
of teams with year or two development timelines.
Working with a mainstream language,
your nads aren't held to the fire.
Whether or not it makes you dumb, it sets
you up to fall at the hand of your own pride.
<br> <br>
(If I were really a Perl programmer, I'd have
been able to make that point in 1/10th of the
characters).
<br> <br>
((Sorry to bother you all with this, but
community and software qualtiy has been
on my mind a lot lately - I see things go
wrong, as with Microsoft, and I want to know
how to it happened so I can avoid it for
myself and the projects I love)).
<br> <br>
-scott





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

