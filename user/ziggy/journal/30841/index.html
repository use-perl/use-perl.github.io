<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of ziggy: The Safety-in-Numbers School of Software Design</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>The Safety-in-Numbers School of Software Design</h1>
<h2><a href="/user/ziggy/">ziggy</a> on 2006-09-01T16:53:10</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p>
Joel's <a href="http://www.joelonsoftware.com/items/2006/09/01.html">latest essay</a> on writing big enterprisey apps boils down to two pieces of advice:
</p>
<blockquote><i>
The safe answer, for the Big Enterprisy Thing where you have no interest in being on the cutting edge, is C#, Java, PHP, or Python, since there's so much evidence that when it comes right down to it zillions of people are building huge business-critical things in those languages and while they may have problems, they're not life-threatening problems.
</i></blockquote>
<p>
That, and anything other than those four choices for a platform are "unsafe".  So pick whichever <i>one</i> you are most familiar with, and run with it.  And, if you really want to try Ruby on Rails, do it in your dorm room, where it doesn't matter when you fail to scale up.  :-)
</p>
<p>
Of course, you know the drill by now.  Insult Rails on a high profile blog, expect an immediate <a href="http://www.loudthinking.com/arc/000596.html">response from DHH</a> pointing out exactly where your arguments are categorically wrong because, as we all know, Rails is the best thing ever done with a piece of software.  :-)
</p>
<p>
For my money, both Joel and DHH miss the point entirely.  It's not about picking the popular tools that the corporate developer lemmings have blessed as safe.  It's not about taking throwing PhD's into a room, giving them Lisp, and expecting great things.  And it's not about the war between static and dynamic languages, dumb vs. crafty frameworks, or convention vs. configuration.
</p>
<p>
It's about understanding the problem, understanding the tools, and building an appropriate solution.
</p>
<p>
If you take Joel's argument at face value (and that's all it is, a philosophical statement devoid of data or a provable hypothesis), and look back 10-15 years ago, you'll find you have an argument in favor of the status quo: large, mission critical apps running on DOS/Win3.11 + Netware, written in dBase, FoxPro, Clipper, or their ilk.  These tools were simply not up to the job, yet as demonstrated by countless unnamed "enterprise" projects, they were suitable for any big enterprisey project.
</p>
<p>
Yet these were the worst kinds of tools for these jobs.  Or, rather, these weren't the tools you really wanted to solve these problems, but they were the best that was available for the slow, underpowered machines of the day.  And they sucked.  And everyone knew they sucked.
</p>
<p>
What was the answer?  Move away from DOS, move towards Windows (3.x), and client/server programming environments.  Brand new and obviously better solutions like SQLWindows, PowerBuilder, Visual Basic, and I forget what else.  (Even Smalltalk was a contender for a small number of projects as well.)  And if you didn't want to risk an unproven language, an unproven RDBMS, an unproven vendor on a big important project, there was always C and C++ on big iron Unix boxes working with CORBA ORBs.  Or, if you were really daring, C++ on Windows with COM (soon to be new and improved, once 32-bit Windows stabilizes).
</p>
<p>
But were <i>any</i> of those choices the answer?  No, not a one of them.  (Except VB, which, when adopted widely, wasn't the same language or environment as the anemic offering available for Windows 3.x.)
</p>
<p>
The lesson here is that the solution blessed by masses of corporate lemmings, isn't always the right one, and the obviously better pitched by Vendors Who Know isn't necessarily the right solution either.
</p>
<p>
It turns out that the right solution here was the web.  And it took a decade to discover, adopt, figure out how to write webapps, and wait for the browsers to be debugged enough.  Once everything was in place, we all could move away from the slow, buggy, kludgy, enterprisey development projects that really weren't as solid as they needed to be, and start talking about more fundemental problems, like how to <a href="http://mag-sol.com/talks/yapc/2006/advdb/">model your data properly</a>.
</p></p>


<hr/>



<h2>Funny</h2>
<h3><a href="/user/sigzero/">sigzero</a> on 2006-09-01T22:45:50</h3>
DHH totally glossed over the two criticisms (unicode and speed).



<h2>Large mission critical apps?</h2>
<h3><a href="/user/jordan/">jordan</a> on 2006-09-02T17:03:41</h3>
I agree with most of what you say, but there's one thing you said that really jumps out at me:<br><blockquote><div><br>If you take Joel's argument at face value (and that's all it is, a philosophical statement devoid of data or a provable hypothesis), and look back 10-15 years ago, you'll find you have an argument in favor of the status quo: large, mission critical apps running on DOS/Win3.11 + Netware, written in dBase, FoxPro, Clipper, or their ilk. These tools were simply not up to the job, yet as demonstrated by countless unnamed "enterprise" projects, they were suitable for any big enterprisey project.<br></div></blockquote><br>Where is it that you worked 10-15 years ago that these tools were regarded as suitable for big enterprisey projects?<br><p>Where I worked, in 1991-1996, only maverick grass roots kinds of organizations proposed these tools for large enterprise projects.  They typically tried to scale up their successes with Departmental level apps using this kind of technology, usually against the objection and resistance of centralized IT departments.<br></p><p>Enterprise projects in those days were typically done with Mainframes and green-screens, or maybe Unix/VMS systems with Oracle/Sybase databases, but not with PCs.<br></p>



<blockquote>

<h2>Re:Large mission critical apps?</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2006-09-03T03:31:40</h3>
<blockquote> <div><i>
Where is it that you worked 10-15 years ago that these tools were regarded as suitable for big enterprisey projects?
</i></div> </blockquote>
<p>
A couple of places, actually. xBase was an acceptable platform  in small business for records management and billing; I saw it used frequently in medical offices.  But the projects I remember most were in finance, where these systems were managing multi-million dollar positions.  These were also systems that were sold to multiple clients, in multiple banking centers around the world.
</p>
<p>
I didn't <i>personally</i> see xBase and its ilk managing 'large enterprise projects', as in the kind of stuff used corporate-wide for a Fortune 500 company.  But these are also the same kinds of projects that are held up as 'big', 'mission critical' and 'enterprisey' today, so there's no reason to be overly circumspect on how these vague terms are used.
</p>
<blockquote> <div><i>
Where I worked, in 1991-1996, only maverick grass roots kinds of organizations proposed these tools for large enterprise projects. They typically tried to scale up their successes with Departmental level apps using this kind of technology, usually against the objection and resistance of centralized IT departments.
</i></div> </blockquote>
<p>
Some organizations are pretty rigid in what's acceptable technology.  Other organizations are laissez-faire.  This leads to interesting war stories, when these two styles of organization merge, and the centralized IT department discovers the critical app written in Visual Basic, written by a nursing school dropout who took a 3-week intro to programming course, who thought that running a line-of-business application on their desktop was a good idea.<nobr> <wbr></nobr>:-)
</p>
<p>
As a result, the whole 'enterprise-grade' bludgeon is less about the scope of the project (department-wide vs. deployed across an entire Fortune 500 organization), and more about the qualities of the system being developed (failover, scale up and scale out, low downtime, supporting millions of dollars of business, low latency, high throughput, etc.).  At least, that's how 'enterprise' is used today, and how I'm categorizing past development projects with the modern meaning of the term.
</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

