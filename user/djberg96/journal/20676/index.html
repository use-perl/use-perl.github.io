<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of djberg96: Intellisense</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Intellisense</h1>
<h2><a href="/user/djberg96/">djberg96</a> on 2004-09-01T15:03:16</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>From <a href="http://darrenoakey.info/darren/blog/programming/2004/09/smalltalk-tidbits-industry-rants.htm">Darren Oakey's blog</a>:
<blockquote>
Anyway - I pointed out that the single most important productivity tool in modern languages is intellisense... without it, he can't hope to pull [Smalltalk] into the '90s.
</blockquote>
I can count the number of times I've found intellisense useful on one hand.  You see Darren, real programmers read and learn the API.  Those few times we can't remember a particular method we just look it up.  Of course, most languages don't have the bloated monstrosity of an API that Java has.  But, as <a href="http://www.lensmen.net/blog/dave/archives/000139.html">Dave says</a>:
<blockquote>
When your language is so verbose that it needs machine assistance to be usable, you've got a crappy language.
</blockquote>
Amen.</p>


<hr/>



<h2>Perl's intellisense</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2004-09-01T15:16:17</h3>
Perl actually <i>does</i> have intellisense.  It's just not supported by a big bloated IDE with dropdown boxes that helpfully guess what you could possibly mean as you type.
Instead, Perl uses huffman coded operators like <tt>grep</tt>, <tt>map</tt>, <tt>split</tt>, <tt>$scalar = @array</tt> , interpolation and so on.<br/><br/><blockquote><div> <i>
&gt; When your language is so verbose that it needs machine <br>
&gt; assistance to be usable, you've got a crappy language.
</i> </div></blockquote><br/><br/>Yep.  A good language has intellisense for both reading <i>and</i> writing code.  Giving you a crutch to write voluminuous amounts of code faster is not only solving the wrong half of the problem, but it is solving the wrong half of the problem in the wrong way.



<blockquote>

<h2>Re:Perl's intellisense</h2>
<h3><a href="/user/lachoy/">lachoy</a> on 2004-09-01T15:50:14</h3>
<blockquote><div>Perl actually does have intellisense. It's just not supported by a big bloated IDE with dropdown boxes that helpfully guess what you could possibly mean as you type. Instead, Perl uses huffman coded operators like grep, map, split, $scalar = @array , interpolation and so on.</div></blockquote>

<p>This is a little disingenuous, isn't it? The examples you're quoting are all built-ins, and I doubt that most people use intellisense for such items. IME it's really useful for keeping on top of libraries, particularly those you don't use very frequently. Even so, isn't one of the great features of Perl people often tout the ubiquitousness of 'perldoc -f' for built-ins and 'perldoc Module' for libraries? Wouldn't it be great to have to remember if, for instance, the constructor for a DateTime object took a hash vs a hashref? Or, since good intellisense implementations in Java also include inline javadocs, whether DBI's bind_param is 0- or 1-based?

</p><p>If I used these items every other day, sure I'd remember them without any help. But I use a LOT of libraries -- benefits of CPAN and working with any language with an an active open source community -- and I don't think I'm unusual in not being able to call up the details of every API on demand.

</p><p>Actually, one of the main benefits I see for something like Perl 6 is to be able to create an IDE as good as <a href="http://www.jetbrains.com/idea/index.html" title="jetbrains.com">IntelliJ IDEA</a jetbrains.com> for Perl. I didn't like IDEs before this one, even for Java, but it's a great tool that helps you code rather than codes for you.</p>



<blockquote>

<h2>Re:Perl's intellisense</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2004-09-02T02:07:41</h3>
<blockquote><div> <i>
This is a little disingenuous, isn't it?
</i> </div></blockquote>
Not really.
<blockquote><div> <i>
The examples you're quoting are all built-ins, and I doubt that most people use intellisense for such items.
</i> </div></blockquote>
That's precisely my point.  One of the reasons why Intellisense is almost a requirement for programming in C/C++/C# and Java is because of the type system, and the over complexity of the programming model.  With Java, you have big class hierarchies, interfaces, and dozens of classes with dozens of methods.  For example, if I want to iterate over a list, I need to construct an iterator and use methods like <tt>next</tt> and <tt>hasNext</tt> on that iterator.  It's a lot of typing.  In the degenerate case, I could be using a class that has a lot of methods named <tt>get_foo</tt>, <tt>get_bar</tt> and so on.  And don't get me started on the syntactic complexity in creating a closure (er, an <i>anonymous inner class</i>).
<p>
In Perl, there's a whole mess of stuff you can accomplish with the three basic datatypes.  Most of those operations are monosyllabic builtin functions.  A whole mess of operations like <tt>m//</tt> can be coerced to use <tt>$_</tt>,  which eliminates the need to say what can be automatically inferred.  Some of the common cases even use syntactic sugar to do what you mean (c.f. <tt>while (&lt;&gt;) {...}</tt>).
</p><p>
In terms of objects, the general idiom is to bless hash references into objects.  If you want to mess with instance data, you can peek and poke directly into the guts of an object: <tt>print $obj-&gt;{count}; $obj-&gt;{count}++</tt>.  We can debate the merits of that design philosophy separately, but it certainly obviates the need to create ~two methods for each instance variable (and consequently reduces method signatures).

</p><blockquote><div> <i>
IME it's really useful for keeping on top of libraries, particularly those you don't use very frequently.
</i> </div></blockquote>
I didn't think of libraries, but you bring up a good point.  I've avoided really nasty class hierarchies like those that are found with Java or any decent C++ framework.  I find that in Perl, I don't need the wall charts of the inheritance tree, or a playbook of what's what before I can use a set of libraries.  Core / CPAN modules tend to be easier to grasp and keep in my head.  (This isn't an natural property of Perl per se, just a set of design principles many Perl module authors share.)

<blockquote><div> <i>
Wouldn't it be great to have to remember if, for instance, the constructor for a DateTime object took a hash vs a hashref?  Or, since good intellisense implementations in Java also include inline javadocs, whether DBI's bind_param is 0- or 1-based?
</i> </div></blockquote>
In theory, it would.  In practice, it'd be easier if Perl defined a convention (all array counts start at zero) and modules adhere to that convention.
<p>
In theory, it would be nice to add all of these wizzy new features into a drop dead stunning Perl IDE.  In practice, a simple text editor with a handful of powerful abstractions and common design principles is at least as good, if not better.</p>





</blockquote>

</blockquote>


<h2>Re: Intellisense</h2>
<h3><a href="/user/jplindstrom/">jplindstrom</a> on 2004-09-01T21:49:55</h3>
I started writing a reply, but it got upgraded to <a href="http://use.perl.org/user/jplindstrom/journal/20679" title="perl.org">it's own journal entry</a perl.org><nobr> <wbr></nobr>:)<br>



<blockquote>

<h2>Re: Intellisense</h2>
<h3><a href="/user/djberg96/">djberg96</a> on 2004-09-01T23:48:53</h3>
Heh - I read it.  I think perhaps you misunderstood my point.  I have no problem with Intellisense.  If you like it, great.  It's probably very handy for some people.
<p>
What I'm really mocking is Darren's assertion that Intellisense is "the single most important productivity tool in modern languages".  I mean, please people.  That, coupled with the notion that Smalltalk failed because it didn't have a cool enough IDE.</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

