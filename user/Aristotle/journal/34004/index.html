<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of Aristotle: Newsflash: resorting to `eval` is a failure in your language</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Newsflash: resorting to `eval` is a failure in your language</h1>
<h2><a href="/user/Aristotle/">Aristotle</a> on 2007-08-06T00:04:46</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p><a href="http://www.cosine.org/2007/08/05/domain-specific-languages/">Even if the Rubyists think it&#8217;s fashionable and trendy</a>.</p>

<p>Oh yeah, and Cosine Jeremiah has never heard of <a href="http://perldoc.perl.org/functions/do.html">do</a>. That&#8217;s OK, you don&#8217;t need to know a language before you can opine on its sucktitude.</p>

<p>Besides, what a great design! I mean, evaluating another source file every time you instantiate an object in that class? Awesome! If I had to maintain his code I&#8217;d refactor that part out of existence <em>with a quickness</em>!</p></p>


<hr/>



<h2>ugh</h2>
<h3><a href="/user/rjbs/">rjbs</a> on 2007-08-06T02:41:35</h3>
I'd reply, but... I have to log in?  Ugh.<br><br>I really hate the "I do not understand the language, and therefore I hate it" school of blogging.



<h2>Huh?</h2>
<h3><a href="/user/djberg96/">djberg96</a> on 2007-08-06T04:38:04</h3>
So, Perl, Python, Ruby, etc are failures because they even <b>have</b> eval then? Or, are you merely criticizing people who actually use it?



<blockquote>

<h2>Re:Huh?</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-08-06T05:00:24</h3>
<p>I thought the title stated my position clearly: if you <em>have</em> to use <code>eval</code>, it&#8217;s a sign of something missing from the language (and if you don&#8217;t have to but do, it&#8217;s a sign of weakness as a programmer).</p>

<p>That doesn&#8217;t mean a language is bad if it has <code>eval</code>. If it helps you understand, just substitute <code>goto</code> for <code>eval</code>; both forms of the statement are completely congruent.</p>





</blockquote>


<h2>urine my do's</h2>
<h3><a href="/user/slanning/">slanning</a> on 2007-08-06T14:22:16</h3>
I'm glad that we in the Perl community are good pissers, because I think we're going to win this contest!



<blockquote>

<h2>Thanks for playing</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-08-06T14:53:04</h3>
<p>Better luck next time.</p>



<h2>Re:urine my do's</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2007-08-07T00:59:02</h3>
<p>That's a horrible pun.  I like it.</p>





</blockquote>


<h2>Reply</h2>
<h3><a href="/user/cosine/">cosine</a> on 2007-08-16T14:39:33</h3>
I think your aversion to eval is a mistake, but if it is not then you are not going to convince me with your current line of thought.  I posted my reply: <a href="http://www.cosine.org/2007/08/16/languagepowered-domain-specific-language/" title="cosine.org">http://www.cosine.org/2007/08/16/languagepowered-domain-specific-language/</a cosine.org>



<blockquote>

<h2>Re:Reply</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-08-16T16:54:17</h3>
<p>How am I supposed to argue with your example? You showed a design wherein a class reads a config file every time it is instantiated. I have no idea how that can be construed as useful; the fact that you use <code>eval</code> is incidental and at best draws attention away from the fact that you are <em>reading a config file on every instantiation</em>. After all,  &#8220;the config file is code!&#8221; Do you <em>really</em> need to recompile the code every time someone makes an instance of it? Sorry, that example just doesn&#8217;t cut it.</p>

<p>In any case I stand by my assertion that resorting to <code>eval</code> reveals a weakness in the language or in the programmer. There are some things that you cannot easily do in Perl without <code>eval</code>, and where the roundabout way confers no benefits over <code>eval</code>; these are things that I consider weaknesses in Perl.</p>

<p>Anyway.</p>

<p>You write:</p> <p><blockquote> <div><p>Ovid&#8217;s most important point is that DSLs can also be implemented by coding your own lexer and parser instead of using eval. I did fail to mention that, but I think it lends yet more credence to my previous assertion: that Ruby has better support for DSLs than Perl. Otherwise, the Perl crowd would not be so much against using eval (on strings) instead of writing the parser.</p></div> </blockquote>

<p>I have no idea how you get from Ovid&#8217;s point that DSLs should be parsable without the full host language executing the code, to the idea that Perl programmers are against <code>eval</code> because the language is lacking in DSL support. I don&#8217;t even know what the latter is supposed to mean. In my best effort to understand that paragraph I cannot find anything more than a non-sequitur.</p>

<p>Not to mention that I don&#8217;t agree with Ovid on what a DSL is, so lumping all the Perl types together based on his assertion is&#8230; silly at best.</p> <p><blockquote> <div><p>The closest I have ever seen in Perl was a configuration file made up of a large number of variable assignments.</p></div> </blockquote>

<p>That&#8217;s silly. Perl has this handy function called <a href="http://perldoc.perl.org/functions/do.html" title="perl.org"> <code>do</code> </a perl.org> (I believe I wrote about it in my last entry, didn&#8217;t I?) which will let you <code>eval</code> a file; and the code in the string passed to <code>eval</code> (and by extension, in the file loaded by <code>do</code>) can return a value, so the file could consist of the initialisation of an anonymous hash, which will be passed back to whoever invoked <code>do</code> to load the file. It is very easy to use Perl as the configuration language for programs written in Perl.</p> <p><blockquote> <div><p>I believe the Perl community&#8217;s recommended way to do this with about the same amount of code would be to have modules instead of configuration files for each vulnerability.</p></div> </blockquote>

<p>In the case of that program, yes, that would be the right approach.</p> <p><blockquote> <div><p>With a DSL I do not have to mess with package overhead or making sure my <code>@INC</code> array will contain the directory with my vulnerability information.</p></div> </blockquote>

<p>Where &#8220;DSL&#8221; is a grandiose way to say &#8220;string <code>eval</code>&#8221;, &#8220;mess with package overhead&#8221; is a grandiose way to say &#8220;apply proper programming discipline so that code in one of the files doesn&#8217;t trample all over code in the other&#8221;, and the other part is a grandiose way to say &#8220;I didn&#8217;t know about <a href="http://search.cpan.org/dist/Module-Pluggable/" title="cpan.org">Module::Pluggable</a cpan.org>&#8221;.</p> <p><blockquote> <div><p>I have also written a fetchmail/procmail hybrid in 512 lines of Ruby.</p></div> </blockquote>

<p>I did the same in Perl. It&#8217;s about 60 lines plus a bunch of CPAN modules &#8211; mostly glue to bind Mail::POP3Client to Email::Filter&#8230;</p> <p><blockquote> <div><p>My personal configuration file for this is about 60 lines, but there is no reason you would need more than 5 if you wanted very basic functionality.</p></div> </blockquote>

<p>&#8230; except for, I wrote it the other way around: the 60 lines of glue code are in a module, and what would be the &#8220;configuration file&#8221; in your case is, in my case, simply a short Perl program that uses the module. In this way I get to avoid the necessity for making up any conventions at all.</p> <p><blockquote> <div><p>What did I gain, in addition to the benefits I noted above, in my DSL for the fetchmail/procmail hybrid?</p></div> </blockquote>

<p>I think you lost track of your argument about Perl vs Ruby. All of the benefits you listed are completely incidental to the fact that you were using Ruby. There is no qualitative difference our independently conceived designs, judging from the description you gave.</p>



<blockquote>

<h2>Re:Reply</h2>
<h3><a href="/user/cosine/">cosine</a> on 2007-08-16T18:53:50</h3>
I'll just take this to mean we still have irreconcilable differences in our opinions here.<nobr> <wbr></nobr>:)  I appreciate the time you took to respond.



<blockquote>

<h2>Re:Reply</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-08-16T19:34:47</h3>
<p>Basically my opinion is that anyone who thinks Perl, Python and Ruby differ in any sort of significant fashion hasn&#8217;t seen a lot of languages. The three are close to identical. Sure, there are lots and <em>lots</em> of superficial differences &#8211; they optimise in different directions, and that is what ends up making me prefer Perl and you Ruby and still others Python. But their fundamental premises are completely identical so there is no substantial difference in terms of expressiveness, overall. Ruby wins at some things, Perl at others, and Python takes its share of victories.</p>

<p>(Btw, Javascript 1.x falls in the same class as these three.)</p>

<p>If you haven&#8217;t, try to look past the echo chamber of &#8217;90s dynamic languages and dig into some <em>really</em> different languages. Try Smalltalk. Pick up Haskell. Look at Forth. Read about Prolog. Write some XSLT. With a broader view of programming languages you should realise that the differences between Perl, Python and Ruby (and Javascript) are no more than cosmetics. Important cosmetics in terms of mental model (and therefore many people will naturally take to one of these, and not so much to the others &#8211; whereafter they promptly proceed to confuse this with superiority of their preferred language), but cosmetics nonetheless.</p>

<p>And I still don&#8217;t know what &#8220;DSL support in a language&#8221; is supposed to mean and how Ruby is purportedly better at it than Perl.</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

