<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of Ovid: God's Epiphany</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>God's Epiphany</h1>
<h2><a href="/user/Ovid/">Ovid</a> on 2004-04-17T16:50:04</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p>Cat sitting for a friend.  Forgot to bring a book or my laptop.  Mind starts wandering.  It starts wandering back to an earlier conversation where I'm explaining to someone that Perl is not C and trying to program in one while thinking in the other is difficult and leads to error prone code.</p>

<p>The I started thinking about <a href="http://use.perl.org/user/Ovid/journal/18362">Widge</a>.  Widge is also falling into the "not spectacularly fast" category because ... because ... because ... crud!  Widge is also a C program written in Perl.  Somehow, I can't seem to break my mind out of the C mindset.  I see the awful code and I cringe; I tweak it slightly but leave it substantially untouched.</p>

<p>I now realize not only what I was doing wrong, but what I need to do right.  By being away from the code, I started thinking in terms of <em>Perl</em>.  I started envisioning how I would code it if I was coding it from scratch, which is what I'm going to do.  I now know the system well enough that I no longer need any code to refer to.  The neural network is crystal clear (admittedly, it's a simple network) and the eyes are ridiculously obvious ... when I stop thinking about C.  The new plan is much simpler and should run one heck of a lot faster.  A quick test of some concepts this morning bore out some of my suspicions.  Unfortunately, I now have to pack for my new apartment when what I really want to do is create my world of widges and watch them evolve.  Damn.</p>

<p>I'm wondering if I can get an article out of all of this when I'm done.  I really need to start writing.</p></p>


<hr/>



<h2>Now you're getting it</h2>
<h3><a href="/user/VSarkiss/">VSarkiss</a> on 2004-04-17T22:41:06</h3>
<p>You've figured out what's so damn <strong>hard</strong> about computing.  We have high-level revelations that we turn into algorithms, but we have low-level hardware.  It's hard to spell out one into the other.</p>
<p>So....  Let's make the hardware smarter!  Oh, wait, that was the '70's idea: VAX opcodes, smart assembler.  That didn't go very far.</p>
<p>So.... Let's make the translator smarter!  Oh wait, that's what RISC was going to do in the '80's: super-smart compilers against cheap, dumb hardware.  Well, that kinda panned out, but not really....</p>
<p>So.... Let's just live with the difference, and make the hardware faster!  Yes, the '90's and '00's superscalar processors, the multi-gigahertz chips.  That's the ticket.  Or is it...?</p>
<p>As you've found, it's still hard.  The real impedance mismatch is between our creative brains and our constructive hands, and it hasn't been crossed yet.</p>
<p>Wonder what the '10's will bring.</p>



<blockquote>

<h2>Re:Now you're getting it</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2004-04-18T03:23:12</h3>
<p> <em>Wonder what the '10's will bring.</em> </p>

<p>Perl 6?<nobr> <wbr></nobr>:)</p>

<p>Seriously, I think something really needs to change in the world of computing.  Testing is what's really helped to push me there.  Specifically, once I started realizing that we can't just <em>know</em> how to build good software, I started thinking harder about this problem, but I am Bear of Little Brain and I don't have a solution for it.  I realized that tests (particularly acceptance tests) are an ad hoc method of ensuring program correctness.  They do not, however, prove correctness and with our insistence upon programming in ALGOL-style languages, we <em>cannot</em> develop proofs for our programs.  Some functional languages allow for such proofs, but I understand that they are usually not supplied with the programs.  I've also heard of attempts to build programs automatically from proofs.  Perhaps this will help.</p>

<p>Currently, if I were to ask a math-savvy person to compute to factorial of 5, she will hopefully respond with 120.  However, we simply do not expect her to ever forget that there's a terminating condition, as some programmers might in a naive factorial function:</p> <blockquote><div> <tt>sub factorial {<br>&nbsp; &nbsp; my $n = shift;<br>&nbsp; &nbsp; # whoops!&nbsp; Forgot the terminating condition of $n == 1<br>&nbsp; &nbsp; return $n + factorial($n - 1);<br>}</tt> </div></blockquote> <p>Now she might make a simple math error and that's something that computers are generally better and faster at, but she won't have a logic error.  I can also ask her to hand me a pen and she won't hand me a book by mistake.  Computers can and will make such mistakes.</p>

<p>We're also fault-tolerant in a way that computers are not.  If I ask who the redhead hired in accounting is, you might tell me that his name is "Sam", but he was hired in human resources.  (Neural networks might also be able to do that, I might add.)</p>

<p>I don't think the 10s will solve this problem, but the 20s might start getting a handle on it.  Unfortunately, we may have to be willing to release our love of ALGOL-style languages to get there, but I'm still unsure of what might take its place.  I actually think that Perl 6 rules might start giving us some interesting clues.  If the language is widely adopted, for the first time that I am aware of, we will have a programming language in widespread use that might allow logic programming in a typical environment (assuming that we can implement logic programming in P6 rules -- I think we might be able to.)</p>

<p>Bah.  I'm rambling about something I know very little about.  Silly me.  Time to get off the computer, stop packing for the day and hit the clubs.  I understand "The Cancer Fags" are playing to night and I've been meaning to see them.</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

