<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of Ovid: Criticizing Perl</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Criticizing Perl</h1>
<h2><a href="/user/Ovid/">Ovid</a> on 2005-10-05T17:53:19</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p>I love the Perl language.  Unfortunately, there's quite a bit to criticize about it.  Most of the issues which dissatisfy me are being fixed in Perl 6, but that's a long way off.  So for the time being, I work around the problems.</p>

<p>There are two major camps of those who criticize Perl:  those who know the language well and those who know the language poorly.  Their criticisms do not generally overlap.  It's gotten to the point where when someone says "I don't like Perl", I usually say "many people don't" because most people who don't like Perl don't know much about the language and didn't bother to learn.  They see sigils on the front of variables and say the language looks like line noise.  They see examples of Perl from bad programmers and generalize that to all of Perl.  They "know" that only strongly typed (whatever the hell that is) languages are worth considering so Perl "must be bad".</p>

<p>Anyone whose thought processes are that simple-minded is someone I don't want working for me.  There are plenty of reasons to dislike Perl.  The three aforementioned ones aren't in that list.</p>

<p>One issue which amuses me the most, though, is how some people think Perl is so bad but keep mum on the subject of PHP.  Most folks with only a passing familiarity of either language would be hard-pressed to tell them apart.</p>

<p>I wonder, though, if part of the problem lies in Perl's power?  To really exploit the full richness of the language, you have to know it well.  How many will stick with it long enough to get there?</p></p>


<hr/>



<h2>tease</h2>
<h3><a href="/user/phillup/">phillup</a> on 2005-10-05T18:45:56</h3>
<i>Unfortunately, there's quite a bit to criticize about it.</i><br><br>You are such a tease!<br><br>I myself don't really have a lot of complaints about the language, except that it sure would be nice to have a spiffy IDE sometimes... and it mostly doesn't because it is so dynamic as to make that difficult.<br><br>But, I am interested in hearing what you *would* consider a "legitimate" complaint. (Would I be correct in assuming most lie in the OO area?)<br>



<blockquote>

<h2>Re:tease</h2>
<h3><a href="/user/Dom2/">Dom2</a> on 2005-10-05T19:37:09</h3>
There are plenty of valid complaints about Perl.  You're right, a lot are in the OO department (how may ways are there to define a class?)  But there's also the slew of weirdly named globals.  And the lack of proper named parameters.  I think inconsistency is probably one of the biggies too (how many global variables do you need for error handling?)  Like you say, Perl 6 will (eventually) rectify a lot of these.  Or you can look at <a href="http://www.ruby-lang.org/" title="ruby-lang.org">Ruby</a ruby-lang.org> today to get some of them fixed.<nobr> <wbr></nobr>;-)

<p>As to an IDE, probably the best that you'll get is something like <a href="http://e-p-i-c.sourceforge.net/" title="sourceforge.net">EPIC</a sourceforge.net>.  But an IDE for Perl 5 will never be that good <em>because</em> of the language.  Perl is <em>so</em> dynamic, that it's nigh on impossible for an IDE to tell you what methods are available (because there are so many ways to define a class) and what parameters they take (because there is no standard way to do named parameters).  So you see your desires for the spiffy IDE are related to language misfeatures.

</p><p>-Dom</p>



<h2>Re:tease</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2005-10-05T20:08:49</h3>
<p>In addition to Dom's comments, I would also add a complaint that, ironically, I also have with Java:  mixing objects and primitives (Perl's less of a pain, but still a pain).</p>

<p>Lately I've been thinking a lot about allomorphism (think "duck typing" in Ruby) and how it relates to programming.  Consider the following snippet:</p> <blockquote> <div><tt>foreach my $method (@methods) {<br>&nbsp; foreach my $object (@objects) {<br>&nbsp; &nbsp; next unless $object-&gt;can($method);<br>&nbsp; &nbsp; $object-&gt;$method( $args_for{$method} );<br>&nbsp; }<br>}</tt></div> </blockquote> <p>That's powerful.  Dangerous, but powerful.  Many languages would force you to jump through a lot of hoops to replicate this behavior (if it's even possible).</p>

<p>Where does <tt>@objects</tt> come from, though?  If the programmer supplies them, what happens when she does this?</p> <blockquote> <div><tt>process($object1, $object2, [ qw/foo bar baz/ ]);</tt></div> </blockquote> <p>The call to <tt>$object-&gt;can</tt> blows up.  There's no reason it has to but now we're forced to rewrite our code to do something like this:</p> <blockquote> <div><tt>use Scalar::Util 'blessed';<br> <br>foreach my $method (@methods) {<br>&nbsp; foreach my $object (@objects) {<br>&nbsp; &nbsp; next unless blessed $object &amp;&amp; $object-&gt;can($method);<br>&nbsp; &nbsp; $object-&gt;$method( $args_for{$method} );<br>&nbsp; }<br>}</tt></div> </blockquote> <p>That seems like a contrived example, but I've found this biting me more than once.  Here's an example I recently had to write.</p> <blockquote> <div><tt>sub _attributes {<br>&nbsp; &nbsp; my ( $self, $attrs ) = @_;<br>&nbsp; &nbsp; return '' unless $attrs;<br>&nbsp; &nbsp; if ( ref $attrs &amp;&amp; UNIVERSAL::isa( $attrs, 'SCALAR' ) ) {<br>&nbsp; &nbsp; &nbsp; &nbsp; return ' ' . $$attrs;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; my @attributes = UNIVERSAL::isa( $attrs, 'HASH' ) ? %$attrs : @$attrs;<br>&nbsp; &nbsp; return '' unless @attributes;<br>&nbsp; &nbsp; # more code here<br>}</tt></div> </blockquote> <p>Because it's the person using this module who controls what is getting passed in (from a function at a higher level, not this one directly), I've no control over whether or not they're passing in a normal reference.  As a rule of thumb, having to check <tt>isa()</tt> indicates a design flaw.  Theoretically, I should just be able to do something like this:</p> <blockquote> <div><tt>sub _attributes {<br>&nbsp; my ($self, $attrs) = @_;<br> <br>&nbsp; # the following line is for illustration purposes only.&nbsp; The<br>&nbsp; # higher level code would probably call this method directly<br>&nbsp; return $attrs-&gt;_build_attributes;<br>}</tt></div> </blockquote> <p>I could do that now, but that means blessing the references passed in and that means that I've modified the calling variables and that's bad.  Of course, I could clone them and then bless them, but that gets annoying, too.  Instead, I'd like to be able to have a <tt>_build_attributes</tt> method exist internally for scalar, array, and hash references and only make it visible to trusted classes.  That would simplify the logic quite a bit and allow <em>Perl</em> to handle dispatching rather than <em>the programmer</em> handling dispatching.</p>

<p>There are also some annoying bugs with typeglobs.  One irritation occurs when one has a CODE slot defined in a glob with no corresponding subroutine.  This breaks inheritance and causes weird "not a code reference" messages.  Unfortunately, the best fix seems to either be deleting the entire glob or create a subroutine which dispatches up the inheritance heirarchy or dies with a "no such method" error message<nobr> <wbr></nobr>:(</p>

<p>Fortunately, I think all of these complaints go away in Perl 6.  Not sure about trusted methods, though.</p>



<blockquote>

<h2>Re:tease</h2>
<h3><a href="/user/runrig/">runrig</a> on 2005-10-05T22:28:43</h3>
<blockquote> <div><em>As a rule of thumb, having to check isa() indicates a design flaw.</em></div> </blockquote>
<p>There is Scalar::Util::reftype(), which would make the code slightly less ugly and broken, but your theoretical alternative would be nice also.</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

