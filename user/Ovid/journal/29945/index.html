<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of Ovid: What's in a name?</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>What's in a name?</h1>
<h2><a href="/user/Ovid/">Ovid</a> on 2006-06-18T18:17:54</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p>If you're familiar with chess, you might know the old saying "a player with a bad plan will beat a player with no plan".  As a general rule, once you commit to a strategy in chess, you should keep up that strategy unless diverting from it gets you a very clear gain which your opponent cannot overcome.  A player who plays for the moment with no eye towards the overall game will rarely succeed in the long-run.  Conversely, a player who only looks at the long-run will often overlook tactical opportunities and can be outplayed by a player who knows this weakness.  The great majority of players, though, play for the moment.  They might have an idea of some long-term goal, but they're constantly looking for short-term advantage.  In chess, those players are generally known as "losers" because, well, that's what they do.</p>

<p>In programming, we see something similar.  We take a bad system, we start refactoring, but in the interest of "getting it done now", we only get it halfway done.  This is then repeated many, many times despite the intention of gradually migrating to the "better way".  Then others come along and start to work on this system and they're seeing a hodgepodge of things like <tt>&some_func</tt> and <tt>&some_func_new</tt>.  Some code uses the "old style" and some code uses the "new style" but it's not always clear when it's appropriate to use either.</p>

<p>To be fair, a company doesn't often have the resources to simply rewrite everything.  Budgetary, temporal and resource constraints all conspire to keep a "half-baked" system half-baked.  However, without disciplined management and programmers, this is a very tough problem to overcome.</p>

<p>Since this problem is one we see constantly -- knowledge that code needs improvement and many partial efforts of dealing with this -- I think it needs a name.  Once something is labeled, it's easier to talk about and deal with.  <em>Does</em> this common situation have a name?  It would strike me as odd if it doesn't, but then, perhaps it's so terribly common that it's taken for granted rather than explicitly dealt with.</p></p>


<hr/>



<h2>And along with partial refactoring...</h2>
<h3><a href="/user/Alias/">Alias</a> on 2006-06-18T20:09:57</h3>
I see tons of similar decisions being made for new code as well.<br><br>Decisions which are clearly made with little thought towards the future.<br><br>Trouble is I don't see an obvious name for the overarching term other to invoke Back to the Future's "You're not thinking 4th dimensionally!!!".<br><br>That people can be suckered into trying to beating the Halting Problem, or a design decision that is clearly subject to a Tragedy of the Commons doesn't seem to me to be a general problem, they just don't see far enough ahead.<br><br>Perhaps something along the lines of "Instant Gratification" ?<br><br>(but that doesn't sound so hot...)



<blockquote>

<h2>Re:And along with partial refactoring...</h2>
<h3><a href="/user/Alias/">Alias</a> on 2006-06-18T20:12:10</h3>
Premature Gratification?<nobr> <wbr></nobr>:)





</blockquote>


<h2>My thoughts on the matter.</h2>
<h3><a href="/user/Shlomi Fish/">Shlomi Fish</a> on 2006-06-19T20:23:15</h3>
<p>
Hi Ovid!
</p>

<p>
I just returned from work when I saw your message and I can understand it
and relate to it. There may be one of the so-called
<a href="http://en.wikipedia.org/wiki/Anti-pattern" title="wikipedia.org">"anti-patterns"</a wikipedia.org> about
this, but since there are quite a few of them, I'm not sure if it will be
easy to find. I'm not much of a pattern/anti-pattern freak myself (as I like
to think of good solutions to problems when they are needed, and not waste
precious memory remembering tons of patterns), but there are people who
are more into this kind of thing. I can try asking someone I know (even IRL) who is a pattern-freak and see if he can recall anything.
</p>

<p>
While this is obviously a bad pattern, I think that refactoring is generally
touted to be done in small steps where none of the steps break the
behaviour of the program. Martin Fowler's "Refactoring" book contains some
large-scale refactorings which aren't like that, but that's usually a rare
case.
</p>

<p>
I think the main problem here is not in coding, but in management. If the
management does not allocate enough time for programmers to finish
refactoring, then it's a problem with the management. I'm pretty sure there's
a "We-shouldn't-do-any-refactoring" or "We don't have time for refactoring"
anti-pattern. Usually such management will get the project to crash and burn.
</p>

<p>
I personally believe that as long as the code works and is mostly bug-free,
it can almost always be salvated (i.e: refactored and then extended). There
were some successful rewrites, mainly in the open-source world, but I was never
involved in that particular stage of one to know if they were completely
justified.
</p>

<p>
One pattern I've been doing to some extent, which is different than that is
something I call "lazy refactoring" or "just-in-time" refactoring. (for not
knowing the correct terminology). What I do
is refactor the program just enough to accomodate for a change while leaving
other (none-critical) issues in place. I've successfully used this to develop
<a href="http://fc-solve.berlios.de/" title="berlios.de">Freecell Solver</a berlios.de>, which I wrote from
scratch in C, and then heavily extended, enhanced and optimised in future
releases. While sometimes I did a lot of refactoring, I often did just enough
refactoring or generalisation to later implement a certain enhancement.
</p>

<p>
At present, the code still has some issues, but it's still in a shape that
can accomodate later changes. I've received some negative criticism about it
from people who read it and tried to understand it claiming it was badly
written. To my critique, I agree that it's unreadable and sometimes possibly
over-optimised (possibly even over-micro-optimised), but it is still in good
shape.
</p>

<p>
BTW, today we discussed the pro's and cons of the proliferation of programming
languages on Freenode's #web channel. One item we touched upon is that
there's a lot of "legacy" code out there, which may be too costy to rewrite.
So for example there's a lot of COBOL code, which is still maintained, because
people are afraid to rewrite it in something better. (albeit IMO rewriting
COBOL code in Perl would be much easier than rewriting Python (for example)
or even C code in Perl, because you can do much more in one statement of Perl
than in one statement of COBOL). But still it's probably easier to maintain
the code in COBOL at least for the short term.
</p>

<p>
On the other hand, there's a lot of code in Perl and a lot of code in Python,
and no-one wants to rewrite it from the "legacy" language to the "better" one,
because it is easier to maintain it and extend it as is. As languages evolve
and more powerful and more succint languages come up
(I.e: C&rarr;Awk&rarr;Perl&rarr;Ruby&rarr;Perl 6), you still have the inertia
not to re-implement all the code in the new language that's only slightly
better. And eventually we get a COBOL-vs.-Perl 5 situation which seems
incredibly ridicolous.
</p>

<p>
One of the issues we discussed was whether this fragmentation between languages that are peers (i.e: offer much the same power and roughly the same succintness, but differ greatly, like Perl, Python, Ruby, Tcl and PHP) is a good thing and whether there is any hope of preventing it. The reason why it's not good is because it makes it harder to interoperate between codes written in different languages, and also encourages different implementations.
</p>

<p>
I diverted a little bit, but I hope it's OK. Cheers, and thanks for sharing this thought with us.
</p>



<blockquote>

<h2>Re:My thoughts on the matter.</h2>
<h3><a href="/user/Shlomi Fish/">Shlomi Fish</a> on 2006-06-25T20:15:09</h3>
<p>
Well, I talked with my "patterns" guy. He said that one may find what you're describing in the
<a href="http://www.laputan.org/mud/" title="laputan.org">"Big Ball of Mud"</a laputan.org> article that describes how a software project goes on to having a lot of bad code, possibly in terminal state. (Note that I have yet to read it)
</p>

<p>
As for my "lazy refactoring" or "just-in-time refactoring" - he called that "continuous refactoring", or at least thought it was a good
name for it, and said refactoring should be done at small, atomic steps. You can consult
<a href="http://www.laputan.org/mud/" title="laputan.org">Joel on Software's Rub-a-dub-dub article</a laputan.org> for documenting a one-time, lengthy and top-to-bottom refactoring, which may also be sometimes necessary.
</p>

<p>
I've done both kinds of refactorings in the past, and I hope everyone has.
</p>



<blockquote>

<h2>Re:My thoughts on the matter.</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2006-06-25T20:52:13</h3>
<p>You've nailed it.  Originally I didn't think about that because I had the incorrect impression that a big ball of mud primarily referred to a reasonable system which decayed with age.  From reading the first bit, I see that the BBOM also refers to what I described.  I think I need to reread that article again.  Thanks, Shlomi!</p>



<blockquote>

<h2>Re:My thoughts on the matter.</h2>
<h3><a href="/user/Shlomi Fish/">Shlomi Fish</a> on 2006-07-05T21:01:23</h3>
<p>
You're welcome.<nobr> <wbr></nobr>:-). I'll also try to remember to thank my expert on this as well for you.
</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

