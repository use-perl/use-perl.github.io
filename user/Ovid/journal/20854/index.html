<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of Ovid: Why not Smalltalk?</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Why not Smalltalk?</h1>
<h2><a href="/user/Ovid/">Ovid</a> on 2004-09-13T15:23:00</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p>I was chatting with a gentleman the other day about dynamic languages and he mentioned that he was at a workshop dedicated to them.  One camp focused on languages such as Perl, Python, and Ruby.  Others were focused on languages such as Smalltalk and Scheme.  Allegedly there's a lot of envy -- perhaps animosity -- surrounding Perl because it's ugly, has all of these weird hacks, isn't "pure," and yet is enormously successful.  At the same time, the Smalltalk and Scheme guys were trying to explain to the other camp that they solved our sorts of problems <em>decades</em> ago, so we should really listen to them.</p>

<p>This begs an obvious question:  if they solved these problems so long ago, why are they viewed primarily as academic languages?  Yes, Disney uses Smalltalk and Yahoo! Store was originally written with Lisp, but those seem like noteworthy exceptions.  The proponents of these languages at the aforementioned workshop were apparently unable to explain why (of course, this is news I heard second-hand and you're hearing third-hand.)</p>

<p>So why aren't they used more?  I suspect that part of it has to do with how "foreign" they are to most people's thinking.  I still remember when I was first learning C and wondered how you could program without line numbers.  If C wasn't so widespread, I might not have bothered with it.  Is this what hampers Smalltalk or is there a different mechanism coming into play?  I've read that <a href="http://c2.com/cgi/wiki?SmalltalkLanguage">Smalltalk used to be the second most popular OO language, but was displaced by Java</a>.</p></p>


<hr/>



<h2>Simple</h2>
<h3><a href="/user/djberg96/">djberg96</a> on 2004-09-13T15:51:07</h3>
Here's my theory, which I just *know* you're dying to hear:
<ul>
<li>Advertising.  Head to your local bookstore.  See the number of Perl and Java books?  Now, do you see any Scheme or Smalltalk books?  Many people have simply never heard of them, or only heard of them in passing.</li>
<li>Difficulty.  One can read Learning Perl and have a basic grasp on the language in a very short period of time.  I don't think the same can be said of Smalltalk or Scheme, at least not for your average hacker.</li>
<li>Syntax.  Smalltalk's syntax is annoying while Scheme's is downright alien to anyone without a functional language background.</li>
<li>Libraries.  Perl and Java both can boast a fat set of libraries.  Do such resources exist for Scheme and Smalltalk?  Maybe, but I've never heard of them.</li>
<li>ROV not significant enough.  Why should I switch from &lt;my favorite language&gt; to Smalltalk or Scheme?</li>
</ul>



<blockquote>

<h2>Re:Simple</h2>
<h3><a href="/user/malte/">malte</a> on 2004-09-14T08:15:31</h3>
You have never heard of a Smalltalk library because a huge beautifully designed class library is so inherent to the language that it is not worth mentioning.



<h2>Re:Simple</h2>
<h3><a href="/user/hardburn/">hardburn</a> on 2004-09-14T19:20:46</h3>
<p>I don't think any of these fully explain why Smalltalk/Scheme/whatever didn't catch on in the first place (though they would explain why it is so hard for them to catch up after other langauges took root). For instance, if Scheme was a more popular language, you would likely see a lot more Scheme books.</p>

<p>I also suspect the "Difficulty" and "Syntax" reasons are non-issues if functional languages were people's first exposure to programming. LOGO, for instance, has a functional syntax and has been used to teach school kids to program.</p>



<blockquote>

<h2>Re:Simple</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2004-09-15T01:23:06</h3>
<blockquote><div> <i>
I don't think any of these fully explain why Smalltalk/Scheme/whatever didn't catch on in the first place
</i> </div></blockquote>
True enough.<br/><br/><blockquote><div> <i>
I also suspect the "Difficulty" and "Syntax" reasons are non-issues if functional languages were people's first exposure to programming.
</i> </div></blockquote>
That's a pretty steep precondition for most programmers.  The vast majority of programmers today did <i>not</i> use a functional language when first exposed to programming.  The switch from an ALGOL derivative syntax and programming model to something fundmentally different is quite unsettling to many programmers.  One programmer's non-issue is another programmer's deal breaker.



<blockquote>

<h2>Re:Simple</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2004-09-15T15:05:00</h3>
<p>I agree about the steep precondition.  I still remember coming from BASIC to C in the 80s.  I struggled to understand how someone could program without line numbers.  Even though I agree with the premise that languages such as SmallTalk and Scheme would not seem so alien if these were the first languages that people were exposed to, the reality is that they are not the first language and they're unlikely to become that.  Hence, we have a chicken and egg problem that is essentially unsolveable from this approach.</p>

<p>Proponents of those languages are going to have a hard time promoting them unless they can "unscare" programmers.  I suspect that Paul Graham has had a moderate amount of success attracting people to Lisp due to his efforts.  I know that I looked into Lisp as a result -- but I never followed up because I had no opportunity to apply it in a real-world setting.</p>





</blockquote>

</blockquote>


<h2>Re:Simple</h2>
<h3><a href="/user/Isaac Gouy/">Isaac Gouy</a> on 2004-09-14T19:37:35</h3>
<ul> <li> <i>Advertising.</i> That's reinforcement not cause - there's a market for books because the languages are widely used.</li>
<li> <i>Difficulty.</i>One can read <a href="http://www.iam.unibe.ch/user/ducasse/FreeBooks.html" title="unibe.ch">"Smalltalk by Example"</a unibe.ch> and have a basic grasp on the language in a very short period of time.</li>
<li> <i>Syntax. </i>Smalltalk's syntax is simple, consistent, powerful.</li>
<li> <i>Libraries... but I've never heard of them </i>Have you ever looked for them? Smalltalk's rich libraries have been growing since 1980.</li>
<li> <i>ROV</i> That's why people switch to Smalltalk - get more done, faster, with fewer people. </li>
</ul>



<blockquote>

<h2>Re:Simple</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2004-09-15T01:33:06</h3>
<blockquote><div> <i>
One can read "Smalltalk by Example" and have a basic grasp on the language in a very short period of time.
</i> </div></blockquote>
Hardly.  That book is obscure and very hard to find on the bookshelf or at the bookstore.  It is freely available online <i>now</i>, but it wasn't 5, 10 or 15 years ago.  And freely available materials do not make a programming language easier to use or learn.  Some of the best materials about Python have been freely available since the project's inception, yet the size of the Python community is persists at about 1/10th of the size of the Perl community.
<p>
Now that this and other Smalltalk books are freely available and getting more widely advertised (Thanks, Google!) we may see Smalltalk's popularity increase.

</p><blockquote><div> <i>
Smalltalk's rich libraries have been growing since 1980.
</i> </div></blockquote>
Yes, and I think we've pretty firmly established that they are not very well advertised.  Again, reinforcement, not cause.





</blockquote>

</blockquote>


<h2>Another reason</h2>
<h3><a href="/user/educated_foo/">educated_foo</a> on 2004-09-13T17:13:33</h3>
Both Lisp and Smalltalk are almost hostile to cooperation with other software.  Smalltalk is the poster child for this, of course -- Squeak may be a wonderful environment (it's fun, I've tried it), but using a computer productively is all about interacting with other programs, handling files, and talking to other machines, and it's hard to interact with programs outside the Smalltalk VM.  In Lisp, this shows up as a "better is worse" syndrome, where you have a nice language with a large standard library, but still no standard POSIX interface, and a bizarre pathname facility that I typically try to ignore.<p>
Perl may be ugly, but it is IMHO one of the best languages out there for interacting with other programs and foreign libraries on a Unix system.  I think the Lispniks may be catching onto this, but Lisp has so many years of bad reputation to live down...</p>



<blockquote>

<h2>Re:Another reason</h2>
<h3><a href="/user/Isaac Gouy/">Isaac Gouy</a> on 2004-09-15T17:22:19</h3>
<i>"interacting with other programs, handling files, and talking to other machines"</i> <br>
Why don't you think Smalltalk supports "handling files"?<br> <br><br/><br/>How do you want to interact with other programs, and machines?<br>
Corba? Sockets? SOAP? CGI? COM? DLLs/Shared libraries? <a href="http://www.exept.de/exept/english/Smalltalk/frame_uebersicht.html" title="exept.de">inline C-code?</a exept.de> <br> <br><br/><br/>Here's the <a href="http://smalltalk.cincom.com/prodinformation/index.ssp?content=vwdocumentation" title="cincom.com">VisualWorks Smalltalks documentation</a cincom.com>



<blockquote>

<h2>Re:Another reason</h2>
<h3><a href="/user/educated_foo/">educated_foo</a> on 2004-09-16T15:04:26</h3>
Alright, you RTFMed me pretty good there.  Having only used two smalltalks (GNU ST and Squeak), and those only briefly, I made the same mistake many people do with Scheme: there are a bunch of languages out there called Scheme, some supporting practical extensions beyond the standard.  Using the wrong "Scheme", or only reading the standard, you get the impression that the language doesn't have much built in.  With Scheme, I've been fortunate enough to be exposed to both Bigloo and PLT, two implementations with many nonstandard, practical extensions.
<p>
As for "handling files" -- it's not just a matter of accessing the filesystem at all, but of slinging around directories and temporary files, generating input for and parsing output from text-based programs, dealing with proto-web-interfaces, etc., and doing all of these things as painlessly as possible.  In other words, scripting in the "shell scripting" sense.  This involves large numbers of intermediate files and complex external programs that I don't want to rewrite or try to hook into my language via FFI.</p>



<blockquote>

<h2>Re:Another reason</h2>
<h3><a href="/user/Isaac Gouy/">Isaac Gouy</a> on 2004-09-16T17:40:08</h3>
<i>'RTFMed me'</i> <br>
We all seem to mix up <i>language</i> and <i>language implementation</i><nobr> <wbr></nobr>;-)<br> <br><br/><br/><i>'scripting in the "shell scripting" sense'</i> <br>
That's something Perl was designed for, and not something Smalltalk was designed for.<br>
Having said that, once we start thinking about web apps, take a look at <a href="http://www.beta4.com/seaside2/docs.html" title="beta4.com">Seaside</a beta4.com>.



<blockquote>

<h2>Re:Another reason</h2>
<h3><a href="/user/educated_foo/">educated_foo</a> on 2004-09-16T20:47:12</h3>
We all seem to mix up language and language implementation<nobr> <wbr></nobr>;-)<br>
I think we also seem to mix up implementation (the interpreter, compiler, or whatever that makes programs run on a machine) and "implementation" (the non-standard extensions an implementation supports).  GCC is IMHO rightly slammed for supporting a host of weird extensions to the C language -- however useful they are, with the exception of inline asm, I don't think many people consider them a positive feature, since they lead to nonportable code.  Whatever else can be said of C, at least when someone complains about its shortcomings, "well, you should use this other implementation" is not an acceptable response.<p>
Maybe it's best to think of this the way some people think of natural languages vs. creoles or dialects.  There may be one version that is considered "the official language" for political reasons, but in fact each implementation's "creole" is its own separate language.  R5RS Scheme is too spartan for me.  The "Bigloo" language, with its optional typing, regular parsers, removable support for escaping continuations, etc., is more to my liking, but I'm not sure how meaningful it is to call it "Scheme".</p>





</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Development tools</h2>
<h3><a href="/user/iburrell/">iburrell</a> on 2004-09-13T19:38:23</h3>
Another reason I suspect is the availability of the language tools.  One of the big advantages of Smalltalk is supposed to be the integrated development environments.  The really good ones are expensive, commercial software.  There are now free versions (Squeak), but my impression was that are less powerful than the commercial environments.

<p>
The consequences that students don't learn the language in school, they can't play around with it at home, they are unlikely to use it to solve a small problem at work.</p>



<blockquote>

<h2>Re:Development tools</h2>
<h3><a href="/user/Isaac Gouy/">Isaac Gouy</a> on 2004-09-14T17:47:54</h3>
<i>"expensive, commercial software"</i> <br>
That you can download for free and use non-commercially as long as you like: <a href="http://smalltalk.cincom.com/downloads/index.ssp?content=visualworks" title="cincom.com">VisualWorks 7 Non-Commercial</a cincom.com> <br> <br><br/><br/>And powerful environments which are free for commercial use: <a href="http://www.exept.de/exept/english/Smalltalk/frame_uebersicht.html" title="exept.de">V Smalltalk/X</a exept.de>





</blockquote>


<h2>Smalltalk etc</h2>
<h3><a href="/user/n1vux/">n1vux</a> on 2004-09-13T21:33:31</h3>
Smalltalk was once the #1 OO language. Of course, that was when it was the only "general purpose" OO language, before C++ was released.<br> <br>I have actually been paid to program in SmallTalk twice, and to build an interface from one Scheme to another with C.  I went from C to SmallTalk to Objective-C to C++ to Perl (and Java), so perhaps I can provide some perspective. I have coded just about every "write only language" -- most of them for pay.<br> <br>Apart from Simula and the like, Smalltalk is the purest OO language still.  As with Pascal, purity does not buy you traction in the real world. The other comments regarding the virtues of integration with other software and the system are right on as to why the impure languages win out over the pure.  Pure elegant systems (Pascal, SmallTalk, Lisp/Scheme) have a tendency to see themselves as an end. Perl started as a scripting language, so has had extensible integration with the host OS's other programming tools from day 1.  Integration wins in the real world.  Ability to exec() a new process isn't enough, although even that's often not in Rev#1 of a "pure" language -- one needs call-and-return to/from legacy and 3rd party subsystems in "foreign" languages *and* call-and-return to separately maintained third-party subsystems in same language.  Single "Workspace Image" systems like SmallTalk made that hard in the early days, very hard. But on the early slow systems we had in the '80's, not saving a workspace image but reloading from sources at every work session was out of the question. Forth has solved this in recent revs, I think; has SmallTalk?<br> <br>Historically, the lack of integration with legacy databases meant Smalltalk was restricted to new projects only.  The selection of OODBs was initially slim and constrained to certain platforms; and of course OODBs were slow to gain the full-feature robustness of their RDB predecessors, but they came eventually.<br> <br>Smalltalk "VirtualMachine" / Browser model was actively hostile to multiple programmers and source control -- the code in the system image was the gold copy, not what was in your filesystem. The environment fought against "waterfall" development of big systems.<br> <br>With the explosion of small hardware in the 80's, there was an explosion of new projects, often outside the formal big-iron IT channels, and thus immune to the Standard Way. SmallTalk nicely fit this rebell niche, and offered a Rapid Development model with quick interaction with test users, perfect for departmental computing skunkworks -- if you put it in production before IT could complain about your project, you got to keep it. The competition for SmallTalk on Windows were MS Visual Basic and MS Visual C/C++ or Borland Turbo Whatever, not traditional technologies.<br> <br>Certain business sectors adopted SmallTalk -- those that needed ability to patch a system without taking it down; those that needed introspection in software (code aware of code and objects at runtime); AI groups who wanted a friendlier, newer framework than Lisp. I know of oil services geologists and financials and expert systems projects that found SmallTalk let them build things that they couldn't do otherwise.<br> <br>Wall Street had "programmed trading" systems on the floor to do instant arbitrage when two markets, indices or prices varied from each other.  These would be patched on-the-fly to adapt trading rules to changes in market conditions and market/regulator rules-changes.  SmallTalk programmers willing to wear a suit and a beeper got good money to fly into NYC every Monday to tend these systesms. Patching live code on the fly is scary<nobr> <wbr></nobr>... but with SmallTalk, it's at least doable.<br> <br>I'm not sure why the early eBiz Catalog Publishing startup that I contracted for used SmallTalk, the GEODE OODB really didn't give them any business advantage beyond not needing a DBA to tune its none existant tunings.<br> <br>One reason SmallTalk lost out to other OO languages was management bias against interpretive languages. Obviously with Java and Perl they've gotten over that to some extent, but the "class" files of partially-compiled Java are still preferred by old school folks. The reputation it had of making 2+1 a message to an object stung.<br> <br>CPAN is Perl's "killer app" (along with mod_perl etc), but the fact that it's possible to have CPAN modules that work *with* other software from other languages is the real winner compared to "closed" systems.<br> <br>-- Bill



<blockquote>

<h2>Re:Smalltalk etc</h2>
<h3><a href="/user/Isaac Gouy/">Isaac Gouy</a> on 2004-09-14T17:37:56</h3>
<i>"So why aren't they used more?"</i> <br>
One reason is badly dated mis-information like this!<br> <br><br/><br/><i>"Historically, lack of integration with legacy databases"</i> <br>
Pre-historically! Smalltalk ORM was common from '90<br> <br><br/><br/><i>"actively hostile to multiple programmers and source control"</i> <br>
From the late '80s Envy/Developer provided fine-grained (method level versioning) source code management. All the code was in a multi-user, replicated, database.<br> <br><br/><br/><i>"Wall Street had... Patching live code on the fly is scary"</i> <br>
Many of those systems are still around. (Working on live production systems is dumb in any language - normal work was done on development machines, sweated on staging machines, and then pushed to production servers.)



<blockquote>

<h2>Re:Smalltalk etc</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2004-09-15T01:44:46</h3>
<blockquote><div> <i>
From the late '80s Envy/Developer provided fine-grained (method level versioning) source code management. All the code was in a multi-user, replicated, database.
</i> </div></blockquote>
You've struck a cultural difference here.
<p>
On this side of the fence, "source control" is an aspect of the development process independent from the platform.  We generally think of source control as standalone tools like subversion, cvs, rcs, perforce, clearcase and whatnot.  Source code management in Smalltalk is a different beast with the same name and similar behavior.
</p><p>
When we cite the lack of integration with source control in Smalltalk instances, it is the lack of interoperability with the current tool-of-choice for source code management.  It means leaving our current well-worn tools behind and moving into a brave new foreign world.
</p><p>
Citing source code management in Envy/Developer misses the point.  It's not (necessarily) a slam that Smalltalk VMs (like Envy) are inferior to, say, Java, Perl, C# or Visual Basic.  It's (frequently) an observation that our favorite tools and skills aren't supported.  And that's disturbing.
</p><p>
I won't debate whether the CVS or the Envy model is better.  That's a religious war for another time.</p>



<blockquote>

<h2>Re:Smalltalk etc</h2>
<h3><a href="/user/Isaac Gouy/">Isaac Gouy</a> on 2004-09-15T16:45:43</h3>
<i>"an observation that our favorite tools and skills aren't supported. And that's disturbing"</i> <br>
I haven't seen people have difficulty learning the tools. I've seen people have real difficulty understanding object oriented design.



<h2>Re:Smalltalk etc</h2>
<h3><a href="/user/Isaac Gouy/">Isaac Gouy</a> on 2004-09-15T16:47:52</h3>
What makes you claim "Smalltalk VMs... are are inferior to, say, Java, Perl, C# or Visual Basic"?<br>
What comparison are you making?



<blockquote>

<h2>Re:Smalltalk etc</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2004-09-17T03:12:50</h3>
Um, read what I wrote.  I am not making the claim that Smalltalk is superior or inferior to anything.
<p>
I <i>am</i> making the claim when we say "Smalltalk doesn't support source code management", it's not the same thing you hear when you respond "Envy/Developer provides SCM."
</p><p>
We are saying "we are happy with cvs/p4/svn/..., and cannot use our tools in your development environment."  Your response that those capabilities exist in some other form does nothing to assuage our skepticism.
</p><p>
I do acknowledge that some less informed language bigots use the lack of CVS support to make the claim "<i>Sma11T4lk 5UX!</i>".  I am not making that claim, nor am I defending the language bigot who makes that claim.  I <i>am</i> stating that many who say "Smalltalk does not support [our favorite form of] SCM" are not saying that Smalltalk is inferior as a result.</p>





</blockquote>

</blockquote>


<h2>Show me the money (Ugh!)</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2004-09-15T15:18:55</h3>
<p>I think Envy/Developer is another reason why SmallTalk has issues with acceptance.  As a programmer, there are certain things I look for in a <em>development</em> environment, not just a language.  I want to know about the language(s) I'll be using, how source control is managed, the database (if any), the test suite, the IDE (if any), etc.  I like to learn about those things one piece at a time.  Throw too many at me at once, or tell me I cannot use tools that I am comfortable with and I'll likely be less interested.  Having tried and tested tools that the programmer already knows can inspire a lot of confidence.  The barriers to entry must be low unless I'm getting paid for it.</p>

<p>In fact, the only reason SmallTalk really interests me right now is the "pure" OO model that I keep hearing people talk about.  However, I'm brushing up on my Java because that's where the bulk of the work is.  Until I hear convincing arguments about how SmallTalk can improve my professional life, I'll probably just wonder about it.  I have a pretty active social life, so I don't have as much time for research as I would like.  I won't argue that this is necessarily the best attitude to have, but it's a pragmatic attitude that many programmers worried about their mortgage or rent, savings, and other financial considerations have.  "Show me the money" might sound rather mercenary, but I have to put food on the table.</p>



<blockquote>

<h2>Re:Show me the money (Ugh!)</h2>
<h3><a href="/user/Isaac Gouy/">Isaac Gouy</a> on 2004-09-15T16:37:20</h3>
<i>"tools that I am comfortable with"</i> <br>
Once in a while leave the comfort zone<nobr> <wbr></nobr>;-)<br> <br><br/><br/><i>"but I have to put food on the table"</i> <br>
You and me both.





</blockquote>

</blockquote>


<h2>Re:Smalltalk etc</h2>
<h3><a href="/user/dws/">dws</a> on 2004-09-18T20:41:17</h3>
<i>Historically, the lack of integration with legacy databases meant Smalltalk was restricted to new projects only.</i>
<p>
Visualworks 1.0 had connectors for Oracle and Sybase; later VWs had additional connectors, including one for ODBC. (Pre-merger) Digitalk Smalltalk also had database connectivity. Many of our (ParcPlace's) customers connected to legacy databases. What we didn't have was a story for connecting to "Big Iron" mainframe databases. (But then neither did Java for quite a while.)
</p>





</blockquote>


<h2>The Language Design Permathread</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2004-09-14T03:52:08</h3>
Ovid, you've raised a meaningful permathread about language design.
<p>
The short answer: academic languages are eclipsed by workaday languages because the academics are focusing on solving tomorrow's problems.  It's tomorrow, and we <b>are</b> adopting a lot of what they discovered decades ago (memory mangement, VMs, JIT, closures, objects, etc.).

</p><p>

A longer answer is <a href="http://use.perl.org/user/ziggy/journal/20866" title="perl.org">in my journal</a perl.org>.</p>



<h2>1.9 cents</h2>
<h3><a href="/user/gimbal/">gimbal</a> on 2004-09-14T08:27:11</h3>
<b> <em>This begs an obvious question: if they solved these problems so long ago, why are they viewed primarily as academic languages?</em> </b>

<p>
FWIW, some guesses, on that:
</p><p> <em>Reputation</em> would be the start of it, there.
</p><p>
<em>Lack of publicity</em> might be another part of it.
</p><p>
There may even be some cases (rare, perhaps, but perhaps possible) of "self doubt" (or <em>"language doubt"</em>?), among any users of said languages. I do not mean any sort of an odd joke by that, though; if it would be so, then it may be another matter hearkening back to <em>reputation</em> - really, of <em>perceptions</em> in the social sphere, which may exist <em>around</em> any languages or around any other tools or techniques.
</p><p>
<b> <em>So why aren't they used more? I suspect that part of it has to do with how "foreign" they are to most people's thinking.</em> </b>

</p><p>Heh, I'll avoid jerking my knee about what might be regarded, but too-lightly, as if it was an accusation that Smalltalk  or LISP  would be foreign to most people's thinking.
</p><p>As to the <em>why</em> of it, there: I could try to explain it away, myself, and not even succeed.</p><p><p>For the other half of my 1.9 cents, though:
</p><ul>
<li>I've supposed, for one, that maybe not so many colleges are necessarily <em>teaching</em> said languages,</li>
<li>and not necessarily so many employers are necessarily looking for people who know how to <em>use</em> said languages;</li>
<li>comparatively, not so many applications are being coded in said languages, to-date.</li>
<li> Furthermore - in regards to LISP, now, perhaps as an example - there is not necessarily any Sun Microsystems of LISP (as there is, or at least was, for Java),</li>
<li>and there is not necessarily any "hacker appeal" about LISP - noting, again, "reputation" here, beside any questions in regards to "ease of use"</li>
</ul>
<p>Now, perhaps to smash any doubt about it: Myself, I would neither think nor would I encourage anyone else to think as if there was any "anti-{LISP, Smalltalk} smear campaign" going around, or anything like it; I doubt that anyone else would really think as so, either. "If {LISP, Smalltalk} is useful, and yet has been commonly overlooked, then that may just be a quaint accident."
</p><p>Those of us who use said languages, and who derive any sense of benefit or general usefulness about them, I'd guess we're all generally content with 'em.
</p><p>Now - while meaning no slight about C or else -  I might wonder how many folks are quite <em>content</em>, themselves, with the languages that they've been sticking with. (For example, I've picked up an impression that maybe not so many people do really <em>enjoy</em> using C, though, evidently, very many people <em>do</em> use C. It is, quite so, a popular language.)
</p><p>and, hey, in the end, there is a variety of languages, and "there's more than one way to do it", yah?</p>



<h2>absence of evidence is not evidence of absence</h2>
<h3><a href="/user/Isaac Gouy/">Isaac Gouy</a> on 2004-09-14T19:08:42</h3>
<i>"if they solved these problems so long ago, why are they viewed primarily as academic languages?"</i> <br>
Simple ignorance. When we know what kind of software is developed with these languages (and how much money it makes) then we no longer regard them as academic languages.<br>
Would you have guessed that Smalltalk is used for the core of <a href="http://www.quallaby.com/" title="quallaby.com">Quallaby PROVISO</a quallaby.com>?<br>
Is there something <i>academic</i> about <a href="http://www.adventact.com/products/controlworks/" title="adventact.com">machine control software</a adventact.com> or <a href="http://www.oocl.com/" title="oocl.com">container shipping?</a oocl.com> <br> <br><br/><br/><i>"So why aren't they used more?"</i> <br>
The benefits of Smalltalk become obvious with medium-to-large scale projects. There are fewer medium-to-large scale projects than small-to-tiny projects.<br>
There are many more small problems which can be adequately resolved with scripting languages.<br> <br><br/><br/><i>'how "foreign" they are'</i> <br>
No, it's really nothing to do with the technology - it's this: <i>"If C wasn't so widespread, I might not have bothered with it"</i> and this <i>"was displaced by Java"</i>.
 With "Duke" running in a browser window, <a href="http://java.sun.com/features/1998/05/birthday.html" title="sun.com">Java grabbed name recognition and became linked with the potential of the Internet.</a sun.com>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

