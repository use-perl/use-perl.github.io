<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of Ovid: Should  We Do &quot;Computer Science&quot;?</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Should  We Do &quot;Computer Science&quot;?</h1>
<h2><a href="/user/Ovid/">Ovid</a> on 2009-03-05T10:00:51</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p>Universities are failing us.</p>

<p>From a paper entitled <a href="http://homepages.inf.ed.ac.uk/ratkey/paramnotions-jfp.pdf">Parameterized Notions of Computation</a>:</p>

<quote>Examples of such are composable continuations, side-effects where the type of the state varies and input/output where the range of inputs and outputs varies. By also considering structured parameterisation, we extend the range of effects to cover separated side-effects and multiple independent streams of I/O. We also present two typed &#955;-calculi that soundly and completely model our categorical definitions Ã¢â¬â with and without symmetric monoidal parameterisation Ã¢â¬â and act as prototypical languages with parameterised effects.</quote>

<p>Whoa!  Pretty heavy reading.  Now let's look at a <a href="http://search.cpan.org/user/drolsky/Moose-0.72/lib/Moose/Manual.pod#WHAT_IS_MOOSE?">description of Moose from the manual</a>:</p>

<quote>Moose is a complete object system for Perl 5. Consider any modern object-oriented language (which Perl 5 definitely isn't). It provides keywords for attribute declaration, object construction, inheritance, and maybe more. These keywords are part of the language, and you don't care how they are implemented.
<br><br>
Moose aims to do the same thing for Perl 5 OO. We can't actually create new keywords, but we do offer "sugar" that looks a lot like them. More importantly, with Moose, you define your class declaratively, without needing to know about blessed hashrefs, accessor methods, and so on.</quote>

<p>Assuming you know Perl, that's pretty accessible.  But looking at the first definition, what's "symmetric monoidal parameterisation"?  I have no idea.  The thing is, that's OK.  <em>I'm not the target audience</em>.</p>

<P>I admit that I've been very annoyed at times with articles which present really cool ideas but do so in such tedious language that I can't follow it, but if it's not aimed at me, I can't blame the author.  Other times we have works aimed at casual users, but <a href="http://use.perl.org/user/Ovid/journal/38501">the author fails to adequately address that</a>.</p>

<p>So what I see a lot of is "comp-sci" people sneering at us for not using their elegant and beautiful tools and "I have stuff to do" people who sneer at those would don't understand the risks of implementing production code that you can't find developers for.  This is unfortunate.  To a certain extent, I see this as the divide between theoretical and experimental physicists.  The first come up with grand ideas and the second cuts 'em off at the knees.</p>

<p>A better analogy, though, would be the difference between theoretical and <a href="http://en.wikipedia.org/wiki/Applied_physics">applied physics</a>.  The former thinks about how things work.  The second has to make things work.  Neither can really function at peak efficiency if they don't have <em>some</em> grounding in what the other does.</p>

<p>In programming, I'm still struck by a comment that a really good programmer I know made about the <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substitution Principle</a>.  He said "yeah, it's good in theory".  In practice, we had some methods which had varying interfaces and we were using if/else statements to catch the differences.  Admittedly, Liskov is sometimes problematic to apply because real-world conditions don't always map well to a class hierarchy, but like "using strict", you need to understand why it's important and, crucially, <em>why</em> you're not using it.</p>

<p>The problem here is ultimately <a href="http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html">the issue which Joel Spolsky has regarding "Java Schools"</a>.  It's not Java <em>per se</em> which is the problem.  It's the fact that people are learning to be McProgrammers and some programmers are turning out <a href="http://www.internetnews.com/dev-news/article.php/3618166">incomprehensibly complex frameworks</a> that McProgrammers can't use, but are still aimed at them.</p>

<p>It's a serious divide in the software world.  Many excellent "comp-sci" tools can make for simple, elegant code, but we're not teaching McProgrammers those tools.  This appears to largely be a failing of our universities, but given that it's largely been easy to get programming jobs without a degree, I'm unsure of how we can solve this problem.  We need the McProgrammers (and to be fair, there's nothing wrong with wanting to have a life outside of dense computer science papers), we need the computer scientists, but there's an awfully sparse array in the gulf between them and this group isn't able to do enough to bridge the gap.</p>

<p>We need universities to start addressing this.  They need to start teaching:</p>

<ul>
  <li>Communication skills (there's a reason I listed this one first)</li>
  <li>Automated testing</li>
  <li>Source control</li>
  <li>Working in teams on new code</li>
  <li>Working in teams on existing code</li>
  <li>Multiple language paradigms</li>
  <li>Complexity management</li>
  <li>Usability</li>
  <li>More that hasn't occurred to me in this brief write-up ...</li>
</ul>

<p>(I was tempted to add "manners" to that list)</p>

<p>Believe it or not, the best programming language instructors I had in college were two old COBOL programmers.  They had real-world experience and they taught us things we were actually going to <em>use</em>.  The worst instructors I had were my Java instructors.  One was fresh out of university and had trouble explaining the difference between a class and instances of said class.  One claimed real world experience but didn't understand MVC and had never done automated testing.</p>

<p>When I talk to new "university" programmers, they can write a heap sort from memory, they can explain complicated algorithms they've memorized, but they've often never programmed with anyone else and don't understand why deadlines are so important.  (One was so steeped in his "one true way" that he mocked Perl programmers for not using linked lists regularly).</p>

<p>Business pressures mean that we'll always need the casual programmers who can churn out that log analysis tool because that's a real-world need and for the sorts of jobs that I work on, I often want them.  Unfortunately, when I work on larger systems, I need to work with programmers who understand the importance of complexity management (watch the blank stares from many uni grads on that one), OO design and automated testing and deployment.</p>

<p>For those few times that (most) businesses <em>need</em> complexity, where do we find programmers who understand how to use <a href="http://en.wikipedia.org/wiki/Adaptive_resonance_theory">adaptive resonance theory</a> for recommendation systems?  Where do we find the programmers who can take an <a href="http://en.wikipedia.org/wiki/Ant_colony_optimization">ant algorithm</a> and apply it to your delivery driver schedules?  We need computer science and computer science needs implementers, but universities aren't churning out the graduates who can bridge this gap.  Business suffers for it, no one really seems to care.  We're limping along to where we need to go when we could at least walk, if not run.</p></p>


<hr/>



<h2>Liked this.</h2>
<h3><a href="/user/Matts/">Matts</a> on 2009-03-05T10:50:59</h3>
<p>A good read. Should get a wider audience.</p><p>Note you need to edit "explain explain" to just "explain".</p>



<blockquote>

<h2>Re:Liked this.</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2009-03-05T11:02:44</h3>
<p>Thanks.  And I fixed the "explain explain"<nobr> <wbr></nobr>:)</p>





</blockquote>


<h2>I think there's a step missing here.</h2>
<h3><a href="/user/mauzo/">mauzo</a> on 2009-03-05T12:38:01</h3>
I don't think the analogy with pure and applied physicists is correct. Working programmers aren't applied physicists: they're builders, or at most architects. Programming isn't a science, it's a trade, and I think what's missing here is some sort of degree (or other more vocational qualification depending on the educational system involved: I'm thinking of the sort of course that would once have been taught at English polytechnics) in Programming or Software Engineering, rather than Computer Science. Ideally the top level of this would lead to some sort of professional certification equivalent to the other branches of engineering (no doubt with the attendant requirement for vast amounts of tedious paperwork, but hey, that is actually the only way to make things work reliably in the end).
<p>The McProgrammers you mention are the equivalent of ordinary builders who know how to build a wall, or maybe a whole house, but don't have the higher-level knowledge of physics and (more importantly) engineering to design a large and complicated structure. There would be little point such a person trying to read a paper written by a physicist (pure or applied) and apply it to their day job: the research needs to be filtered through several layers of 'Engineer' before it can be useful to them.
</p><p>I suspect the root of the problem here is simply that CS as a discipline is so very young. Most of the physics used in (say) construction is several hundred years old, so we've had time to find out which bits are useful and how they apply to practical problems. In CS we keep trying to take pure research done approximately last week and use it in working programs right now.</p>



<h2>CPAN?</h2>
<h3><a href="/user/zby/">zby</a> on 2009-03-05T12:39:17</h3>
Nice article - just one observation.  Assuming our Open Source ecology is working you don't need to many people to understand the intricate algorithms - you just need a few of them to capture the idea and encode it into a library<nobr> <wbr></nobr>:)



<h2>No!</h2>
<h3><a href="/user/exussum0/">exussum0</a> on 2009-03-05T15:10:27</h3>
<blockquote><div><p>    *  Communication skills (there's a reason I listed this one first)
    * Automated testing
    * Source control
    * Working in teams on new code
    * Working in teams on existing code
    * Multiple language paradigms
    * Complexity management
    * Usability
    * More that hasn't occurred to me in this brief write-up<nobr> <wbr></nobr>...</p></div>
</blockquote><p>

Computer science is as much about computers as astronomy about telescopes, right?
</p><p>
Everything you wrote up here is explainable within a couple of days.  Most of it requires lots of practice.  Being disagreeable while being agreeable is a skill you learn elsewhere, just like manners.
</p><p>
Most colleges teach using the pop language today, which to the fairness of the 3 schools I attended (looking at the course requirements), made up 6 credits out of 128, 8 credits out of 128 and lastly, 0 out of 64 credits required.
</p><p>
It sounds like most of your point is not knowing their terminology.  In the non-scholarly world, most of what we build or interact with is fairly common stuff.  A forum has posts and replies.  A letter has a thread of correspondence.  It out lay it out on a table, you have multiple threads.
</p><p>
When you talk about the theoretical complexity and classification, you have to use new terms.  Describing them every time gets old, fast.  The barrier to entry is knowledge.  In your BS degree, you learn about the book.  In your MS, you learn to read and enjoy the book.  In your PhD, you learn to write the book.
</p><p>
We've all done the business concepts to death.  The next progressions are a) stagnate and branch out into other goals, like making lots of money or other fields like biology and applying it there or b) LEARN MORE.'
</p><p>
I'll reiterate the list and demonstrate how silly these things are in comparison to real problems.</p><blockquote><div><p>    *  Communication skills (there's a reason I listed this one first)</p></div>
</blockquote><p>

This is a tech writing and/or language of your choice Thing.  We mostly learn this anyhow.</p><blockquote><div><p>    * Automated testing</p></div>
</blockquote><p>

There are 4 or 5 types of tests.  These can be described within minutes. A day of practice, and you're done.  This isn't a science problem, but a process problem that's being solved.  You write stuff, you test it.  You ensure you always make sure it works, even after changes to the target.</p><blockquote><div><p>    * Source control</p></div>
</blockquote><p>

File goes in, file comes out.  Changes are tracked and copies are made.</p><blockquote><div><p>    * Working in teams (snip)</p></div>
</blockquote><p>

This isn't a computer science agenda.  This is a life lesson.</p><blockquote><div><p>    * Multiple language paradigms</p></div>
</blockquote><p>

Turing complete.  Any mess can be made in any language.  Any masterpiece as well.</p><blockquote><div><p>    * Complexity management</p></div>
</blockquote><p>

Alogirthms teaches big-o notation and fundamentals.  Anything much more beyond that usually requires a masters.</p><blockquote><div><p>    * Usability</p></div>
</blockquote><p>

UI usability?  That's environmental psych.

I don't usually rant like this, but c'mmon - a request to dumbing ourselves down?</p>



<blockquote>

<h2>Re:No!</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2009-03-05T19:41:53</h3>
<blockquote><div><p> <em>Everything you wrote up here is explainable within a couple of days.</em></p></div> </blockquote><p>I'd love to hire super geniuses like the ones you've taught, but unfortunately the rest of the world isn't nearly that capable.  Some ten years in, and <em>I'm</em> still figuring out the nuances of automated testing.</p>



<blockquote>

<h2>Re:No!</h2>
<h3><a href="/user/exussum0/">exussum0</a> on 2009-03-06T12:31:27</h3>
Nuances are nuances.  You do understand the principle points of it, eh?  You're a bright fellow.  Just like we all can do division, but the larger the numbers, the easier it is to screw up, and it takes time when someone does something screwy.



<blockquote>

<h2>Re:No!</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2009-03-06T20:15:03</h3>
<p>I can explain the principal points of functional programming to my five year old nephew in a few minutes, but even Abelson and Sussman spent more time on it at MIT.</p>





</blockquote>

</blockquote>

</blockquote>


<h2>&quot;We need universities to start addressing this&quot;</h2>
<h3><a href="/user/Adrian/">Adrian</a> on 2009-03-05T16:57:39</h3>
<p>A semi-serious question.</p><p>Is it the job of universities to train people to do computing jobs?</p><p>I completely agree that - by and large - a CS degree doesn't prepare folk for many aspects of the job of being a developer. But should it?</p><p>Getting nostalgic for the old polytechnics...</p>



<blockquote>

<h2>Re:&quot;We need universities to start addressing this&quot;</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2009-03-05T19:32:44</h3>
<p>I think it's the job of universities to teach their students the skills they need to succeed in their chosen field.  If it's not computing jobs, that's fine, but if it is, they fail.</p>



<blockquote>

<h2>Re:&quot;We need universities to start addressing this&quot;</h2>
<h3><a href="/user/btilly/">btilly</a> on 2009-03-06T08:55:10</h3>
<p>Universities have 3 basic missions:</p><p>1. Advancing the state of knowledge.<br>2. Exposing students to knowledge.<br>3. Training students for future careers.</p><p>These are listed in decreasing importance in the eyes of universities.  From the point of view of most students, this should be in increasing order of priority.  From the point of view of employers, this definitely should be increasing order of priority.</p><p>Whenever a person or institution judges their performance by different criteria than outsiders judge them by, conflict is inevitable.  However do you really want universities to prioritize on career development?  The ones that do, tend to be the ones whose CS programs are glorified Java schools.</p><p>That said, every field has a core that everyone is expected to know.  My opinion is that the core for CS should include a good dose of software engineering.  Which would include many of your topics.  However I don't argue that just on its utility on the job, but because software engineering helps you reliably write the kinds of programs that CS research requires you to write.</p>





</blockquote>

</blockquote>


<h2>Poppycock</h2>
<h3><a href="/user/Alias/">Alias</a> on 2009-03-05T23:00:06</h3>
<p>Applied Physics people explain how the idea might work in the real work with available materials.</p><p>But in the end it's the engineers that actually make it work.<nobr> <wbr></nobr>:)</p>



<h2>Deadlines are only important</h2>
<h3><a href="/user/SimonHawkin/">SimonHawkin</a> on 2009-03-06T01:30:10</h3>
...because people who set them give us paychecks.<br/><br/>They are rarely important in the technical sense. Sometimes a project has to be finished before another which depends on it can start. More often, however, it's just a way for the boss(es) to assert their authority.



<blockquote>

<h2>Re:Deadlines are only important</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2009-03-06T07:04:54</h3>
<p>I've worked on deadlines which:</p><ul>
  <li>Which had severe legal consequences if we don't have it implemented</li><li>Which might save a client from bankruptcy <em>if</em> it was implemented in time (that one was <em>not</em> fun)</li><li>Holds up other projects if it's not implemented (many, if not most, of my deadlines now fall in this category)</li><li>Were simply part of a company struggle to stay alive</li></ul><p>Yes, I've worked on some projects which are simply management trying to assert authority, but that's been the minority.  I'm sorry to hear you've had a different experience.  That doesn't sound fun.</p>



<blockquote>

<h2>Re:Deadlines are only important</h2>
<h3><a href="/user/SimonHawkin/">SimonHawkin</a> on 2009-03-06T18:29:51</h3>
Well, of course my reply had a lot of tongue-in-cheek in it. However, the original post was talking about people not understanding the importance of deadlines, and this kind of talk is usually reserved to those of us who prefer to tell people what to do rather than do it.





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

