<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of Ovid: Extreme Programming is Misnamed</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Extreme Programming is Misnamed</h1>
<h2><a href="/user/Ovid/">Ovid</a> on 2003-12-29T23:42:40</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p>This is probably not a terribly original observation on my part, but Extreme Programming is horribly misnamed.  I don't view it as particularly extreme:  it merely says "follow the good programming practices that you already know about".  What, if anything, is extreme is that it tells you <em>how</em> to follow those good programming practices.</p>

<p>The big problem I have with the name, though, is the implementation detail embedded in the name.  "Programming" shouldn't be there.  XP is about project management, not about programming per se.  If you took out the programmers and said "carpenters should review each others work, not build things the customer didn't ask for, get frequent feedback from the customer, etc.", then many people would shrug and agree.  If anything, it should be called XPM:  eXtreme Project Management.  However, since I don't think it's extreme, I suppose we could call it Really Good Project Management, but RPGM just doesn't have the same ring to it.</p></p>


<hr/>



<h2>What XP Ought To Be Called</h2>
<h3><a href="/user/mdxi/">mdxi</a> on 2003-12-30T00:08:50</h3>
"Making Tons Of Money By Writing Down Linux's Internet Based Design And Implementation Method (But Without The Internet Part) And Telling Businesspeople It's Really Cool (Like OO)"



<blockquote>

<h2>Re:What XP Ought To Be Called</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2003-12-30T01:31:02</h3>
<p>They got the Linux kernel wrong, then, as "refactoring" should be called "throwing it all away and starting over from scratch every release" and "automated testing" should be "ask users to debug it for you and berate them for not reading the development mailing list religiously".<nobr> <wbr></nobr>:)</p>

<p>Lots of open source projects succeed because their leaders are exceedingly brilliant at project management without discipline.  Lots more projects succeed because there's a point at which you can throw many, many warm bodies at a problem and get something that works reasonably well.</p>

<p>Please don't misunderstand: I think open source does well at collaboration, pragmatism, and soliciting feedback.  If you set aside philosophic goals of freedom (which I hate to do, because they're important to me), the reason it works so much better as a software development model over proprietary development schemes is not because open source developers are brilliant, disciplined, and thoughtful.  It's because so much of proprietary software development is shockingly bad.</p>



<blockquote>

<h2>Re:What XP Ought To Be Called</h2>
<h3><a href="/user/mary.poppins/">mary.poppins</a> on 2003-12-30T06:07:50</h3>
Free software is worker control.  This means:<br> <br>
&nbsp; &nbsp; &nbsp; 1) workers aren't forced to work on the boss's bad ideas -- the bad ideas<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have to attract the workers on their own (see apache.org java stuff<nobr> <wbr></nobr>:)<br>
&nbsp; &nbsp; &nbsp; 2) no boss deadline pressure<br>
&nbsp; &nbsp; &nbsp; 3) no boss backward-compatibility pressure<br> <br>These three things are, in my experience, responsible for the bulk of stupidity<br>in boss-run proprietary software organizations.<br> <br>Now, of course, the lack of these bad things does not guarantee great software<br>(cough cough perl5 guts cough cough<nobr> <wbr></nobr>:), but it does at least *allow* it.<br>



<blockquote>

<h2>Re:What XP Ought To Be Called</h2>
<h3><a href="/user/jdavidb/">jdavidb</a> on 2003-12-30T14:48:39</h3>
<p>But how can you say the Perl 5 guts don't have backward-compatibility pressure?<nobr> <wbr></nobr>:)</p>



<blockquote>

<h2>Re:What XP Ought To Be Called</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2003-12-30T15:51:49</h3>
<p>Let's not talk about backward pressure in guts, please.  There might be children present.</p>



<h2>Re:What XP Ought To Be Called</h2>
<h3><a href="/user/mary.poppins/">mary.poppins</a> on 2003-12-30T16:18:18</h3>
Of course there is backward compatibility pressure -- but it doesn't compare to<br>a proprietary shop, where the boss says "We can't lose this big account -- so<br>don't change anything, anywhere, that might cause them problems."<br> <br>One of the reasons that proprietary software sucks in general is that the<br>programmers are first rushed, then told not to change anything.  Developers of<br>free software have much more freedom to say "The next major version will change<br>things; stick with the old version if you want; fork the project if you want."<br>



<blockquote>

<h2>Re:What XP Ought To Be Called</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2003-12-31T07:23:38</h3>
<p>Right, open source software is less affected by economic pressure.  That's probably the largest pressure that leads to an immature release, but it's not the only one.</p>

<p>(<em>Sidebar:</em>  This weekend, Ward Cunningham and I discussed the idea that open source's biggest advantage is not necessarily improved communication, it's scalability &mdash; in the sense that a thousand hackers can throw themselves at a problem and a few might eventually come up with a solution.  I'll continue to argue that practicing a little more discipline will help us solve our current problems more quickly and more effectively.  Ward points out that we'll find a whole new set of problems then.)</p>



<blockquote>

<h2>Re:What XP Ought To Be Called</h2>
<h3><a href="/user/mary.poppins/">mary.poppins</a> on 2003-12-31T12:39:39</h3>
W.R.T. "scalability" -- thousands of hackers are not needed, and generally not<br>involved.  It takes only a few really good ones to solve a particular problem.<br>And those really good hackers produce much better work when they have control.<br> <br>In my experience it is proprietary shops that use the "hordes of programmers"<br>approach, trying to crank out software quickly by throwing lots of mediocre<br>programmers at the problem.  The "wizard in the tower" approach, though<br>sometimes slower, gets better results.<br> <br>Now, one could bring up the linux kernel as a counter-example, but even there<br>there are a few main programmers for each subsystem.  Besides, I would wait for<br>2.6 to work well in practice before holding up linux as an example of good<br>development methodology.<br>





</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>drinking the sweet, sweet kool-aid</h2>
<h3><a href="/user/lachoy/">lachoy</a> on 2003-12-30T03:31:38</h3>
it's not extreme to you because you've already bought into it and you're looking at it from a smart developer's point of view. Of <b>course</b> small development iterations are good; of <b>course</b> forcing customers to choose features based on an honest assessment of the costs is good; of <b>course</b> continuous testing is good.

<p>IME XP really is extreme for old-school big-design-up-front folks. Or for people who think Big Serious Projects require one or more Serious Architects who dictate in the form of The Specification to the Small Developers what Shall Be Done. And then the project is 50% over budget and 66% late, but they keep doing the same thing over and over, because it's what they know. And it's not just old COBOLers either -- for an extreme reaction, just bring up pair programming on any development list or forum that isn't solely populated by xp-folks...<nobr> <wbr></nobr>:-)

</p><p>I do think the association with Mountain Dew, bungee jumping and crazy ski guys is unfortunate and causes people to have a bad first impression. Too late now...</p>



<h2>It's about programming too</h2>
<h3><a href="/user/jplindstrom/">jplindstrom</a> on 2003-12-30T17:20:08</h3>
Oh, I'd say it's partly about programming.<br> <br>Test-driven-development, pair-programming and a lot of the attitudes like you-aint-gonna-need-it and once-and-only-once are very much hands-on programming related.<br> <br>There is a project managemenet aspect as well of course. And somewhere the line is blurred, like YAGN; that's part programming design, part project management strategy.<br> <br>IMHO, and what do I really know?, I've never actually _done_ XP<nobr> <wbr></nobr>:)  But I know I've had great success with TDD, YAGN and aggressive automation.<br>



<h2>Extreme Mowing</h2>
<h3><a href="/user/DAxelrod/">DAxelrod</a> on 2003-12-31T06:31:45</h3>
This reminded me of Andy Lester's (just slightly tounge-in-cheek) "Extreme Mowing" article in The Perl Review: http://www.theperlreview.com/Issues/v0i5.shtml<br/><br/>It's about how he successfully applies XP principles to mowing his lawn.<br/><br/>I don't remember whether he had a test suite, though. And I don't think pair mowing would work too well; lawnmowers are designed to be pushed by a single person, and you can't really converse over the noise of the engine.



<h2>Good practices might not be good together</h2>
<h3><a href="/user/dws/">dws</a> on 2003-12-31T22:25:35</h3>
<i>I don't view [Extreme Programming] as particularly extreme: it merely says "follow the good programming practices that you already know about".</i>
<p>
Well, not everyone agrees that each of the XP practices is good. A lot of people view pair programming as a waste of one programmer.
</p><p>
Extreme Programming is one set of good practices which have been shown to reenforce one another. There are plenty of other good practices, but if you cherry pick practices and put them together without considering how they interact, you might end up with team that chugs along one half power, belching smoke and leaking oil.
</p><p>



<blockquote>

<h2>Re:Good practices might not be good together</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2003-12-31T22:43:28</h3>
<p>The strongest objections to pair programming that I hear usually seem to come from those who have little experience with it and those who prefer to be alone.  The objections, in fact, remind me of an interview where the manager told me "we don't want you writing tests because that will slow down your programming."  I was offerred the job, but I declined.</p>

<p>Having done quite a bit of pair programming here at work, I've discovered that it can be a bit tough as many programmers are, shall we say, not overly social.  However, I've also discovered that a good pair can dramatically improve code quality and save many headaches.  One pair tells the other "no, don't do that.  We've already implemented it over there."  Meanwhile, the other pair says "hey, you forgot to test if that's defined."  When we stop pair programming, the team as a whole does seem to crank out more code, but we also wind up with more bugs slipping through, even with our tests.  It's been fascinating watching how well our processes have validated many core XP tenets.</p>





</blockquote>


<h2>Not really (IMHO), at least not for that reason :-</h2>
<h3><a href="/user/Adrian/">Adrian</a> on 2004-01-05T16:01:31</h3>
<blockquote><div> <em>This is probably not a terribly original observation on my part, but Extreme Programming is horribly misnamed.  I don't view it as particularly extreme:  it merely says "follow the good programming practices that you already know about".</em> </div></blockquote>

<p>That's quite a big "merely" considering how many people ignore good practices on a daily basis:-)</p>

<p>I agree that, in hindsight, XP was a terrible name - but only because of the "dangerous" / ad-hoc / bungie-jumping connotations.</p>

<p>To me the "extreme" was always intended to indicate the level that you take the good practices to:</p>
<ul>
<li>If code reviews are a good thing, do them all of the time by pair programming</li>
<li>If customer feedback is a good idea, do it all of the time by having small iterations and regular releases</li>
<li>If tests are a good idea then... well... I'm sure you get my drift<nobr> <wbr></nobr>:-)</li>
</ul>

<p>It's extreme not because of the things you do, but due to the fact that you turn up following the good practices to the max.</p>

<blockquote><div> <em>The big problem I have with the name, though, is the implementation detail embedded in the name.  "Programming" shouldn't be there.  XP is about project management, not about programming per se. </em> </div></blockquote>

<p>Hmmm. Of the practices unit/acceptance test first, pair programming, collective code ownership, refactoring, YAGNI, etc. all seem related to programming to me<nobr> <wbr></nobr>:-)</p>

<p>Also where does the join between project management and programming live? Where does analysis/design live in that continuum?</p>

<p>Possibly it's a case of reclaiming a term that has come to mean "code monkey who follows instructions from on high" but, to me programming is about creating products for my clients (and having fun of course<nobr> <wbr></nobr>:-). How can you have programming without some sort of project management process? </p>



<blockquote>

<h2>Re:Not really (IMHO), at least not for that reason</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2004-01-05T16:52:58</h3>
<blockquote><div>Of the practices unit/acceptance test first, pair programming, collective code ownership, refactoring, YAGNI, etc. all seem related to programming to me<nobr> <wbr></nobr>:-)</div></blockquote>

<p>As from from test first programming, those seem applicable outside of programming.</p>

<ul>
<li>YAGNI -- painters don't do extra fancy trimming unless asked.</li>
<li>Pair programming -- people working in teams to check each other's work.</li>
<li>Collective code ownership -- rotating accounting personnel through various deparments so they can see the whole business.</li>
<li>Refactoring -- Multiple similar policies or tasks are consolidated.</li>
</ul>

<p>:)</p>



<blockquote>

<h2>Re:Not really (IMHO), at least not for that reason</h2>
<h3><a href="/user/Adrian/">Adrian</a> on 2004-01-05T22:40:27</h3>
<p>I think you're reaching on some of those<nobr> <wbr></nobr>:-) For example you get a lot of synergy between the XP practices in programming that you don't get in other fields (it's hard to refactor a damp-proofing layer if you're a YAGNI painter!)</p>

<p>I stiill think the XP practices are more about programming than project management.</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

