<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of Ovid: Pair Problems</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Pair Problems</h1>
<h2><a href="/user/Ovid/">Ovid</a> on 2004-07-11T21:18:05</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p>One theory of pair programming is that it keeps developers honest.  That doesn't seem to be as true as I thought.  I've watched a programmer get his tests passing, claim he was finished and then had his pair sit silently, despite the fact that the follow-up refactor was not done, the code needed some serious cleanup and the tests were woefully inadequate.  Programmers do not always have the best social skills and many find it difficult to tell someone else that they're not finished or they say it so bluntly that feelings are hurt.  Pairing is inherently a social activity.  With geeks.  What could possibly go wrong?  We can sit around and discuss, ad naseum, the intricate details of various Linux distributions, but pairing doesn't just require compensation for different technical skill sets, it also requires compensation for different motivation levels and <em>that</em> requires people skills that some of us simply do not have.  This, I think, is an inherent contradiction in the needs of pairing versus the abilities of people actually engaging in it.</p>

<p>We've had programmers fall asleep because they were so bored while pairing.  Another programmer was caught playing a Gameboy while pairing.  And let's be honest:  there are some programmers that no one ever wants to pair with.  One programmer, no longer with the company, summed it up quite nicely when he said "Pair programming is great.  If I show up with a hangover I can just grab a pair and let him do the work."</p>

<p>Pair programming is a great idea but it is not a cure-all -- of course, no knowledgeable XP proponent claims this.  The team I work on has six programmers.  Recently, we had a programmer get promoted while we were still one person down.  We had, in effect, four people to do a six person job.  Hollywood really doesn't care if we're short-staffed, so pair programming got tossed out the window and everyone kept working like mad to get things done.  And we did.</p>

<p>Several months ago when we stopped pairing due to workload, our bug rate went up, but this time it hasn't.  Instead, our productivity went up significantly and management is, predictably, very happy about this.    We've not abandoned pairing.  The rule of thumb we use is "grab a pair when you need it."  We're having some issues in that we still need to spread knowledge around a bit more, but so far things have worked out very well.  I'm very curious to see how our deformed XP variant will perform in the future.</p></p>


<hr/>



<h2>Re: Pair Problems</h2>
<h3><a href="/user/dws/">dws</a> on 2004-07-12T05:00:42</h3>
<p>
What you're describing sounds like a situation where pair programming was mandated from outside the team.
</p>
<p>
The team I'm with chose to do XP. We screen for the ability to pair program during the later phase of the interview process. If someone on the team fell asleep while pairing, we'd probably dye his hair a funny color (or an even funnier color).
</p>



<blockquote>

<h2>Re: Pair Problems</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2004-07-12T11:52:54</h3>
<blockquote><div> <p>(or an even funnier color)</p> </div></blockquote> LOL! That must be an interesting team.





</blockquote>


<h2>XP: an amalgamation</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2004-07-12T11:51:49</h3>
<p>I don't regard XP as a single, monolithic set of practices. All of its parts individually make sense, and they enhance each other, but I don't see a reason that they're all required during every phase of every part on every project. The single most important practice, in my observation (but not experience), is test-driven programming. All else is somewhat optional, or at least flexible, depending on the scope and size of the project and the rest of your methodology.</p>

<p>XP to me seems much like many assertions of what results in good code &mdash; a framework of guidelines you should follow until you understand it, at which point you will still follow it most of the time, but will know when to deviate from it. It is much like things such as &ldquo;use strict and warnings!&rdquo; and &ldquo;use CGI.pm!&rdquo;.</p>



<blockquote>

<h2>Re:XP: an amalgamation</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2004-07-12T15:49:17</h3>
<p>I definitely agree with the much of what you say, but I am concerned about XP in general.  Pair programming is code review -&gt; don't do too much refactoring without code review -&gt; don't do the refactoring without tests -&gt;don't write the tests without a clear understanding of the what the task is, etc.  Pair programming is also knowledge sharing -&gt; with knowledge sharing and more tests, we can write less documentation.  XP seems to create certain chains of events that, if not properly understood, can cause people to stumble when they miss some of the links.</p>

<p>The refactoring link might be one of the biggest failures.  The design cannot efficiently "evolve" from the code when refactoring isn't being done properly/consistently.  I've had to deal with tedious objections from programmers who fail to understand the "don't duplicate" rule.  They argue (sometimes correctly) that too much abstraction can detract from the task at hand, but fail to realize that eliminating duplicated code, when done properly, leads to greater clarity rather than greater abstraction.  I was also stunned when people objected to me removing <em>many</em> modules with structures as follows:</p> <blockquote><div> <tt>package Foo::Bar;<br>use base 'Foo';<br> <br>1;</tt> </div></blockquote> <p>Those were all over the place because the intent, over a year ago, was to fork the code, but now those were simply useless barriers to further development, had duplicated tests (oh, for inherited tests!) that had to be maintained, but kept 'em because people were afraid of what would break if they were removed (I thought the tests were supposed to add courage for doing the right thing?)  I managed to remove them one day by simply doing it as part of a task to "improve performance," but I'm still surprised that people actually wanted that mess.  As dws pointed out, though, much of this  is due to XP being imposed from the outside on many developers.  If they really trusted it, I suspect we wouldn't have some of the silliness that we do.  We're <em>so</em> close to having a team that really shines, but that final coat of polish seems to be lacking.</p>



<blockquote>

<h2>Re:XP: an amalgamation</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2004-07-12T18:23:42</h3>
<p>Again, the biggest issue is quite clearly test-driven development. Your coworkers do not seem to have understood why they should write tests. Consequently, they're seeing them as a burden, writing woefully inadequate ones to claim they're done. Inevitably, they have no courage to refactor cruft. It is all pretty obvious, if you ask me.</p>

<p>I really believe that once a programmer understands in his heart why test-driven development is A Good Thing, then all the other practices of XP will be understood effortlessly and will come to him naturally.</p>

<p>It is the single most important lesson of XP and a universally useful approach. In fact, you can <em>always</em> practice test-driven development if you want to &mdash; even in a corporate environment with traditional project management methodology. A programmer who Has Understood test-first will do that on his very own if need be, even if noone else follows this practice.</p>



<blockquote>

<h2>Re:XP: an amalgamation</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2004-07-12T18:27:21</h3>
<p> <em>In fact, you can always practice test-driven development if you want to...</em> </p>

<p>I turned down one Perl job because the man who interviewed me told me that he forbade programmers from wasting time writing tests<nobr> <wbr></nobr>:)</p>



<blockquote>

<h2>Re:XP: an amalgamation</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2004-07-12T19:31:13</h3>
That is&hellip; I am speechless.



<h2>Re:XP: an amalgamation</h2>
<h3><a href="/user/jplindstrom/">jplindstrom</a> on 2004-07-13T00:53:55</h3>
If that guy had a coherent explanation for that idea, it would actually be pretty interesting to hear the reasoning behind it.



<blockquote>

<h2>Re:XP: an amalgamation</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2004-07-13T01:01:41</h3>
<p>His reasoning was that writing tests meant that you were writing twice and thus were taking twice as long to get anything done.  Since the process of debugging requires running the application anyway, that's where testing "should" be done.  (No, I don't buy his argument either<nobr> <wbr></nobr>:)</p>





</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Why is it different this time?</h2>
<h3><a href="/user/Adrian/">Adrian</a> on 2004-07-12T17:21:42</h3>
<blockquote><div> <em>Several months ago when we stopped pairing due to workload, our bug rate went up, but this time it hasn't.</em> </div></blockquote>

<p>Any theory as to why it's different this time around?</p>



<blockquote>

<h2>Re:Why is it different this time?</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2004-07-12T17:35:45</h3>
<p>My guess (and I stress that it's just a guess) is that we're not making the sweeping changes we were last time (switching colocations and changing the look and feel of the entire site), nor do we have the deadline pressure.  I think the combination of the two last time really bit us.  Of course, there's also the possibility that the improved test suite helps.  I've spent a lot of time nailing all of the tests to ensure that none of them fail intermittently.  Now, if a test fails, it probably really is a bug and is less likely to be ignored.  It's probably a variety of factors, some of which I don't know.  Basically, don't place your programmers in a pressure cooker and they won't boil over<nobr> <wbr></nobr>:)</p>





</blockquote>


<h2>'2-per-computer' ne 'pair-programming'</h2>
<h3><a href="/user/Adrian/">Adrian</a> on 2004-07-12T21:57:27</h3>
<blockquote><div> <em>One theory of pair programming is that it keeps developers honest. That doesn't seem to be as true as I thought. I've watched a programmer get his tests passing, claim he was finished and then had his pair sit silently, despite the fact that the follow-up refactor was not done, the code needed some serious cleanup and the tests were woefully inadequate.</em> </div></blockquote>

<p>For me this, and the other examples you list, aren't demonstrations of pair programming not providing benefit, but examples of people who are not doing pair programming.</p>

<p>You actually have to <em>do</em> pair programming before you can figure out whether it benefits you, and just because two people are sitting in front of a computer doesn't mean that they're doing pair programming.

</p><p>If you have two people on stage and one of them is playing a gameboy and the other is asleep then they ain't singing a duet<nobr> <wbr></nobr>:-)</p>

<p>This may seem like nitpicking (okay - it is nitpicking<nobr> <wbr></nobr>;-) but I think it's a distinction that you have to be careful about. One of the problems I've come across when introducing people to agile practises are people saying "Foo doesn't work - we tried it" when they actually mean "We tried to do Foo and couldn't make it work".</p>

<p>There's a difference between:</p>
<ul>
<li>Cycling doesn't work.</li>
<li>I cannot ride a bike</li>
<li>I tried to ride a bike once and fell off</li>
</ul>

<p>Somebody falling off a bike isn't an sign that cycling offers no benefits. </p>

<p>Not that I disagree that some people seem incapable of pairing programming because their personalities don't bend that way. In new teams I try my very best not to hire them. In old teams add a lot more code reviews or encourage them to do stuff that doesn't need pairing.</p>



<h2>What does the team think?</h2>
<h3><a href="/user/jplindstrom/">jplindstrom</a> on 2004-07-13T01:07:54</h3>
Isn't one of the things with agile methods the reflection, the ongoing analysis of what works and what doesn't?<br> <br>Obsiously the pairing doesn't work. What does the team think about that? Is it a problem or a symptom of another problem? Should you try to make the pairing work? Abandon it? Do something else?<br>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

