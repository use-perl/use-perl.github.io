<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of shiflett: What Is Scalability?</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>What Is Scalability?</h1>
<h2><a href="/user/shiflett/">shiflett</a> on 2003-10-19T23:15:57</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p>
There is an interesting article on <a href="http://www.onjava.com/">ONJava.com</a> entitled <a href="http://www.onjava.com/pub/a/onjava/2003/10/15/php_scalability.html">The PHP Scalability Myth</a>. The author describes scalability as follows:
</p>
<p>
<i>
There are a number of different aspects of scalability. It always starts with performance, which is what we will cover in
this article. But it also covers issues such as code maintainability, fault tolerance, and the availability of programming staff.
</i>
</p>
<p>
Is this what scalability means? It's certainly not my definition. Do code maintainability, fault tolerance, and the availability of programming staff have something to do with scalability? They can if your definition of scalability takes human resources into account, which seems reasonable.
</p>
<p>
The definition I find on <a href="http://www.dictionary.com/">Dictionary.com</a> describes scalability as:
</p>
<p>
<i>
How well a solution to some problem will work when the size of the problem increases.
</i>
</p>
<p>
This seems like a better definition. A textbook definition would be something to the effect of, "the ability to scale." This is probably a starting point that everyone can agree to. So why do some people argue that certain technologies (PHP, mod_perl, Java, etc.) don't scale? I have
always assumed that these people define scalability as the ability for something to scale well and that they're using their own subjective opinions to define what scales well and what doesn't. This is where things go wrong. It also seems that more and more people use scalability as a measure of performance, when this is not the case either. Something that performs very poorly can still potentially scale very well. Scalability is a relative measurement.
</p>
<p>
Before I say more, I should describe what I think it means for something to scale well. Consider the following three figures:
</p>
<p>
http://shiflett.org/images/scalability_1.png<br />
http://shiflett.org/images/scalability_2.png<br />
http://shiflett.org/images/scalability_3.png<br />
</p>
<p>
The first figure represents a case where the amount of required resources grows exponentially compared to the number of users. This is bad. In the second figure, the amount of required resources grows linearly. This is typical (the rate of growth can vary). In the third figure, the amount of required resources grows logarithmically. This is very nice. Of these three figures, my opinion is that both the second and third represent something that scales well. Because I am a Web developer, a growing number of users is typically when the "size of the problem increases" for me. The term "resources" refers to many things, but most people are concerned with cost. Things that cost money include hardware, software, human resources, and time.
</p>

<p>
Lastly, let's look at an example. Consider two hypothetical technologies, Technology A and Technology B:
</p>
<p>
Resources required to build an application that supports 100,000 users a day:<br />
Technology A: 10 servers, 5 developers, and 6 months of development time<br />
Technology B: 40 servers, 10 developers, and 3 months of development time
</p>
<p>
Resources required to build an application that supports 250,000 users a day:<br />
Technology A: 25 servers, 5 developers, and 9 months of development time<br />
Technology B: 50 servers, 10 developers, and 6 months of development
</p>

<p>
Which technology do you think scales better? Which appears to be the better choice when no more than 250,000 users a day need to be supported? Should things like maintainability and robustness be taken into consideration? How do you measure these things? If you are making decisions based on your assumptions about the scalability of certain technologies without asking these types of questions, you need to stop making such decisions.
</p></p>


<hr/>



<h2>scalability</h2>
<h3><a href="/user/gav/">gav</a> on 2003-10-20T00:48:42</h3>
<p>I'm sure my feelings about PHP are the same as a lot of PHP programmer's about Perl, you can probably build a decent web app in PHP but 95% of what I've seen is crap.</p>
<p>To build something scalable you need both people that know what their doing and a toolset that doesn't hinder them. The first part of the equation is the most important one.</p>
<p>For example, earlier this year I "fixed" a Java web app by re-writing it in Perl. It ran on 3 dedicated servers - 2 app servers and a DB server. It took a whole bunch of DB queries to render each page, so I wrote something that output static pages (the data changes perhaps once or twice a month). Now it runs on a single shared webserver. This doesn't mean that Perl is more scalable than Java, just that if you don't design a scalable solution from the start you'll have to throw a lot of money at the problem.</p>



<blockquote>

<h2>Re:scalability</h2>
<h3><a href="/user/shiflett/">shiflett</a> on 2003-10-20T02:43:49</h3>
<p>Actually, I don't think the general opinion of Perl in the PHP community is as poor as the general opinion of PHP in the Perl community. Some of this is warranted, but of course, much of it is not. In general, the Perl community is more advanced as well as more mature (I'm talking about the age of the community, not personality). This, by itself, leads to better code. Yes, there is a lot of bad PHP code, probably a higher proportion than bad Perl code. However, the top PHP developers can solve the same problems as the top Perl developers, and the relative elegance of the solution is at least debatable. Also, with apache_hooks, PHP is able to do things that only mod_perl could do before. PHP doesn't suck as much as you might think.<nobr> <wbr></nobr>:-)</p>
<p>
As far as scalability is concerned, I think my point is that it is only a measurement of one thing. And while that thing is vague (the relation between resources and the size of the problem), it is not more than that. The best solution isn't necessarily the one that scales the best, even when dealing with hypothetical situations where the scalability can be compared.
</p>





</blockquote>


<h2>People Count!</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2003-10-20T01:14:48</h3>
<blockquote><div> <em>Things that cost money include hardware, software, human resources, and time.</em> </div></blockquote>

<blockquote><div> <em>Should things like maintainability and robustness be taken into consideration?</em> </div></blockquote>

<p>Yes.  Smart people have been saying this for years.  I develop better software faster in Perl than I do in Java.  (Of course, I develop better software faster in Java than I do in C.)</p>

<p>Relative productivity of a language is important.  I think Jack wasn't quite ready to say that, but it's important to realize that ops-per-second isn't the be-all end-all of scalability and value.</p>



<blockquote>

<h2>Re:People Count!</h2>
<h3><a href="/user/shiflett/">shiflett</a> on 2003-10-20T02:50:11</h3>
<blockquote><div><i>
Yes. Smart people have been saying this for years. I develop better software faster in Perl than I do in Java. (Of course, I develop better software faster in Java than I do in C.)</i>
</div></blockquote>


<p>
But when people attempt to compare the scalability of programming languages (which isn't a practice I am advocating), shouldn't they try to take an "all else being equal" perspective? I know that I should consider the skillset of my current (or at least potential) employees when choosing a solution, but if my goal is only to measure the scalability (whatever that is) of something, should I take such things into consideration?
</p>



<blockquote>

<h2>Re:People Count!</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2003-10-20T03:06:06</h3>
<p>I don't see what value there'd be in such a comparison.  I certainly don't work in an ideal world.  The handwavy things that don't matter in purely academic comparisons have a way of actually mattering a great deal in practice.</p>



<blockquote>

<h2>Re:People Count!</h2>
<h3><a href="/user/shiflett/">shiflett</a> on 2003-10-20T03:22:46</h3>
<blockquote><div><i>
I don't see what value there'd be in such a comparison.</i>
</div></blockquote>


<p>
I said I wasn't advocating it.<nobr> <wbr></nobr>:-)
</p>
<blockquote><div><i>
I certainly don't work in an ideal world. The handwavy things that don't matter in purely academic comparisons have a way of actually mattering a great deal in practice.</i>
</div></blockquote>


<p>
I agree completely, which I guess was part of my point. I generally dislike scalability being used as this paramount characteristic that determines whether a particular technology is "worthy."
</p>
<p>Because the true meaning of scalability doesn't justify this practice, it seems like more and more people choose to warp the definition so that it does.</p>
<p>Imagine a manager asking, "Does foo scale?" What is the right answer? To me, this is no different than someone asking, "Do you have a temperature?" Well, of course I do.
</p>





</blockquote>

</blockquote>

</blockquote>


<h2>linear is the best you're going to do</h2>
<h3><a href="/user/mary.poppins/">mary.poppins</a> on 2003-10-31T11:00:28</h3>
I don't see how you're ever going to better than linear, given that you have to do *something* for each user of your system, even if it's as simple as serving up a static page.<br>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

