<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of pshangov: Data::AsObject Released - Data Structures Made Easy</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Data::AsObject Released - Data Structures Made Easy</h1>
<h2><a href="/user/pshangov/">pshangov</a> on 2009-08-11T14:36:25</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><i>Cross-posted from <a href="http://mechanicalrevolution.com">http://mechanicalrevolution.com</a>.</i>

<p>Perl is notorious for its punctuation-ridden syntax, and if there is one place where this is manifested most obviously, it is when working with data structures. While I myself can see the beauty behind the line noise and have nothing against the syntax <em>per se</em>, it sometimes feels there are just too many characters to type. In particular, I have recently had to do a lot of work with XML data represented by perl hashes, via <a href="http://search.cpan.org/dist/XML-TreePP/">XML::TreePP</a> and <a href="http://search.cpan.org/dist/XML-Compile/">XML::Compile</a>. Working with the data structures generated by these modules can quickly become pretty painful.</p>

<p>Enter <a href="http://search.cpan.org/dist/Data-AsObject/">Data::AsObject</a>. It allows you to work with hash and array references as if they were objects. For example, I often have to process <a href="http://en.wikipedia.org/wiki/XLIFF">XLIFF</a> files, which are used in the translation industry. Using XML::Compile, I can get my XLIFF files serialized into a hash and use it as follows (you don't need to know the details of the XLIFF format to see the point of the example):</p>

<pre>
$xliff holds the serialized xml
# get the source language of the first file
my $source_lang = $xliff->{'seq_any'}->[0]->{'file'}->{'source-language'};

# get all the translation units in the first file
my @trans_units = @{ $xliff->{'seq_any'}->[0]->{'file'}->{'body'}->{'cho_group'}->[0]->{'trans-unit'} };

# for each translation unit, add an alternative translation with a source and a target
foreach my $tu (@trans_units) { 
    my @matches = get_matches($source->textContent);

    my $id = 0;
    foreach my $match (@matches) {
        $tu->{'cho_context-group'}->[$id]->{'alt-trans'}->{'source'}->{'_'} = $match->source;
        $tu->{'cho_context-group'}->[$id]->{'alt-trans'}->{'target'}->{'_'} = $match->target;
        $id++;
    }
}
</pre>

<p>The same example with Data::AsObject (for this to work, hooks need to be added to XML::Compile to automatically convert Ã¢â¬Åsource-languageÃ¢â¬Â, Ã¢â¬Åtrans-unitÃ¢â¬Â and other elements with dashes to Ã¢â¬Åsource_languageÃ¢â¬Â, Ã¢â¬Åtrans_unitÃ¢â¬Â etc.): </p>

<pre>
# Data::AsObject::dao converts a hashref or an arrayref to a 
# Data::AsObject::Hash or a Data::AsObject::Array object
dao $xliff;

my $source_lang = $xliff->seq_any(0)->file->source_language;
my @trans_units = $xliff->seq_any(0)->file->body->cho_group(0)->trans_unit;

foreach my $tu (@trans_units) { 
    my @matches = get_matches($source->textContent);

    my $id = 0;     
    foreach my $match (@matches) {
        $tu->cho_context_group($id)->alt_trans->source->{'_'} = $match->source;
        $tu->cho_context_group($id)->alt_trans->target->{'_'} = $match->target;
        $id++;
    }
}


</pre>

<p>This an almost real life example and you can easily see what benefits in terms of readability Data::AsObject provides. Of course there are many caveats, the primary one being that you need to be able to control your input and guarantee that hash keys will only contain alphanumeric characters and underscores. Go check out <a href="http://search.cpan.org/perldoc?Data::AsObject">the docs</a> for more usage details.</p></p>


<hr/>



<h2>Now THAT kicks ass</h2>
<h3><a href="/user/xsawyerx/">xsawyerx</a> on 2009-08-12T08:20:34</h3>
Very interesting. I like it!



<h2>I prefer XPath</h2>
<h3><a href="/user/grantm/">grantm</a> on 2009-08-13T01:17:11</h3>
For that type of problem, I find that using XML::LibXML and XPath leads to code with even less syntax.



<blockquote>

<h2>Re:I prefer XPath</h2>
<h3><a href="/user/pshangov/">pshangov</a> on 2009-08-20T12:01:18</h3>
Sometimes, however, XML::LibXML is not an option. In the example above, I use XML::Compile (which BTW uses XML::LibXML internally), which is currently the best option if you want to work with schema-compliant XML documents (especially if you want to create and modify ones). The other such module I often use is XML::TreePP, which is a pure-perl solution and is available in environments where XML::LibXML isn't.





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

