<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of Matts: Perl 6 for Damians</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Perl 6 for Damians</h1>
<h2><a href="/user/Matts/">Matts</a> on 2001-10-25T09:04:00</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>Well, I've voiced my opinion on IRC, and I thought it was time to make it stand up on its own. So I wrote a <a href="http://217.158.50.178/docs/just_for_damians.html">rebuff</a> to Pier's article. The rebuff isn't meant to be against Piers by any stretch, but against where I see Perl 6 going.<br/><br/>Note that the URL above won't be the final resting place, so don't link to it. The article is also in flux, as I'm accomodating feedback from people. So please use the comments facility here to respond.</p>


<hr/>



<h2>Rebuttal</h2>
<h3><a href="/user/wickline/">wickline</a> on 2001-10-25T13:12:56</h3>
disclaimer: I like where perl6 is going, but I certainly respect your dislike of that direction. These comments are intended only to help you clarify your opinion, not to de-value your opinion.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; a number of changes are being made for the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; sake of change. Things that we use a _lot_
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; in Perl 5, like '.' for concatenating, and
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; the dereference operator are going to change
<br>
<br>The fact that they are used a _lot_, and that they are changing, does not mean that they are being changed for the sake of change. One could argue that the '.' is being given new meaning because it is so easy to type that it should be used for something we use constantly. In Perl6, I think you'll find that most code will use the new '.' operator more than it uses the new (concatenation) '_' operator. See also Apocalypse 3 comments re: Huffman encoding
<br>
<br>http://www.google.com/search?q=cache:4Qf38IvSsGU:w ww.perl.com/pub/a/2001/10/02/apocalypse3.html+huff man&amp;hl=en
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; It's no good if we come up with a fantastic
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; syntax that's almost impossible to produce
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; a grammar for
<br>
<br>actually, many changes in perl6 are motivated by a desire to make perl6 much easier to parse. For example, ?? regexen won't fly, and a great deal of care was put into how to use the colon. Indirect object syntax flakiness from perl5 will go away.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; In all the Apoc's and Eg's I'm yet to see
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; a grammar, or part of a grammar, for Perl 6
<br>
<br>...but then you won't find one in the camel either. These Apoc's and Eg's are intended to follow the camel book, which didn't include a grammar either. Note that this was not an argument for you to not use perl5, so maybe it shouldn't be an argument for you to not use perl6. I suspect that as more and more Apoc's arrive, the Good Folks on the perl6 lists will begin writing the grammar you're looking for, in order to inform their parsers. Frankly, they're going to have a harder time writing the same for perl5 when they're working on that backwards compatability angle.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; If it's possible for the interpreter
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; backend to be able to do $^_ + $^_, then
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; it's possible for a module to do that too
<br>
<br>Sure. This is entirely a matter of opinion. One could also argue that map and grep should be implemented as modules. Everyone is going to draw their own line as to what they think is appropriate for the language and what should be shoved into modules. I think the hope here is that folks are going to find currying to be just as useful as $_ once they're familiar with it. Maybe you'll never once use it. I know I plan to.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; Perl 6 needlessly populates Perl with syntax
<br>
<br>Your opinion. For what it's worth, I'm looking forward to this syntax. I *like* the idea of being able to do all this spiffy stuff without having to wait for the Damians of the world to write a module for me.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; The intent of the second is only clear if
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; you know what ^/ means. It's not something
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; I've seen in any other language. So how
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; would I look up the documentation for this?
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; perldoc -f '^/' ?
<br>
<br>One could say the same about a great deal of perl5 if one's comming from a non-perl background. Just because you haven't seen it doesn't mean it's not good. Maybe I've never seen regular expressions or the ||= or =~ or !~ operators or the ternary ? : operator or references. That doesn't mean that they're bad. As for how you look up operators, I think you'd look up ^/ the same way you look up ||= in perl5. It's just an operator.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; I believe the former is less obscure.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; It is explicit in its operation
<br>
<br>This argument could also be used by a C programmer (or an assembly programmer) to justify their pages and pages of code over the one line regex full of line noise that a perl programmer would rather use. The regex is only more obscure if you don't understand it. However, that should not be a convincing argument against the utility of the regex. Similarly, lack of familiarity with new operators shouldn't be a convincing argument against becoming familiar with them. On the other hand, if you personally don't want to learn them, you don't have to. Plenty of perl5 hackers write mostly perl4 code. I'm sure many perl6 hackers will write mostly perl5 code.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; File test operators are NASTY. We would be
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; far better served by something like a stat
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; object. Then you just use a schwartzian
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; grep to do your tests
<br>
<br>I think I understood your points before this one, and I just disagreed. In this case, I don't think I understand. Are you claiming that your four lines ST code is less "NASTY" than
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; grep { -r -w -x -f $_ } @files
<br>
<br>I'm afraid I just don't understand why that is. If you're claiming that the stat method is more efficient, note that the perl6 syntax is not doing four checks against the filesystem. The underlying mechanism uses a stat-type object, so it is just as efficient. In the new syntax, you loose the wrap/unwrap map from the ST construction, and in my opinion the result is much less "NASTY" (not that ST is nasty at all, it's just not necessary in this case with the new perl6 syntax).
<br>
<br>I guess I think of it this way. You seem to be advocating an ST where the new syntax would "just do it". I don't understand why. The argument seems to me like saying "grep is just NASTY... we'd be better off using this nice for loop instead".
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; Module
<br>
<br>You wrote the above re: Binary ';'
<br>
<br>Again, a matter of preference. Would you also like to see perl5 slice syntax moved into a module? Personally, I love slices. I'm sure I'm going to love convenient multi-dimensional slices.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; Parsing is a solved problem. Tell me
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; again why it should be a core function?
<br>
<br>There's a bunch of stuff that's just a royal pain in the ass without core support. One can work around lack of support by implementing your new feature as a source filter and essentially completely re-writing a program to make it do what you want. However, perl6 is a good opportunity to do away with the need for that sort of kludge in some cases. Parsing is a very often tackled with perl, and increasing core support for parsing may be a big win, saving many module authors many many hours of headaches.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; the above can be achieved quite simply
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; using eval(), rather than closures
<br>
<br>The purpose of the Eg3 was to use perl6. So, doing it the perl6 way is appropriate even if it can be done other ways. If you're saying that eval() is better, I guess that's a matter of opinion. Personally, I cringe every time I have to use eval()... it just feels like a hack for something that should be easier in most cases (for example, error trapping in DBI).
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; Another thing that confuses me in the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; above us why is it using<nobr> <wbr></nobr>:= instead of
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; "sub assert_with_comparator {<nobr> <wbr></nobr>... }
<br>
<br>It's *calling* the assert_with_comparator function to construct an assertion subref. The result is then assigned with<nobr> <wbr></nobr>:= to the sub assert_foo (fill in whichever instance you're looking at).
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; And where is it supposed to get the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; function arguments from? Or is this
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; using magic special variables again?
<br>
<br>Yup. This may still be new and unfamiliar, but that doesn't mean it's bad. People learning perl say almost the same words whenever $_ comes into play (or @_). That doesn't mean that $_ is bad.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; Every OO language I've used has an
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; implicit concept of "this" in method
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; calls. Why are we trying to be different?
<br>
<br>Perl6 also has the same concept. It's not different in that way. However, the concept isn't invoked with
<br>
&nbsp; &nbsp; &nbsp; &nbsp; this.method()
<br>but rather with
<br>
&nbsp; &nbsp; &nbsp; &nbsp;<nobr> <wbr></nobr>.method()
<br>Which is different, but in a keystroke-saving sense, much like $_ is different from most languages, and the fact that you don't type *anything* at all to mean $_ in some cases is even more different.
<br>
&nbsp; &nbsp; &nbsp; &nbsp; print;
<br>That print statement is *very* convenient. Similarly,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; sub method { $.attribute =<nobr> <wbr></nobr>.other_method(); }
<br>is much more convenient than
<br>
&nbsp; &nbsp; &nbsp; &nbsp; sub method {
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my $self = shift;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $self.attribute = $self.other_method();
<br>
&nbsp; &nbsp; &nbsp; &nbsp; }
<br>
<br>moving on...
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; OO baby, OO
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt;
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; geq ($expected, $got)
<br>
<br>Ah, but your example doesn't have the precidence of the perl operator eq, and it doesn't have the associativity of an operator. I think you missed the point here. While Damian's example was small and could be trivially replaced by a function, the point is that you could do so much more just as easily. With perl6 you can overload operators much much easier (and more of them). This means that your arbitrary objects can now be compared with normal operators with only a few lines of code and no extra module overhead. And if you want a new operator, creating it takes only a few lines of code... and it *works* like an operator instead of a function. Maybe you want to do matrix math and have cross products and dot products with real operator-type syntax instead of a function call. You wouldn't want to write (for addition)
<br>
&nbsp; &nbsp; &nbsp; &nbsp; $result = plus( $this, $that );
<br>so why would you want to write
<br>
&nbsp; &nbsp; &nbsp; &nbsp; $result = dot_product( $this, $that );
<br>With perl6 you don't have to...  and you can create your own operator for dot_product instead of having to overload an existing one if you want.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; So now we just have to fix perl to do the
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; right thing as above.
<br>
<br>I don't think I understood your complaint against the proposed trait handling, so I also don't understand why your suggestion is an improvment. Perhaps more details would help?
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; I despise the indirect object syntax,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; so I despise the binary :
<br>
<br>Perhaps you should avoid using it then.<nobr> <wbr></nobr>:)  I despise eval(), and use it only when I have to. That doesn't mean it should leave the language. It sounds like you use it more than me, and so it's useful, just not for me.
<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; there's no reason to change the basic
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &gt; syntax in such fundamental ways.
<br>
<br>I disagree. There's plenty of reason. Maybe the new features aren't very compelling for you, but they sure are for me (and I'm much less of a Damian than Piers, and in fact am nothing at all of a Damian).
<br>
<br>Off to Mexico for a week now<nobr> <wbr></nobr>:)
<br>
<br>-matt
<br>



<blockquote>

<h2>Re:Rebuttal</h2>
<h3><a href="/user/Matts/">Matts</a> on 2001-10-25T13:35:54</h3>
<tt>OK, one thing that people have seemed to completely miss in my discussion of this is my fundamental objection: Perl 6 won't parse Perl 5.
<br>
<br>I accept a lot of your points and take them on board. My point about the file test operators wasn't that I dislike the new syntax - I think it's *much* better than doing tests on the magic underscore. I just dislike the file test operators altogether<nobr> <wbr></nobr>:-)
<br>
<br>You ask if I'd like to see slice and grep moved into a module. Well no, I wouldn't, because they are functions that operate on Perl's fundamental data types. But I *would* like to see things like the networking functions moved into modules.
<br>
<br>And you're right, I don't like the idea of using eval() either. It's a hack. I was being overly picky about that. However I didn't find the closure syntax confusing at all. Maybe it's just me<nobr> <wbr></nobr>:-)
<br>
<br>I do think you missed the point about the<nobr> <wbr></nobr>:= being used. Let's look at the code:
<br>
<br>&amp;assert_with_comparator<nobr> <wbr></nobr>:= {
<br>&nbsp; &nbsp; &nbsp; &nbsp; unless ($^comparator.($^a, $^b)) {
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw Exception::FailedComparison :
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; comparator =&gt; $^comparator,
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result&nbsp; &nbsp; &nbsp;=&gt; $^a,
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target&nbsp; &nbsp; &nbsp;=&gt; $^b
<br>&nbsp; &nbsp; &nbsp; &nbsp; }
<br>&nbsp; &nbsp; }
<br>
<br>That's the code I meant, not the assignment code below that. Here we see a block being assigned to the function "assert_with_comparator". So why not use sub assert_with_comparator? Is it just for obfuscation? Secondly, where does the code block get its parameters from? There's no parameters declaration section, so the params appear to be magical. I mean, I know there's no interpreter yet, and so Piers maybe just made a boob on the above, so I'd like to know.
<br> </tt>



<blockquote>

<h2>Re:Rebuttal</h2>
<h3><a href="/user/pdcawley/">pdcawley</a> on 2001-10-27T14:54:39</h3>
<tt>Ah... I think I understand what you mean now. The reason that I can't just do
<br>
<br>&nbsp; &nbsp; &nbsp;sub assert_with_comparator {
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...
<br>&nbsp; &nbsp; &nbsp;}
<br>
<br>Is because I need the automatic currying behaviour, which comes from $^comparator, $^a &amp; $^b ($^foo introduces a named currying parameter, in the same way as $^_)
<br>
<br>Maybe
<br>
<br>&nbsp; &nbsp; sub (&amp;comparator, $a, $b) is curried {
<br>&nbsp; &nbsp; &nbsp; &nbsp;<nobr> <wbr></nobr>...
<br>&nbsp; &nbsp; }
<br>
<br>will become a valid way of declaring a curried subroutine, but that hasn't been stated yet, so I used the notation that I *know* will work.</tt>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

