<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of Alias: I do appreciate the effort...</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>I do appreciate the effort...</h1>
<h2><a href="/user/Alias/">Alias</a> on 2009-01-26T23:30:23</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>But we've had Perl Enterprise Edition, and Best Practise Perl, and now Enlightened Perl, and Modern Perl...<br/><br/>A wise man (who I'll credit because I'm too lazy to do the research) once said that the definition of "Best Practice" is generally "My Practice".<br/><br/>I like the idea of a definition for some kind of better thing, but what prevents the idea becoming a temporary fad. What gives this one sticking power.</p>


<hr/>



<h2>Sticking Power</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2009-01-26T23:44:25</h3>
<p>I think many well-versed Perl hackers can agree that using lexical filehandles is better than passing around raw typeglobs, and that <code>given</code>/<code>when</code> is better than long chains of <code>if</code>/<code>else</code> statements.  I'm pretty sure that most of us can agree that a novice Perl programmer should look to the CPAN to solve common problems.</p><p>I'm sure that the definition of "modern" will change over the coming years, but I'm also sure that just as we can look at a piece of code which uses global variables (with perhaps a <code>local</code> or two thrown in for good measure) and leading ampersands to call functions as old, we can look at a piece of code and say "Your personal style may be different from mine, but you've written in a modern Perl style."</p>



<blockquote>

<h2>Re:Sticking Power</h2>
<h3><a href="/user/dagolden/">dagolden</a> on 2009-01-27T03:45:47</h3>
<p>I like the idea of a sort of <a href="http://en.wikipedia.org/wiki/Strunk_%26_White" title="wikipedia.org">"Strunk and White"</a wikipedia.org> for Perl.</p><p>The way I see this project as different in intent from PBP is that it can be less dogmatic about what is "best" (highly contextual and often idiosyncratic) and yet dogmatic enough about what is "good" (generally accepted) to be a reference for minimum standards or expectations.</p><p>-- dagolden</p>



<blockquote>

<h2>Re:Sticking Power</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2009-01-27T04:26:48</h3>
<p>That's a nice metaphor.  Do you mind if I borrow it?</p>



<blockquote>

<h2>Re:Sticking Power</h2>
<h3><a href="/user/dagolden/">dagolden</a> on 2009-01-27T04:32:28</h3>
<p>Please do.</p>



<h2>Re:Sticking Power</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2009-01-27T05:01:49</h3>
<p>Only if you want all the linguists in the room to huff and <a href="http://languagelog.ldc.upenn.edu/nll/?p=4" title="upenn.edu">go on a rant</a upenn.edu> about the <a href="http://languagelog.ldc.upenn.edu/nll/?p=1022" title="upenn.edu">&#8220;shallow grammar-bossiness and vapid style-mongering&#8221;</a upenn.edu> of <i>Elements</i>, which therefore seems to be analogous more to PBP than to this Modern Perl endeavour. (I would not want to offend Damian so badly as to say it is directly analogous.)</p>



<blockquote>

<h2>Re:Sticking Power</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2009-01-27T07:04:36</h3>
<p>If you thought arguments about programming languages were shallow and meaningless, you don't know any academics!</p><p>With all due respect to everyone who hates prescriptivism, I'll put on my professional editor hat and say that a gentle dose of Strunk and White could improve the majority of writers with whom I've worked (and anyone who turns into a petty linguistic dictator after reading Orwell was already a petty dictator).</p>



<blockquote>

<h2>Re:Sticking Power</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2009-01-27T15:05:40</h3>
<p>It&#8217;s not like they merely trash <i>Elements</i> without ever <a href="http://languagelog.ldc.upenn.edu/nll/?p=661" title="upenn.edu">suggesting a better alternative</a upenn.edu>.</p>





</blockquote>

</blockquote>

</blockquote>


<h2>Re:Sticking Power</h2>
<h3><a href="/user/drhyde/">drhyde</a> on 2009-01-27T12:35:06</h3>
Expect furious arguments from those who prefer <a href="http://wikiproxy.cantrell.org.uk/Fowler's_Modern_English_Usage" title="cantrell.org.uk">Fowler's</a cantrell.org.uk> Modern Perl Usage<nobr> <wbr></nobr>:-)



<blockquote>

<h2>Re:Sticking Power</h2>
<h3><a href="/user/dagolden/">dagolden</a> on 2009-01-27T12:50:39</h3>
<p>As I'm not British, I'll stick with the <a href="http://www.amazon.com/Columbia-Guide-Standard-American-English/dp/0231069898/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1233060430&amp;sr=8-1" title="amazon.com">The Columbia Guide to Standard American English</a amazon.com>, thank you.<nobr> <wbr></nobr>:-)</p><p>N.B. It's great fun using it to rebut language pedants at work.</p>





</blockquote>

</blockquote>

</blockquote>


<h2>And the alternative is ...</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2009-01-26T23:46:51</h3>
<p>We see lots of creative people pouring heart and soul into Perl.  The alternative might be lots of creative people ignoring Perl.  I certainly know which I prefer.</p><p>The fact that so many people are working on these issues makes me happy.</p>



<h2>Nothing, that's what makes it dangerous.</h2>
<h3><a href="/user/jshirley/">jshirley</a> on 2009-01-27T02:07:38</h3>
<p>There is nothing that the EPO is doing that couldn't be done by others, but it can be said that the difference between a successful entrepreneur and a failure is simply doing it.
</p><p>
If the EPO fails and collects dust, some will say that it is a failure.  I'll view it as a learning experience about what to fix the next time something comes around.
</p><p>
Also, my focus on EPO is to help Perl's external facing image.  The EPO Extended Core is good for the various Best Practice&#226;&#8222;&#162; stuff, but the marketing is where I'm hopeful.
</p><p>
Perl's a great language, but with a horribly dense echo chamber that few people want to enter.  Enlightened Perl's success will come easier with the Perl Community (or rather, a part of the Perl community; I don't think it is possible to have the whole thing<nobr> <wbr></nobr>;)).  However, marketing to the outside world doesn't really require support from the community, outside of the community not actively trying to hurt the effort.</p><p>
If I can get people who have never used Perl to evaluate something, I'll view my time as a success.
</p><p>
Even if it is just a temporary fad... who knows, it may only last until <em>Christmas</em>.
</p>



<h2>The issues are...</h2>
<h3><a href="/user/jrockway/">jrockway</a> on 2009-01-27T14:42:51</h3>
<p>So how are Modern Perl and Enlightened Perl different from the other similar initiatives?</p><p>PBP was the first real step in the direction of "modernizing" Perl.  It was a book that showed people that Perl isn't a toy, and isn't a "write-only" language.  (Unfortunately some of the advice in the book was just wrong, like using Class::Std.  What?)</p><p>(I have never heard of Perl Enterprise Edition, and I am no marketing expert, but somehow I don't think "pee" is the way to make Perl popular again.  Although it would pair nicely with Perl OO Persistence, "poop".  LOL.)</p><p>Anyway, the problem with PBP was that best practices didn't really exist when the book was written.  Not many people were thinking about it.  Damian tried to use his own modules to fill in the gaps, but they were simply not production-tested yet.  That makes them fun toys, not best practices.  Get a few people to use them, *then* write a book about it!  (This is easy to slip into -- as I plan my next book, I have to make a conscious effort to resist the urge to tell everyone to use my super-cool experimental modules that only I use.  They're super-cool... to me, but they are certainly not "best practices".)</p><p>Anyway, now were are here today.  Real "best practices" are emerging.  Use Moose for OO.  Use Catalyst for web development.  Use DBIx::Class to talk to your database.  Use DateTime for dates.  These are solid modules that are used by tens of thousands of critical applications.  You can use them as "buzzwords" on your resume, and end up with a job doing something with Perl that you actually like.  And, these modules are really good pieces of software.  It is time that they are marked to the wider world, because they are not only the best of Perl, they are the best among *all* the languages.</p><p>Enlightened Perl is a marketing push to make sure that people realize that there are good parts of Perl, and that they start with those (instead of opening up the Perl Cookbook from 1998 and using what was the state of the art 10 YEARS AGO).  Enlightened Perl has the advantage that most of its members are the people and companies creating this new technology.  A lot of the cool stuff in Perl comes out of II, BPS, Shadowcat, etc., and those are the companies involved with EPO right now.  So in addition to "this is good for Perl", there is some of the "come play with my cool stuff" that keeps us hackers (as opposed to marketers or managers) interested.  I think it will be a good thing.</p><p>(I can't say much about Modern Perl other than it's a good name and that I think chromatic is going to do a good job with it.  The key is that he actually writes real Perl applications from time to time, which will make for a good book.  Theory, practice, and all that.  When was the last time Damian submitted code implementing new perl features to p5p?)</p><p>Anyway, PBP was a great first step, and really helped the Perl community.  Now it's time to take the second and third steps, and Modern Perl and Enlightened Perl are here to do that.</p>



<blockquote>

<h2>Perl Cookbook</h2>
<h3><a href="/user/vek/">vek</a> on 2009-01-27T17:44:20</h3>
<p>To be fair, the 2nd Edition of the Perl Cookbook came out in 2003, but I get the point you were trying to make.</p>



<h2>Re:The issues are...</h2>
<h3><a href="/user/moritz/">moritz</a> on 2009-01-27T18:13:37</h3>
<p>Why does it have to be different than previous efforts? I'd say that PBP was a success, and whoever writes a book now can try to both tie to its success, and learn from its failures.</p><p>I'd say that a newly revised PBP with a more technical focus could also be a success.</p>



<blockquote>

<h2>Re:The issues are...</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2009-01-27T18:39:35</h3>
<blockquote><div><p> <em>Why does it have to be different than previous efforts?</em></p></div> </blockquote><p>I don't want to define best practices.  I want to explain how Perl works and how to write good Perl code in 2009 taking advantage of the best features of the language and our ecosystem as it stands right now.</p>



<blockquote>

<h2>Re:The issues are...</h2>
<h3><a href="/user/jplindstrom/">jplindstrom</a> on 2009-01-28T00:39:27</h3>
<p>What makes that different from what's called "best practice"?</p>



<blockquote>

<h2>Re:The issues are...</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2009-01-28T00:50:26</h3>
<p>In general?  I suppose little.</p><p>PBP attempted to define some best practices where consensus is murky.  That's fine.  My goal with <em>Modern Perl</em> is just to teach people how to think to write good Perl, not to create coding standards.</p>





</blockquote>

</blockquote>

</blockquote>


<h2>PBP is great, but it's sad it is needed</h2>
<h3><a href="/user/Ed Avis/">Ed Avis</a> on 2009-01-28T01:15:51</h3>
PBP is an excellent book but it is the most eloquent argument against Perl (and by implication, in favour of Python / Ruby / whatever) that I have read.  Pretty much the whole book is a collection of gotchas and workarounds for crufty areas of the language that should have been cleared up years ago.  The semantics of 'local $x;' are unclear and can trip up many programmers?  OK, here is a sticking plaster.  Shouldn't it simply be fixed in the language, with a sensible deprecation timetable and warnings as Python does?  Unfortunately that seems to be impossible.  Ditto two-arg open or $[ or hundreds of other fossilized linguistic warts which were surely useful in perl 4.036 but mostly serve to obfuscate or create subtle bugs today.
<p>
Moose is a great piece of work.  But Perl 5 today (and its biggest asset, the CPAN) uses a mishmash of different object systems.  In the same timespan Python has successfully moved from one object system to another (so-called "new-style" classes) by first adding the better variant, then marking the old one as deprecated, then adding warnings, and finally (in 3.0) dropping support for the old model.
</p><p>
We end up with a state of affairs where the language to use is not perl, but 'perl that passes perlcritic', where perlcritic is doing the duty of many things that really ought to be fixed in the language proper.
</p><p>
(I think a marketing push in favour of the best CPAN modules is a great idea BTW.)</p>



<blockquote>

<h2>Re:PBP is great, but it's sad it is needed</h2>
<h3><a href="/user/zby/">zby</a> on 2009-01-28T13:01:48</h3>
Perl was designed to have lots of non-orthogonal features - Larry did not want to decide what is useful for us but instead let us try them out and see what works for us.  So we had this big number of features and this was good - this was part of the evolutionary design:<blockquote><div><p>"I am told that when they built the University of California at Irvine, they did not put in any sidewalks the first year. Next year they came back and looked at where all the cow trails were in the grass and put the sidewalks there. Perl is designed the same way. It's not just a random collection of features. It's a bunch of features that look like a decent way to get from here to there. If you look at the diagram of an airline, it's a network. Perl is a network of features... It's more like glue than it is like Legos."</p></div>
</blockquote><p> - <em> <a href="http://www.techgnosis.com/wall1.html" title="techgnosis.com">An interview with Larry Wall (1999)</a techgnosis.com>.</em>
But then people got tangled into the political disucssions about deciding what to depreciate - about deciding where really are the trails in the grass.</p>



<blockquote>

<h2>Re:PBP is great, but it's sad it is needed</h2>
<h3><a href="/user/Ed Avis/">Ed Avis</a> on 2009-01-28T15:32:20</h3>
Non-orthogonal features are great.  I don't agree with PBP's advice to avoid 'unless', for example.  There is a difference between that and things which are just plain useless; or worse than useless - appearing to work most of the time but introducing subtle bugs, for example glob()'s behaviour with spaces in filenames.





</blockquote>


<h2>Re:PBP is great, but it's sad it is needed</h2>
<h3><a href="/user/jrockway/">jrockway</a> on 2009-01-28T19:29:03</h3>
<blockquote><div><p>Pretty much the whole book is a collection of gotchas and workarounds for crufty areas of the language that should have been cleared up years ago.</p></div>
</blockquote><p>
If you think there is any programming language that is not like this, you have not used that language long enough.</p><blockquote><div><p>The semantics of 'local $x;' are unclear and can trip up many programmers</p></div></blockquote><p>Anything can "trip up" programmers that don't know how to program.  The semantics of local are quite clear.  (Dynamic binding versus my's lexical binding.  Not hard.)</p><blockquote><div><p>Shouldn't it simply be fixed in the language, with a sensible deprecation timetable and warnings as Python does? Unfortunately that seems to be impossible. Ditto two-arg open or $[ or hundreds of other fossilized linguistic warts which were surely useful in perl 4.036 but mostly serve to obfuscate or create subtle bugs today.</p></div></blockquote><p>
Sure, maybe.  But that's not going to happen.  So you can either document the problems (which are not problems once you are fluent in Perl), or you can switch to Python.  Not everyone has to use Perl, but it is such a good choice for most things that it's a shame to dismiss it based on some arbitrary "the language shouldn't have anything I don't want" criteria.</p>



<blockquote>

<h2>Re:PBP is great, but it's sad it is needed</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2009-01-28T20:43:35</h3>
<blockquote><div><p> <em>Not everyone has to use Perl, but it is such a good choice for most things that it's a shame to dismiss it based on some arbitrary "the language shouldn't have anything I don't want" criteria.</em></p></div> </blockquote><p>There's something deeply wrong with a software development process that enshrines deliberate obfuscations in the core test suite.</p><p>I don't accept the counter-argument "They test features not tested elsewhere", not in the least because I've added tests for features not otherwise tested (and my tests tend to be somewhat more maintainable).</p>



<blockquote>

<h2>Re:PBP is great, but it's sad it is needed</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2009-02-03T10:07:58</h3>
<p>I suspect that the deliberate obfuscation tests are necessary due to Perl's heuristic parsing.  With Perl 6, I doubt there would be as much of a need for them.</p>



<blockquote>

<h2>Re:PBP is great, but it's sad it is needed</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2009-02-03T18:59:20</h3>
<blockquote><div><p> <em>I suspect that the deliberate obfuscation tests are necessary due to Perl's heuristic parsing.</em></p></div> </blockquote><p>That's an excuse for not figuring out what the heuristics should be and writing maintainable tests for them.  Remember, these are tests intended to prevent the breakage of code which no one can prove actually exists.</p>





</blockquote>

</blockquote>


<h2>Re:PBP is great, but it's sad it is needed</h2>
<h3><a href="/user/Ed Avis/">Ed Avis</a> on 2009-01-28T22:08:30</h3>
<blockquote><div><p>The semantics of local are quite clear.</p></div></blockquote><p>Oh, having dynamically scoped variables is very useful and not difficult to understand.  I was referring to the semantics of 'local $x;' in particular.  What does that statement do?  Is it useful and clear, or is it a fairly useless behaviour and a gotcha for the unwary?  PBP makes a good argument for the latter.</p>



<h2>Re:PBP is great, but it's sad it is needed</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2009-01-29T01:04:05</h3>
<blockquote><div><p> <em>The semantics of local are quite clear.</em></p></div> </blockquote><p>They're murky when you add in Perl 5 magic.  (For everyone who doesn't follow p5p regularly, "magic" is a specific term of art you might recognize as that magic code which makes <code>tie</code> and overloading work.)</p>





</blockquote>

</blockquote>


<h2>Re:The issues are...</h2>
<h3><a href="/user/hex/">hex</a> on 2009-02-01T00:33:05</h3>
&gt; <i>Use DBIx::Class to talk to your database.</i>
<p>
Ugh. Endless tedious faffing with objects when plain old SQL (plus something snappy to use it with like DBIx::Simple) works perfectly well. If that's a "best practice", I guess I'm happy not being the best.</p>



<blockquote>

<h2>Re:The issues are...</h2>
<h3><a href="/user/autarch/">autarch</a> on 2009-02-01T05:54:23</h3>
<p>A lot of folks out there <em>are</em> looking for an ORM. If they're not, hopefully they already know about DBI and don't need help from EPO on that one<nobr> <wbr></nobr>;)</p><p>For those folks looking for an ORM, having some standard somewhere say "use this one" isn't a bad thing.</p><p>And note that I say this as the author of a competing ORM<nobr> <wbr></nobr>;)</p>



<h2>Re:The issues are...</h2>
<h3><a href="/user/zby/">zby</a> on 2009-02-05T09:51:13</h3>
ORMs give you nice abstraction that can be used to base other generic libraries - like generic html form handlers or records browsers or full CRUD frameworks.  Without it it you don't have the meta information about the rows and columns and you need to fiddle with all the SQL variants.



<h2>Re:The issues are...</h2>
<h3><a href="/user/jrockway/">jrockway</a> on 2009-05-14T21:25:44</h3>
Yeah, let's pretend that your minority opinion is relevant in some way.



<blockquote>

<h2>Re:The issues are...</h2>
<h3><a href="/user/hex/">hex</a> on 2009-05-15T12:24:05</h3>
Oh noes! Clearly you have the larger e-penis. I yield.





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

