<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of Alias: Why Perl 6 scares the hell out of me</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Why Perl 6 scares the hell out of me</h1>
<h2><a href="/user/Alias/">Alias</a> on 2008-01-29T05:40:27</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>(I wanted to title this journal entry "The relationship between a language and its toolchain, and why Perl 6 scares the hell out of me" but it didn't fit)<br/><br/>For the record, this is not an anti-Perl6 rant. It is a warning.<br/><br/>For language designers, one of the foundational concepts is how simple the grammar  is going to be. Being a human interface device, languages go beyond math (where there is generally a single truth) and engineering (where there's generally a limited set of widely known best practices) and can get into the realm of personal preference and fashion with few clear guides for the "best" way to do something.<br/><br/>The reason this dimension is so important is that the language imposes limitations on the types of tools it is possible to write. Some types of tools simply are not possible to write at all if the grammar has certain features.<br/><br/>I hypothesize that we can break down the human "language experience" for a general-purpose language as being a combination of the language syntax itself, the tools for it, and the size/quality of available libraries. These are by no means all the success factors, but are the ones that in my opinion make up the influence on the individual user.<br/><br/>(I explicitly ignore languages with features like "proof-carrying" that are essential for specific domains like cryptography and make it worth the pain of learning Haskell or proof-carrying Ada)<br/><br/>According to my hypothesis, the danger here then is to add excessive expressiveness to a language with the intention of it being pro-user, at the cost of fatally crippling your toolchain and hurting the user more than the benefits gained at the language level.<br/><br/>The second risk here is what I'll call the "Personal Language Anti-Pattern". I first heard examples of this from some old-school Lisp hackers. The typical way of describing it goes something like this...<br/><br/>"I can write something in 4 days in Lisp that takes most people 20 in some other language. I just spend 3 days modifying Lisp to solve that type of problem, then 1 day solving the problem".<br/><br/>The anti-pattern here is that you end up going way beyond TMTOWTDI. You don't get two, or three, or five ways to do it. You end up with a different language for every single person and every single project.<br/><br/>Forget about maintaining projects written in crufty Perl. Imagine maintaining code where every single project is written in its own mini-language (although they all look a bit lispish).<br/><br/>In Perl 5 we achieved this depressing state with source filters, but mostly managed to keep it under control with culture. "Source filters == bad" is our cultural norm.<br/><br/>The risk with Perl 6 here is that the ability to safely modify the language is going to be taken as permission to modify it early and often.<br/><br/>I'm not talking obvious positives like "use physics;" here, I'm talking My::Project::Lang here, in the same vein as the "God Object" anti-pattern... Where I don't want to end up is "BioPerl... the Language!", where DNA sequences are a known literal (because it starts with a capitalised GTCA).<br/><br/>my $sequence = GATTACA;<br/><br/>This seems like a seductive option, but the cost is you throw away most of your developer tools.<br/><br/>While I had originally thought that "easier to parse" was a part of Perl 6, this has apparently been removed or was never what I thought it was.<br/><br/>What Perl 6 actually is is easier to IMPLEMENT.<br/><br/>That is to say, we won't be in the worst possible situation of having a dynamic grammar that can't be reimplemented at all, because there is no grammar beyond "what the implementation does".<br/><br/>So we will have A grammar, but now it is a grammar that is EXPLICITLY changable.<br/><br/>So consider this step 1 to toolchain bliss.<br/><br/>It's still removes the possibility to implement most useful tools.<br/><br/>So, as I see it anyways, here is the rest of the steps.<br/><br/><b>Step 2 - Deterministic</b><br/><br/>The key to the really awesome tools is that you need to have a way to READ the code, without necessarily having to RUN the code.<br/><br/>BEGIN blocks (and everything similar) really screw this up for us.<br/><br/>If you need to execute code to read code, then you need to execute arbitrary code in order to read arbitrary code. And right there the phrase "execute arbitrary code" should be more than enough to explain the problem.<br/><br/>In one hit it creates the limitation that you can only every create tools that run your OWN code, you can never write tools that run anyone <b>else's</b> code.<br/><br/>As an example of how this can hit in unexpected ways, in Perl 5 if you have Komodo (or anything else that does background linting) installed it's quite easy to create a totally innocent-looking link on a webpage that will delete your home directory.<br/><br/>So compile time string-eval has to go (and BEGIN blocks or anything else that does it). It's also the death of having a "sub import" that can do anything you like.<br/><br/>In exchange, you get code you KNOW is going to be parsable, if the entire program is valid. None of this BEGIN { exit if rand > 0.5 } stuff.<br/><br/>Since it is so trivial to implement (one line of code in PIL), for the next parrot release there should be an experimental --xdeterministic flag you can pass to perl6 to forbid compile-time execution.<br/><br/>None of this makes interesting tools more POSSIBLE, it just makes it safe to open up a project from a third party without wondering if it is going to install a root kit or not. Which goes a long way to creating the incentives to write the tools at all.<br/><br/><b>Step 3 - Finalized Grammar</b><br/><br/>The other ugly problem is in the idea of having a compile-time-morphing grammar AT ALL, and completely blows away the possibility of having a "PPI6" that is sufficiently complete to handle all documents (and along with it kills perlcritic6 and sqlinjectiondetector6 and perltidy6 and other stuff).<br/><br/>If the syntax and semantics of your document is not stable DURING the document being parsed, how are you supposed to generate any form of semantic model (ala method-name completion or SOAP API auto-generation) or even a syntactic document model (ala PPI).<br/><br/>You can't describe anything, simply because you have no idea what you will need to describe in advance.<br/><br/>Perl 5 is horrible in this respect because the grammar contains an "operator/operand" state that flips back and forth every other character (which is the underlying cause of the "/" problem, and 6 other characters).<br/><br/>But at least it's only a boolean flag, and I could fudge my way around the problem by heuristically guessing well enough.<br/><br/>Once grammar modification is easy, any reasonable likelihood of fudging goes out the window because it can change in so many more ways.<br/><br/>You end up with a language which is expressive as hell, but where the most sophisticated editor you can create is vi (with no syntax highlighting allowed).<br/><br/>Assuming such a thing can be created, my bet for the "use strict;" for Perl 6 would be something like "use v6-static;" which would guarantee the file sticks to the official primary grammar for that document and allow you to safely use source code analysis tools on the file.<br/><br/>This could even be useful without determinism, as it would at least let you prove that the compile-time code wouldn't modify the grammar, and so you could still safely model the source code without having to risk compiling and running the BEGIN block.<br/><br/>It would also mean you solve the other big stepping stone for tools, the ability to do useful things with a document BEFORE it is a legally correct program.<br/><br/>This covers everything from parsing "use Win32;" on Unix to "use Not::Written::Yet". The ideal for a parser is a context-free (only needs one file) symantic parser you can safely fuzz-test without it exploding.<br/><br/>PPI is merely a syntactic parser you can safely fuzz-test.<br/><br/>And be under no illusions that it can be replicated in Perl 6. It was only BARELY possible to implement it for Perl 5 and even I wasn't sure I was going to find a good enough path through all the impossible problems until a few months before it was finished.<br/><br/>Now if we are indeed walking into this trap, there's certainly ways to avoid it.<br/><br/>Removing determinism would be useful (and easy to implement) but possibly impractical as it removes the ability to do platform-adaptive code that picks dependencies at compile-time. Goodbye File::Spec...<br/><br/>Finalizing the grammar by default somehow is far more interesting in my opinion. It enables all syntactic and some of the semantic tools, and will discourage flippant grammar modifications.<br/><br/>If you REALLY need to do something exotic, you should be willing to pay the price for it by doing something like "no determinism;" or "no tools;" so that it's clear to anything parsing your code that it should stay the hell away  unless it is either running the code, or willing to take the risk or exploding violently.<br/><br/>Or at least the tool is CONFIGURABLE to act safely, instead of being vulnerable to exploit by default. And before you mention Safe.pm, consider "BEGIN { while(1) {  $_++ } }" or see a great talk by an Australian University lecturer that teaches a Perl course called "Safe isn't" in which she explores all the ways her students violate her computer from inside Safe containers.
</p>


<hr/>



<h2>reusable toolchain?</h2>
<h3><a href="/user/nothingmuch/">nothingmuch</a> on 2008-01-29T07:08:34</h3>
You are working under the assumption that you won't be able to reuse the existing toolchain to write these tools.<br><br>The approach that everyone seem to be aiming for is that instead of writing PPI all over again for Perl 6, you are supposed to get decent enough support form the actual grammar that ships with the compiler in order to do your own interesting things with it.<br><br>Secondly, since Perl 6 supports separate compilation units in many ways this is actually much simpler than Perl 5 - there is no more possibility for action at a distance. If a unit is expected to compile independently of the other units then all the information on how to compile it must be in the files creating that unit. Granted, you are allowed to twiddle things in BEGIN { } by just running perl, but the sequencing of the operations is less adhoc. This has lots of merit in this particular field: in the absense of any BEGIN { } declarations or importing of macros/grammars from other compilation units (this is something you can statically check for if the unit is already compiled) then you can statically parse Perl 6 as defined in it's core syntax.<br><br>In other cases, if it's safety you're after, in not running the compile time code, then theoretically you just use something like perl 5's Safe on all the macros and grammar extensions.<br>



<blockquote>

<h2>Re:reusable toolchain?</h2>
<h3><a href="/user/rjbs/">rjbs</a> on 2008-01-29T15:37:27</h3>
<p><blockquote><div>in the absense of any BEGIN { } declarations or importing of macros/grammars from other compilation units (this is something you can statically check for if the unit is already compiled)</div></blockquote><br><br>I am probably being thick, but once they code is compiled, haven't you already run the BEGIN block and all its arbitrary contents?



<blockquote>

<h2>Re:reusable toolchain?</h2>
<h3><a href="/user/nothingmuch/">nothingmuch</a> on 2008-01-29T17:15:18</h3>
The begin block itself has to be fully parsed before it's run.<br><br>Similarly a macro or grammar extension coming from another compilation unit has already been compiled.<br><br>At this point you can examine their code in a manner much like Safe does (existing problems in safe are an implementation issue, not a conceptual one), and run the code with some resource limitation if necessary (if this wasn't possible then we wouldn't have javascript<nobr> <wbr></nobr>;-)<br><br>Furthermore, if you deduced by static analysis that these blocks cannot affect your code (Because, for instance, they never address the grammar classes, or they don't touch any symbol table, they never run string eval, etc) you can deduce that this code will not affect parsing in any way, and thus skip it entirely when you are only parsing (as opposed to compiling).<br><br>On an unrelated note, another benefit of this extensible toolchain approach is that if you *do* implement a DSL, then any tool can at least still parse it properly, and if the DSL is very simple or the tool is easily extensible you can get the tool to treat this code correctly too.<br><br>Imagine PPI being able to correctly parse Switch.pm's statements because Switch defines it's magic in terms of a real parser extension. It produces a new type of tree node that PPI using tools might not know how to handle, but they can at the very least safely ignore them. If the node does roles (like a 'ControlBlock' node for a Switch statement) then the tools might even be able to work with them anyway (like Perl::Tidy fixing parenthesis for Switch statements just like it would for if { }).



<blockquote>

<h2>Re:reusable toolchain?</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-29T22:13:49</h3>
&gt; At this point you can examine their code in a manner much like Safe does (existing problems in safe are an implementation issue, not a conceptual one), and run the code with some resource limitation if necessary (if this wasn't possible then we wouldn't have javascript<nobr> <wbr></nobr>;-)<br><br>You don't need to run Javascript in order to parse it, since it has (I think) a static syntax.<br><br>Also, this comes down to practicality.<br><br>"What percentage of CPAN can this parsing strategy handle?"<br><br>As a context-free document parser, PPI can handle as close to 100% as makes no difference.<br><br>Remember import methods are BEGIN-time code here too... so ANY "use Foo" kills you.<br><br>Anything where you don't have dependencies installed kills you.<br><br>Anything where you read config files at BEGIN-time kills you.<br><br>Everyone doing things like BEGIN { %foo = map { $_ =&gt; 1 } qw{<nobr> <wbr></nobr>... } } kills you.<br><br>If you were to work out what percentage of CPAN you could support under a "just use the native parser" approach, I think you'd find it is a small percentage indeed.<br>



<blockquote>

<h2>Re:reusable toolchain?</h2>
<h3><a href="/user/nothingmuch/">nothingmuch</a> on 2008-01-29T23:31:18</h3>
With respect to dependencies that will indeed fail to work, but for use Foo that's untrue - Perl 6's importing semantics will support real linkage of symbols for the benefit of compilation units. The method 'import' and glob assignments are not supposed to be the only way to actually import symbols anymore. This solves a lot of issues.<br><br>As for reading files etc in BEGIN - that's also handled differently - there is no guarantee that a BEGIN block will run every single time you run the program, it is fair game to save the output as constants in the compilation unit. Reading configuration files is supposed to happen at INIT/CHECK, and before you whip out the "no that's broken" argument, it's supposed to be fixed in perl 6.<br><br>Please do a little more research before you post all this FUD, people have thought of these "horrible problems" before.





</blockquote>

</blockquote>

</blockquote>


<h2>Re:reusable toolchain?</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-29T21:47:57</h3>
&gt; In other cases, if it's safety you're after, in not running the compile time code, then theoretically you just use something like perl 5's Safe on all the macros and grammar extensions.<br><br>Only if you can solve the Halting Problem.<br><br>In Perl 5, even trivial Perl examples involve BEGIN blocks (use strict) and grammar modification (operator/operand switching).<br><br>This problem applies to Perl 5 to.<br><br>Simon Cozens has a never-released parser based on the Perl internal parser.<br><br>It works just fine, as long as the code compiles, and doesn't load modules that are broken or don't exist, and can compile in a Safe container, and... and... and...<br><br>Practically speaking, you end up in a situation of death by a thousand cuts.<br><br>There are so many little scenarios that aren't allowed that in practice you can't parse a useful subset of files at all.<br>



<blockquote>

<h2>Re:reusable toolchain?</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2008-01-29T22:10:41</h3>
<p><blockquote> <div><em>Only if you can solve the Halting Problem.</em></div> </blockquote>

<p>No version of the Perl compiler or processor for any version of the language attempts to solve the Halting Problem.  They tend to do a pretty good job on most reasonably correct code (and plenty of unreasonably incorrect) code as well.  You don't need to solve the Halting Problem.  You only need to decide if it's worth it at any particular point to Halt and say "Sorry, I'm not going to continue processing from here," and you can do that if you control the runloop.</p>

<p>Now if it's possible to modify Perl 6's grammar lexically within Perl 6 programs by writing only Perl 6 code, then it follows that Perl 6 must be able to parse Perl 6 grammars and have a pretty good idea of what they do.  The rules are fairly declarative, after all.</p>

<p>I agree that it's likely possible for someone curious, malicious, or incompetent to write a grammar in such a way that you can't predict the effects of things (storing grammar rules in an <code>eval</code> run conditionally thanks to <code>rand</code> for example), but I'm not sure anyone thinks that <code>BEGIN { POSIX::_exit() if rand() &lt; 0.5 };</code> is a smart thing to put in Perl 5 code either.</p>



<blockquote>

<h2>Re:reusable toolchain?</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-30T01:38:44</h3>
This pretty much covers my point.<br><br>If the code does anything remotely interesting or unusual, you have to abort parsing the document. (worse, you may have to do it after already having spent significant CPU trying).<br><br>Limiting yourself to documents that compile significantly reduces the types of tools you can use.<br><br>I guess in a way this entire post is something of a challenge to prove that a useful non-executing parser can be written for Perl 6.<br><br>Maybe I should formalize it at some point.<br>



<blockquote>

<h2>Re:reusable toolchain?</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2008-01-30T01:53:06</h3>
<p><blockquote> <div><em>If the code does anything remotely interesting or unusual...</em></div> </blockquote>

<p>... <em>and</em> non-declarative, which I think you keep overlooking.  While I agree that there are ways to write grammar actions that change parsing in unfortunate ways, grammars themselves look more or less statically decidable in ways that regular expressions aren't.</p>

<p>I won't suggest that they're quite as static as an EBNF grammar is, but they're much, much closer than the Perl 5 parser.  It should be possible to identify arity and precedence without actually executing code, which clears up a couple of the thornier problems in parsing Perl 5.</p>



<blockquote>

<h2>Re:reusable toolchain?</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-30T02:52:41</h3>
Well, I'm assuming that "interesting an unusual" things will be non-declarative.<br><br>Anything declarative becomes "normal" for Perl 6.<br><br>Grammar changes have two overlapping issues.<br><br>There's the BEGIN problem.  Lets assume that isn't a problem because grammar changes are declarative and decidable.<br><br>The secondary problem for grammar changes is how to (and if you can) handle syntactic and semantic modelling for the resulting document in such a way as to allow for stuff like $document-&gt;find('comments');<br><br>





</blockquote>

</blockquote>

</blockquote>


<h2>Re:reusable toolchain?</h2>
<h3><a href="/user/nothingmuch/">nothingmuch</a> on 2008-01-29T23:20:43</h3>
The halting problem only applies to code you cannot introspect.<br><br>If you have a function, and that's all, then you can't find out what's in it.<br><br>But given a compiled optree, you have much more information.<br><br>If you parse the BEGIN { } block under the current rules, then you wind up with an optree which you can then examine, to see what it does.<br><br>As for simon's project - perl 5's parser was never designed to make this easy, it was designed to emit an interpreter optimized optree. This is very different from the design goals of perl 6's toolchain.



<blockquote>

<h2>Re:reusable toolchain?</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-30T00:40:31</h3>
We probably need to escalate this to a formally trained mathematician here, but as I understand it, it applies to any case with "arbitrary" code whether introspectable or not.<br><br>You CAN prove something will finish in finite time, you just can't prove how long that finite time is, which may be longer than the heat death of the universe.<br>



<blockquote>

<h2>Re:reusable toolchain?</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2008-01-31T09:51:48</h3>
<p>Errm, you would have done well to follow your own advice and stop at the end of the first sentence.<nobr> <wbr></nobr><tt>:-)</tt> </p>



<h2>Re:reusable toolchain?</h2>
<h3><a href="/user/nothingmuch/">nothingmuch</a> on 2008-02-02T17:17:35</h3>
No, that is just plain wrong.<br><br>You can very easily prove that the program 1 + 1 will return in finite, and short time, and it has nothing to do with heat death of the universe (very long != infinity).





</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>One True Grammar</h2>
<h3><a href="/user/brian_d_foy/">brian_d_foy</a> on 2008-01-29T14:48:07</h3>
The mutable Perl 6 grammar scares me too, but I'm hoping that people never use it and it doesn't become a problem.<br><br>In my "Bird's Eye View of Perl", the talk I give to managers, I talk about Perl being a single language that comes from the same source. The idea of multiple implementations looks good on paper, but it doesn't work out in practice. Besides knowing the core language and its libraries, now the mere mortal users have to wrestle with pecularities of each implementation and grammar. It the reason I stopped using Java a long time ago (and it's probably much better now). I didn't have anything against Java, but I wasn't going to waste my time making perfectly valid code work with the three or four slightly broken VMs. I hope that Perl 6 eventually won't have that problem.<br><br>I'll wait to see what happens and what the reality is, but I'm certainly concerned since I'm writing <i>Learning Perl 6</i>. That's much easier if there is One True Grammar and One True Implementation instead of footnotes for "In Pugs this happens but in Some Other Thing this happens". Anything beyond that is a lot of work for the benefit of a few people.



<blockquote>

<h2>Re:One True Grammar</h2>
<h3><a href="/user/Abigail/">Abigail</a> on 2008-01-29T16:17:42</h3>
<em>The mutable Perl 6 grammar scares me too, but I'm hoping that people never use it and it doesn't become a problem.</em>
<p>
Yet, whenever I raise my biggest objection I have against Perl6 (meaningful whitespace), I always get thrown back "well, you can change the grammar you know...".</p>



<blockquote>

<h2>Re:One True Grammar</h2>
<h3><a href="/user/schwern/">schwern</a> on 2008-01-29T18:01:00</h3>
Yeah, I was just going to say that.  "Just change the grammar" was used to end Perl 6 language debate sort of like "God works in mysterious ways" is used to end religious debate.<br><br>Thankfully I haven't seen it come up as much lately.  Maybe folks are starting to realize that easily mutable grammars are a powerful and awesome tool but not the sort of thing you want every kid on the block to use.





</blockquote>


<h2>Re:One True Grammar</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-29T21:49:27</h3>
I see multiple implementations as a strength.<br><br>At some point you simply HAVE to be able to have an IronPerl6 and JPerl6 simply for long term language flexibility and health.



<blockquote>

<h2>Re:One True Grammar</h2>
<h3><a href="/user/brian_d_foy/">brian_d_foy</a> on 2008-01-29T22:11:27</h3>
I thought that was the point of parrot---you didn't need different implementations if you had the byte code.<br><br>I don't see different implementations as necessary to anything. Some people might like it, but in reality people will code to the implementation's features. It happens in Java, Javascript, Lisp, Smalltalk, and probably a lot of others that I haven't used. The conversations at the pub are about who supports what and what you have to do to make good code on one implementation work on another.<br><br>It's not something I'm looking forward too.<br><br>



<blockquote>

<h2>Re:One True Grammar</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-30T02:56:31</h3>
There's going to be many cases where people are already standardised on a particular environment, typically CLI/.Net or JVM.<br><br>They already have management infrastructure in place to deal with it, and if you can fit in with the existing it's a huge plus.<br><br>Not to mention that if you can run on multiple implementations it's a huge advantage ecologically speaking, you can respond to environmental disasters much better.<br><br>(Just look at how Catalyst dealt with the Class::DBI disaster compared to Maypole)



<blockquote>

<h2>Re:One True Grammar</h2>
<h3><a href="/user/brian_d_foy/">brian_d_foy</a> on 2008-01-30T03:22:37</h3>
Catalyst dealt with the Class::DBI disaster by using something different. That's not how I want people to deal with Perl.<nobr> <wbr></nobr>:)



<blockquote>

<h2>Re:One True Grammar</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-30T04:21:25</h3>
Similar analogy...<br><br>How is some users of Python/Ruby dealing with their C implementations can be slow?<br><br>By switching to JRuby/IronPython/etc...<br><br>Similarly Catalyst survived by leaving Class::DBI, but nobody that was using Catalyst had to leave Catalyst. The same cannot be said for Maypole.<br>





</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Separate grammar from BEGIN blocks?</h2>
<h3><a href="/user/schwern/">schwern</a> on 2008-01-29T18:05:12</h3>
Seems to me the trick is to separate grammar changes from BEGIN blocks.  That is, you have explicit blocks which do nothing but change the grammar.  They can't execute code, they can't call eval, they can't declare variables, they can't load modules (except other grammar-only modules).  They would then allow two critical things for tools:<br><br>1)  They're safe to execute.<br>2)  The tools can be made aware of grammar changes.<br><br>It might not even need to be as restrictive as all that, maybe just that grammar changes happen in a "Safe" compartment which doesn't allow access to the outside world.  This allows some flexibility when defining the grammar while still making it safe to run.<br><br>It might already work this way, I haven't looked.



<blockquote>

<h2>Re:Separate grammar from BEGIN blocks?</h2>
<h3><a href="/user/nothingmuch/">nothingmuch</a> on 2008-01-29T19:06:55</h3>
The problem is that the grammar is code itself.



<blockquote>

<h2>Re:Separate grammar from BEGIN blocks?</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-29T21:51:05</h3>
That may not be a problem if the code is never run...<br><br>If "=" is mapped to sub equals, you shouldn't need to run equals while parsing, right?<br>



<blockquote>

<h2>Re:Separate grammar from BEGIN blocks?</h2>
<h3><a href="/user/nothingmuch/">nothingmuch</a> on 2008-01-29T23:25:14</h3>
You don't understand. The grammar itself is a class. The parsing primitives are methods. It is actual Perl 6 code that does the parsing, you don't get a BNF for it.



<blockquote>

<h2>Re:Separate grammar from BEGIN blocks?</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-30T03:12:05</h3>
The parsing primitives are controllable and, fortunately, NOT arbitrary code.<br><br>And so they don't present a decidability problem, at least for the parsing primitives that are available out the box.<br><br>If we DO allow arbitrary grammar modifications, and those modifications will result in the execution of arbitrary code, well then we're back into the decidability quagmire again.<br><br>In fact, if arbitrary grammar chances are trivially associational with arbitrary compile-time execution then that should pretty much clearly prove that non-final grammars make the language undecidable for Perl 6, and we don't even need to introduce the problem of how to modelling arbitrary syntax and semantics.<br>



<blockquote>

<h2>Re:Separate grammar from BEGIN blocks?</h2>
<h3><a href="/user/nothingmuch/">nothingmuch</a> on 2008-01-30T12:12:05</h3>
Go over the synopses again then... You can definitely define grammars in terms of code.<br><br>However, as long as this is trusted code, which you can determine by introspecting it, I don't think this is a problem.





</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Really? It scares you that badly?  Wow.</h2>
<h3><a href="/user/rhandom/">rhandom</a> on 2008-01-29T18:51:58</h3>
I'm afraid that I can't restate your concern without putting words in your mouth - so I won't try.  So I will look at this from my own perspective.
<br> <br>
I think it would be great to be able to have parsers/editors/refactor-ers that can "statically" (whatever that means) analyze Perl 6 code and do neat(tm) things with the output.  I will write the majority of my Perl 6+ code in the standard grammar using the future best practices for doing so because I think there will be great tools that will give great insight into my code.  And I think that the standard grammar will make it much easier to do (much more easy than what Perl 5 gave which was nearly nothing).  I see no reason why there can't be a standard PPI6 - it is just the standard grammar.  Done.
<br> <br>
When time permits, or the problem requires it, or when I get bored I may try to modify the grammar to fit my need.  Why would I ever assume that if I was writing a grammar modification - that some stock code analyzer would be able to read code written in my new grammar.  That would be a foolish assumption to make.  It would also be an error on my part to require that it must be able to parse my new dialect.
<br> <br>
Now - I assume that there will be those who will write nifty changes to the grammar.  I don't know that they will, but I have every reason to assume that somebody will make a useful module that overrides the stock grammar.  Why would I now assume that the stock code analyzer would be able to parse this new dialect.  Again - it would be a foolish assumption to make.  Again - it would be an error to require that the stock analyzer be able to parse the code.  But in this case, if they have written a nifty extension to the grammar and it saw sufficient uptake and was widely popular, I would assume that somebody would write a plugin to the stock analyzer that would let the extended grammar parse just as well.  And if not, and it was important to me, then i'd try and figure out how to do so.  And if the tools aren't capable of being extended, well, then I'd seek out new tools.
<br> <br>
I don't mean to be argumentative, but I think the picture painted is far worse than what you have presented.  Here's where I put words in your mouth<nobr> <wbr></nobr>... you want "easy to parse," "standardized," "refactorable," syntax and you are scared that somebody will extend the grammar, so we shouldn't be able to extend the grammar.  Well, all of that request will be available, except for the "shouldn't be able to" part.  That part is replaced with "most of the time people won't, but sometimes they will, and if they do, then maybe it isn't all bad for them to."
<br> <br>
I think in the rare cases, this will be the fusion powered ultra mega swiss-army chainsaw of death that will make it possible to do the impossible job.  Maybe even make it easy.  And I won't care if I have to edit the code without the help of a stock analyzer.  But most of the time I'll settle for using the ultra swiss-army chainsaw that is called Perl 6 - and will love using PPI6 enabled tools to do so.



<blockquote>

<h2>Re:Really? It scares you that badly? Wow.</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-29T22:06:44</h3>
&gt; I see no reason why there can't be a standard PPI6 - it is just the standard grammar. Done.<br><br>There is a VAST gap between anyone thinks is true and what they can prove.<br><br>Personally I DO see reasons why, plenty. Because I spent three years wrestling with them in Perl 5's grammar, several of which are based on mathematically provable impossibilities. And these grammar problems remain in Perl 6 unchanged.<br><br>You can't just invoke the "standard grammar" as some kind of magic cure-all.<br><br>SOMEONE has to eventually write this stuff, and at the moment the default expectation of many people seems to be on me.<br><br>&gt; I think it would be great to be able to have parsers/editors/refactor-ers that can "statically" (whatever that means)<br><br>"Static" essentially means "context-free". That is, you can treat an arbitrary Perl source code file as a document, and parse it without needing to also parse any other documents.<br><br>&gt; When time permits, or the problem requires it, or when I get bored I may try to modify the grammar to fit my need.<br><br>And this is EXACTLY what worries me.<br><br>If it is EAST to modify the grammar or worse becomes fashionable to do so, then we end up in a world of mess because an even smaller percentage of existing documents can be parsed.<br><br>&gt; And if the tools aren't capable of being extended, well, then I'd seek out new tools.<br><br>This assumes that 1) Other tools exist 2) Such tools are possible to write at all.<br><br>&gt; Here's where I put words in your mouth<nobr> <wbr></nobr>... you want "easy to parse," "standardized," "refactorable," syntax and you are scared that somebody will extend the grammar, so we shouldn't be able to extend the grammar.<br><br>No. I don't want it to be impossible to extend the grammar.<br><br>I see a lot of (theoreticaly at least) value in things like "use physics".<br><br>What I do see is a giant shiny thing that people will INEVITABLY want to use despite the fact it will make your code impossible to work with in anything more complex than Notepad.<br><br>So I want it to be HARD to modify the grammar.<br><br>Or at least I want something that triggers flashing lights and air raid sirens that you need to toggle before you are allowed to modify the grammar.<br>



<blockquote>

<h2>Re:Really? It scares you that badly? Wow.</h2>
<h3><a href="/user/rhandom/">rhandom</a> on 2008-01-30T00:22:08</h3>
I am fully aware of your work with PPI on Perl 5.  I am aware of the "proof" that it is impossible to statically parse Perl 5.  I think they are amazing accomplishments.  That said, I haven't had any need for PPI on Perl 5 and I think that it is obvious that BEGIN blocks potentially make it impossible to parse Perl 5.  I believe your zero-ary sub followed by regex issue is actually taken care of in Perl 6 - at least the standard parser will be able to handle it.

<blockquote><div><i>You can't just invoke the "standard grammar" as some kind of magic cure-all.</i></div>
</blockquote> 

Sure I can.  If I write standard perl 6, then I can use the standard grammar and get a parsed tree back...  Like magic...  Just like I said in my first post.  If I don't write standard perl 6 then all bets are off, just like I said in my first post.<p><blockquote> <div><i><nobr> <wbr></nobr>...at the moment the default expectation of many people seems to be on me.
</i></div> </blockquote>

Um, no.  The standard grammar parses standard perl 6.  I don't really expect anything of you.  I don't intend this as a slight.  I just really don't have any requirements placed on you.<p><blockquote> <div><i>
you can treat an arbitrary Perl source code file as a document, and parse it without needing to also parse any other documents.
</i></div> </blockquote>

If you want to refactor your code or have method autocompletion, or check the code for security problems it is an impossible dream to analyze the code as an isolated document.  You can't do it.  You couldn't do it in Perl 5.  You can't do it in Perl 6.  If you allow inclusion of other documents, more things become possible.
<br> <br>
If all you want is to syntax highlight, then you don't need a parsed document at all.  You are actually better off without having to parse the document as it is nice to have syntax highlighting while you are creating an as of yet uncompilable document.  The last thing I want is for the syntax highlighting to disappear and reappear while I type because the syntax goes in and out of being correct and incorrect.<p><blockquote> <div><i>
&gt; And if the tools aren't capable of being extended, well, then I'd seek out new tools.

This assumes that 1) Other tools exist 2) Such tools are possible to write at all.
</i></div> </blockquote>

This was my fault for stating or implying that I need these tools.  I don't.  My emacs highlights perl 6 documents just fine as it is RIGHT NOW.  It even completes methods for me too, albeit in a non-class-associative way.  I'm productive enough right now in Perl 5 and I'll be productive enough in Perl 6.  I'm not sure why not having a parsed document forces us down to the level of notepad.  Of course having PPI style tools could possibly help me be more productive - but there is no guarantee that they would even if the grammar was static.<p><blockquote> <div><i>
If it is EAST to modify the grammar or worse becomes fashionable to do so, then we end up in a world of mess because an even smaller percentage of existing documents can be parsed...
<br> <br><nobr> <wbr></nobr>...So I want it to be HARD to modify the grammar...
</i></div> </blockquote>

To summarize with a run-on sentence:

You want it to be difficult for an unquantifiable future developers, to potentially modify an un-finalized grammar, for an un-finished language, because the developers might possibly extend the grammar in a way that might possibly be harder to parse than the as yet-un-finished standard grammar, that might not be possible to statically parse, by a tool that doesn't yet exist, that hasn't been requested or at very least isn't required by the community and may or may not have any real utility at all, because writing the tool was barely possible for Perl 5, and writing the tool would be hard if not impossible for you to do.
<br> <br>
To sum up my summarization:  You want to cripple Perl 6 because it <i>might</i> be hard for your non-existing tool to parse it.
<br> <br>
I think it should be easy to change the grammar.  I'm glad Larry does too.  I think amazing things will come of the ability to do so.  I think it is premature to think that hobbling Perl 6 will provide more benefit than allowing for new design ideas.  Nobody knew what would happen with CPAN when it was introduced.  Modifyable grammars may fall on their face but I wouldn't bet on it.



<blockquote>

<h2>Re:Really? It scares you that badly? Wow.</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-30T01:00:39</h3>
&gt; Like magic...<br><br>There is no magic, just complexity we don't understand enough.<br><br>&gt; I just really don't have any requirements placed on you.<br><br>I didn't say YOU, I said "many people". I seem to get those sorts of comments about once a week or so.<br><br>And from about 50% of everyone that has used perlcritic or something else PPI-based.<br><br>&gt; If you want to refactor your code or have method autocompletion, or check the code for security problems it is an impossible dream to analyze the code as an isolated document.<br><br>Pretty much all languages with simplistic grammars (Java/Python) can do this with relative ease.<br><br>Also, you don't have to do it perfectly. Approximations are able to be approximately as useful as a complete model.<br><br>&gt; To summarize with a run-on sentence...<br><br>This comes across as dismissive and laden with uncertainties, but you pretty much nailed it.<br><br>It's reasonable to predict they will exist and be mostly like developers of other languages. Humans, with hobbies and jobs and preferences similar to other developers.<br><br>The grammar is unfinalized, but largely complete.<br><br>The language is incomplete, but hasn't stopped is discussing it for the last several years.<br><br>There's no "might" about it being not statically parsable.<br><br>The tool already exists according to you (the Perl 6 parser).<br><br>The tools have been CONTINUOUSLY requested, certainly to me, and clearly consider it useful. Personally, I've certain found my version synchronization tool and my SQL injection attack detector useful in real world scenarios.<br><br>The number of people requesting it demonstrated a need.<br><br>The fact it was barely possibly in Perl 5 is the REASON we should be treating this properly in Perl 6.<br><br>To counter-summarize: I want to cripple Perl 6 so that it is possible for ANYONE to write tools for it.<br><br>You might be brilliant enough to productively work on 100,000 line projects written by other people with nothing more than emacs, but I'm not.<br><br>Having effective developer tools is essential for being productive in a language across the full set of all language developers. If they weren't needed, then we wouldn't see the correlation that the best developers are generally the ones WRITING the tools to automate themselves out of development tasks.



<blockquote>

<h2>Re:Really? It scares you that badly? Wow.</h2>
<h3><a href="/user/rhandom/">rhandom</a> on 2008-01-30T05:35:43</h3>
<p><blockquote> <div><i>
You might be brilliant enough to productively work on 100,000 line projects written by other people with nothing more than emacs...
</i></div> </blockquote>

All of my jobs to date have met this criteria.  Most of the jobs have been "pure perl" shops with 3 to 20 perl developers.  We are hiring now in Orem Utah if anybody is interested.  And emacs and vim are still the best tools for the job where I work.  Not to abuse perl critic - but it helps little in what we are doing, whereas test suites and Devel::Cover help considerably.  The Perl 6 seems more likely to make Devel::Cover possible than Perl Critic.





</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Smart tools</h2>
<h3><a href="/user/Thos Davis/">Thos Davis</a> on 2008-01-29T20:30:27</h3>
Actually, because Perl 6 does have a grammar, a tool could include it's own parser which would could lex the code including any grammar changes without doing any of the calls which don't change the language. That wasn't really possible when filters were reaching in and twisting about the compiler innards. Consequently, tools like vim with it's own syntax coloring language which is not dynamic, will be less useful<nobr> <wbr></nobr>:( while others with plug-in token labelers will flourish -- well until someone replaces the current syntax logic with a perl6 instance that will allow coloring tokens in any language with dynamic syntax<nobr> <wbr></nobr>:).



<blockquote>

<h2>Re:Smart tools</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-29T22:16:23</h3>
You've outlined the situation perfectly.<br><br>Perl 6 breaks a ton of existing tools, while relying on the existance of new tools which everybody assumes will exist but nobody has actually proven can be written.<br>



<blockquote>

<h2>Re:Smart tools</h2>
<h3><a href="/user/rhandom/">rhandom</a> on 2008-01-30T00:31:09</h3>
<p><blockquote> <div><i>
Perl 6 breaks a ton of existing tools,
</i></div> </blockquote>
Besides the fact that the existing tools were written before Perl 6, there is no guarantee they would work with Perl 6 if grammar modifications were disabled.  There is no existing tool today that works with perl 6 (other than basic syntax highlighting of various editors).  Your entire basis in this thread is about the creation of <i>"new tools which everybody assumes will exist but nobody has actually proven can be written.</i>



<blockquote>

<h2>Re:Smart tools</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-30T02:59:29</h3>
I'm talking about the methodologies used to implement the tools.<br><br>If there is an equivalent environment, then it's reasonable to predict that an equivalent methodology can be used to achieve an equivalent result.<br><br>The code then just becomes an implementation detail.<br><br>I don't understand why you are attacking my in a discussion about a future language for talking future tools for that future language.



<blockquote>

<h2>Re:Smart tools</h2>
<h3><a href="/user/rhandom/">rhandom</a> on 2008-01-30T05:27:55</h3>
<p><blockquote> <div><i>
I don't understand why you are attacking me in a discussion about a future language for talking about future tools for that future language.
</i></div> </blockquote>

I apologize if you felt a personal attack.  Some of my comments may have been too heavy.  But you surely expected some heavy responses when you attacked the future language.  Still I apologize.





</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Taming the Beast</h2>
<h3><a href="/user/dpuu/">dpuu</a> on 2008-01-30T02:29:45</h3>
The reasoning of the article -- that dynamic languages (where the language itself is dynamic) are difficult (perhaps impossible) to analyze statically  seems reasonable. The proposed solution: less so.
<p>
Lets assume that we don't want to hobble perl6 before people have had a chance to evolve it -- yet we still want tools that can safely analyze non-trivial applications of it, without running those applications -- not even the "BEGIN" blocks. What would be required?
</p><p>
The answer is probably that you'd need to require any grammar modification to be accompanied by some meta data. Perhaps one could say that grammar modification is only permitted by a "used" module, and that it is allowed to modify the grammer only of its user, not itself. This would mean that the code analyser would need to see the meta data associated with the "use Foo;" statement, but not necessarily the code associated with module Foo.
</p><p>
This proposal might hobble perl-6 too much. So there's a second fallback: define a dielect (subset) of perl that enforces this rule. If you're writing perl6 code yourself, and so know that you want to use the tool, then you'd only permit yourself to use modules that conform the the appropriate meta-data spec (C6PAN modules might be tagged that they support it). A lint tool that sees you using a module that doesn't contain the meta data (minimal: "this module doesn't mess with it's user's grammar" tag) would issue an error.
</p><p>
Summary: I agree that unconstrained perl6 will be so dynamic that it is impossible to analyze statically, but my gut tells me that it will be possible to define a tame subset that can be analyzed. Library writers, and JAPHs, and golfers, would use wild-perl; corporate enterprise users would use tame-perl.</p>



<blockquote>

<h2>Re:Taming the Beast</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-30T03:05:35</h3>
I concur completely with both your conclusions and suggested adaptations.<br><br>This is pretty much what I'm advocating.<br><br>The key differentiation is perhaps that I strong think we need to define and support this subset/strict form of Perl 6 from day one and have it a considered part of the language, rather than try to hack something afterwards.<br><br>To quote Larry, "Why do people seem to keep thinking I'm only creating one language here".<br><br>From these N languages he is allowing, we need to at some point nail down an identifiable "Standard Perl 6" we can actually target development and analysis tools at.<br><br>If we know this exists early, then we can make sure all the lowest-level platform-abstraction and toolchain modules are all compliant with this subset, so that it won't potentially compromise downstream dependencies.<br>



<blockquote>

<h2>Re:Taming the Beast</h2>
<h3><a href="/user/dpuu/">dpuu</a> on 2008-01-30T06:24:14</h3>
I guess the place where I disagree is the "have it considered part of the language" bit (other than that, by definition, a subset is part of the whole).
<p>
My background is ASICs. The history of semiconductor design is one of increasing abstraction while maintaining a path to implementation (i.e. to manufacturable hardware). Many years ago, Verilog and VHDL appeared as hardware modeling languages. Tool vendors saw opportunity for profit if they could convert "models" to "implementation", and they started selling tools that could synthesize subsets of the languages down to gates. The "Synthesizable Subset" became a de-facto standard: it was the subset that you used if you wanted you code to synthesize across the tools from multiple vendors. More recently, SystemVerilog and SystemC are following a similar path.
</p><p>
Not everything can be defined using the synthesizable subset. Analog components, and complex cores, would be defined as "black boxes", with behavioral models (i.e. full language models -- or even models written in other languages such as C++) for simulation; plus meta data to define the relevant properties to the tools.
</p><p>
I would see the same path being followed for Perl6. Language designers and library implementors will use the whole language. People, such as yourself, will create tools that understand some useful subset. If other people agree that the subset is useful then they will limit themselves to that tool; and module authors will have an incentive (users!) to create the meta data. The exact form of meta data need not be part of Perl. It could be a separate domain-specific language -- though one could argue that Perl6 should have the hooks to allow it to be associated with the code (perhaps via POD).
</p><p>
So I say, don't wait for the subset to be blessed by @larry before creating the tool. Pick some arbitrary subset (e.g. pugs) and tell people of all the cool things they can do if they restrict themselves to just those features. If it's not cool enough, then add more features! I'd hope that  a symbiotic relationship could form between programmer-tools and language-design.</p>



<blockquote>

<h2>Re:Taming the Beast</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-30T09:58:17</h3>
Thanks for the great precedent.<br><br>The thing in this case is that the language still hasn't been finalized, and if at all possible I'd like this subset blessed and supported internally.<br><br>For example, not just detailing the subset but actually having the parser finalize the grammar class by default, or something, so that the subset is both provable and enforcable.<br><br>And if that fails, well THEN we look at the alternatives...



<blockquote>

<h2>Re:Taming the Beast</h2>
<h3><a href="/user/dpuu/">dpuu</a> on 2008-01-30T17:35:27</h3>
I'd be tempted to go down the road of being explicit -- avoids the political pain of fighting for the subset. In perl5, people are used to saying "use strict" at the top of every file. You could create a "use strict::static" module that (a) tells your tool that the user's module should be analyzable; and (b) modifies the grammar to eliminate the ability to modify the grammar. If the core language doesn't allow you to write such a module then you have a strong case to argue to tweak the language; but otherwise you can exist somewhat independently.
<p>
That said, a good way to promote it would be to have the (an) implementation of perl6 were written in this safe subset. A statically analyzable language is easier to optimize at compile-time, so there's an objective technical reason for doing so.</p>





</blockquote>

</blockquote>


<h2>Re:Taming the Beast</h2>
<h3><a href="/user/phaylon/">phaylon</a> on 2008-01-30T19:08:17</h3>
<p>Do you mean something like the Scheme standard revisioning process for a "Standard Perl"? That could actually be nice. Especially since we have a (assumably (is that even a word?)) larger userbase and a (also assumably) more practical than academic POV.</p>



<blockquote>

<h2>Re:Taming the Beast</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2008-01-31T09:50:24</h3>
<p>(The word you were looking for is &#8220;presumably.&#8221;)</p>





</blockquote>

</blockquote>

</blockquote>


<h2>Chris Dolan's unintentional response from Jan 27th</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-30T05:12:07</h3>
Chris Dolan says,<br><br><i>"After using Java off and on for many years, I've been using it almost full time for the last year. I've loved it. It's not the language itself I like, but the combination of Eclipse + Java. Java's strong typing means that Eclipse can infer a HUGE amount of detail about your code and make valuable suggestions for code completion, improvement and organization. Most of the time Java is still quite a bit slower to write than Perl, but at some tasks it is actually faster and is more likely to be correct before you run the first unit test. The Java analogues to Perl::Critic (Coverity, FindBugs, CodePro, CheckStyle, PMD) are WAY, WAY ahead of us.<br><br>I still think Perl's syntax is vastly better for humans, but Java's syntax is so much better for computers than Perl's that Java + Eclipse is a net win over Perl + Emacs.</i>"



<blockquote>

<h2>Re:Chris Dolan's unintentional response from Jan 2</h2>
<h3><a href="/user/tron/">tron</a> on 2008-01-30T08:44:51</h3>
I think that pretty much nails it down.<br><br>In my opinion: If Perl6 does not make it easy to create tools like Eclipse or (though I don't like MS) Visual C++ for it and have by default - and without any extra effort by the programmer like adding meta data - the vast majority of available code ready for use in them, then it won't be successful with the masses.<br><br>It's not like ten or fifteen years ago when emacs ruled - today people are used to use IDEs offering advanced code completion, refactoring support and the like. If they don't get that for a language they simply won't consider using the language.<br><br>From what I've seen (and based on what I understand from what I've seen<nobr> <wbr></nobr>;-) Perl6 will be a great language - but it'll only live in the shadows without the right tools...



<blockquote>

<h2>Re:Chris Dolan's unintentional response from Jan 2</h2>
<h3><a href="/user/rhandom/">rhandom</a> on 2008-01-30T16:13:10</h3>
<p><blockquote> <div><i>If Perl6...</i></div> </blockquote>

This nails down my opinions about this article as well.  My opinions are against people who are not @Larry or who haven't contributed more than a few patches (if even that), who speak as if in behalf of the community saying what should be done or predicting the sad future if their demands aren't met.  I apologize to you because this rant is in response to your article when it really applies to a much larger set of postings across the years.  Of course people are allowed their opinions - but I think the volunteers that are putting Perl together sort of deserve to follow their course unhindered.<p><blockquote> <div><i>
but it'll only live in the shadows without the right tools...
</i></div> </blockquote>

Who is Perl 6 being built for.  It is being built for the people who love it by the people who love it.  There are no companies or foundations dumping large amounts of money into it.  Perl the language is a labor or love.  And whether we create tools or not - Perl will always be in the shadows.  That doesn't mean I'll love it less.  The industry has shown time and time again, that just because someone builds something better (for an arbitrary person's definition of better), that doesn't guarantee widespread adoption.
<br> <br>
Perl 6 is and will be great.  But there is no reason to believe that because it is great, that people will drop whatever they are using and flock to it.  That won't happen.  The question is, does that change your valuation of Perl.
<br> <br>
You are welcome to build and use Perl because you think people will flock to it.  I use Perl 5 because it helps me to get my job done, scales well code-base wise, scales well server side, and is generally a joy to work with.  Everything I've seen about Perl 6 affirms that this trend will continue.
<br> <br>
Thank your for your response, because it is one more note reminding me that I need to get in and contribute code to Perl 6.



<blockquote>

<h2>Re:Chris Dolan's unintentional response from Jan 2</h2>
<h3><a href="/user/tron/">tron</a> on 2008-01-30T17:34:47</h3>
<p><blockquote> <div><cite>Who is Perl 6 being built for. It is being built for the people who love it by the people who love it.</cite></div> </blockquote>
<p>Yep. But I'm pretty sure more people would love it if some tools would ease their burden of tedious day-to-day work like code refactoring or make it easier just to take the first steps in a new programming language.</p>
<p>As someone else replied to you: <cite>You might be brilliant enough to productively work on 100,000 line projects written by other people with nothing more than emacs, but I'm not.</cite> That last remark certainly applies to me as well, no matter how much I like my vim.<nobr> <wbr></nobr>;-)</p> <p><blockquote> <div><cite>And whether we create tools or not - Perl will always be in the shadows.</cite></div> </blockquote>
<p>I don't actually see why I should take that for granted. Tools, of course, do not guarantee success - but they certainly help.<br>
Maybe you don't like those fastidious milksops right from university who didn't learn their craft just with ed and who can only program if their IDE tells them what to do (well, there's some kind of exaggeration in that...) and just don't want to see them hanging around in the perl community? But there are many of them! And maybe I'm more of an evangelist kind of person than you - but I'd love to see a more widespread use of Perl6
if only it increases my chances for working on Perl projects with others.</p> <p><blockquote> <div><cite>Thank your for your response, because it is one more note reminding me that I need to get in and contribute code to Perl 6.</cite></div> </blockquote>
<p>Well, even if that's the only effect my post had it was worthwhile<nobr> <wbr></nobr>;-)</p>



<h2>Re:Chris Dolan's unintentional response from Jan 2</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2008-01-30T19:16:06</h3>
<p><blockquote> <div><em>Of course people are allowed their opinions - but I think the volunteers that are putting Perl together sort of deserve to follow their course unhindered.</em></div> </blockquote>

<p>I don't know about the word "unhindered", but I will say this.</p>

<p>I thought about a problem in OO code for a couple of years and argued about it with friends and family and colleagues for a couple of years and, when Allison handed me the Smalltalk Traits paper and said "This is really close to what I think you want", I was finally able to convince Larry and Damian that existing OO systems had a real problem and that what would become roles was a real solution.</p>

<p>I don't know if the other designers would have found a similar solution in time.  I do know that it took a lot of work to get a feature I wanted in the language, but we're all better off for it.  That's the way many features get in community-driven projects: the people who really want them enough to work for them make them.</p>



<blockquote>

<h2>Re:Chris Dolan's unintentional response from Jan 2</h2>
<h3><a href="/user/rhandom/">rhandom</a> on 2008-01-30T19:53:36</h3>
Yes - unhindered is too strong.  The feeling I was trying to get to was "please stop complaining or changing perl and get in and do something."
<br> <br>
Code speaks louder than words, and when you or Allison or Patrick or Jerry or any of the other current major contributors to Perl 6 find design deficiencies, you should have more clout and say in changing the language that those (like me) who up to date have stood on the sidelines.
<br> <br>
Even though I've just been an observer, I've still grown tired of the rhetoric in and out of the community saying <i>"Perl 6 will be bad because/unless..."</i>  For those in the community I know it is just because they want to make sure that Perl 6 really is great -- but posting inflammatory (whether intentioned or not) instead of going through the mailing lists or irc channels and asking Larry directly serves little to help the community.
<br> <br>
I know Adam intended well.  The method of delivery just seemed a poor choice.  Especially in light of Moritz asking the exact same thing and getting a nice explanation from Larry.
<br> <br>
Oh - and by the way.  Thanks chromatic.



<blockquote>

<h2>Re:Chris Dolan's unintentional response from Jan 2</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2008-01-30T20:49:09</h3>
<p><blockquote><div><nobr> <wbr></nobr><em>... you should have more clout and say in changing the language that those (like me) who up to date have stood on the sidelines.</em></div> </blockquote>

<p>I don't think that's necessarily true.  While there is a distinction between committer and contributor, if you showed up with a test or documentation or code patch that was obviously right, I'd apply it like one of my own patches.</p>

<p>There <em>is</em> a big difference between complaining out of band and contributing, but I have reminded myself in the past week that:</p>

<ul>

<li>Some people just like to complain.</li>
<li>Some people enjoy complaining more than feeling scared or concerned.</li>
<li>Some people just like to make trouble.</li>

</ul>

<p>I can do very little to help any of those people, so it's better for me to spend my time doing productive things and encouraging everyone else to participate in productive ways, such as on the mailing lists.</p>





</blockquote>

</blockquote>


<h2>Re:Chris Dolan's unintentional response from Jan 2</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-31T03:11:17</h3>
&gt; Who is Perl 6 being built for. It is being built for the people who love it by the people who love it. There are no companies or foundations dumping large amounts of money into it.<br><br>There is very little point in building an awesome language that we like using if nobody can be paid to do it.<br><br>If you can't creating a suitably strong economic proposition for the use of a language (and companies are, after all, almost purely economic beasts) and nobody can get a job working with the language, then the language is either a failure or merely a toy.<br><br>Ultimately, it comes down to productivity. Language design shouldn't merely be aa beauty contest. It's about making the most productive and efficient way of translating a developer's intent into machine-executable code.<br><br>



<blockquote>

<h2>Re:Chris Dolan's unintentional response from Jan 2</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2008-01-31T04:41:57</h3>
<p><blockquote> <div><em>There is very little point in building an awesome language that we like using if nobody can be paid to do it.</em></div> </blockquote>

<p>By that metric, Perl 5's a failure because TPF can't seem to convince companies outside of the usual suspects (including Stonehenge, O'Reilly, ActiveState, MSDW, Ticketmaster, and the Beeb) to chip in cash to fund its development.</p>

<p>The traditional economics where businesses shell out modest piles of money for things that help them make bigs piles of money don't seem to work out in favor of the volunteers who create the things that help big companies make big piles of money.  I've come to a sort of piece about that, where every few months I go off on a tear to call those companies antisocial, selfish leeches.  The rest of the time I console myself with telling them their opinions about the software I write don't matter unless they somehow find a way to contribute to the writing of that software.</p>

<p>That plan seems to work out.</p>



<blockquote>

<h2>Re:Chris Dolan's unintentional response from Jan 2</h2>
<h3><a href="/user/grinder/">grinder</a> on 2008-01-31T14:14:14</h3>
(I think the word you were looking for was "peace"<nobr> <wbr></nobr>:)



<blockquote>

<h2>Re:Chris Dolan's unintentional response from Jan 2</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2008-01-31T18:00:58</h3>
<p>True.  At that hour, the word I should have been looking for was "Goodnight!"</p>





</blockquote>


<h2>Re:Chris Dolan's unintentional response from Jan 2</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-31T23:19:09</h3>
&gt; By that metric, Perl 5's a failure because TPF can't seem to convince companies outside of the usual suspects (including Stonehenge, O'Reilly, ActiveState, MSDW, Ticketmaster, and the Beeb) to chip in cash to fund its development.<br><br>I wasn't referring to being paid to work ON it, I was referring to being paid to work WITH it.<br><br>Funding language development is a WHOLE different ball game...





</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Re:Chris Dolan's unintentional response from Jan 2</h2>
<h3><a href="/user/nothingmuch/">nothingmuch</a> on 2008-02-01T20:31:36</h3>
You are still working using the inherently flawed assumption that the best tools are written by reparsing Java/Perl 5/Perl 6 yourself, instead of reusing existing tools.<br><br>While that might be easy (perchance, easier, since the language is so simple) in the case of Java, or our only choice with Perl 5 due to practical limitations, if you have access to real meta data about the source code at all levels (text, parse tree, ast, runtime optree, emitter tree, etc) you are getting a lot more value.<br><br>There is lots of history besides Java, much more worth looking into. Smalltalk (especially Squeak), LISP/Scheme, forth etc are all good examples. Despite the fact that these languages have a very simple syntax (much simpler than even Java), they have established a culture where nobody bothers with the syntax anymore, even though it's so simple to do things with the right structures instead.<br>



<blockquote>

<h2>Re:Chris Dolan's unintentional response from Jan 2</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2008-02-02T20:43:11</h3>
<p><blockquote> <div><em>You are still working using the inherently flawed assumption that the best tools are written by reparsing Java/Perl 5/Perl 6 yourself, instead of reusing existing tools.</em></div> </blockquote>

<p>... especially the language's own abstract trees.  That technique gives Lisp and Scheme so much of their power and makes Smalltalk so malleable.</p>





</blockquote>

</blockquote>


<h2>Some random notes</h2>
<h3><a href="/user/phaylon/">phaylon</a> on 2008-01-30T18:15:01</h3>
<p>I'm not really that fit in the Perl 6 category, but I'd like to make some comment regarding the Scheme/Lisp way:</p> <p><blockquote> <div><p>"I can write something in 4 days in Lisp that takes most people 20 in some other language. I just spend 3 days modifying Lisp to solve that type of problem, then 1 day solving the problem".</p>

<p>The anti-pattern here is that you end up going way beyond TMTOWTDI. You don't get two, or three, or five ways to do it. You end up with a different language for every single person and every single project.</p></div> </blockquote>

<p>Are you sure he and you meant the same thing? When I implement a different "sublanguage" in scheme, I don't change the syntax (eg. the reader). The typical parenthesis structure is (AIUI) _not_ the syntax, it's just the structure. The stuff we see, is only one way to tell the reader how to transform this into sexprs, which will then be executed.</p>

<p>For example, there are modules that do whitespace-indentation in lisp and scheme. You could just use a different reader to read that one file in that format. Nothing changed about the reader of the current, or anybody else's code.</p>



<blockquote>

<h2>Re:Some random notes</h2>
<h3><a href="/user/phaylon/">phaylon</a> on 2008-01-30T19:50:54</h3>
<p>As an addition: Most scheme systems (Can't remember R5RS at the moment) handle the syntactical differences (read: Macros or other procedures that don't work with the usual left-to-right evaluation) with syntax objects that can be imported. I wonder if Perl 6 could use something like "use syntax My::Company::Grammar".</p>



<h2>Re:Some random notes</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-31T03:12:31</h3>
It's entirely possible I got the language wrong here... in retrospect that story may have been about SmallTalk perhaps?<br>



<blockquote>

<h2>Re:Some random notes</h2>
<h3><a href="/user/phaylon/">phaylon</a> on 2008-02-06T16:49:33</h3>
I think the language could be the right one, without problem. It's just that developers of different languages have different semantics between the lines<nobr> <wbr></nobr>:)





</blockquote>

</blockquote>


<h2>What Larry says...</h2>
<h3><a href="/user/rhandom/">rhandom</a> on 2008-01-30T19:25:26</h3>
Larry recently (2008-01-30) responded to Moritz Lenz who was asking about writing a code analyzer/annotator (fancy that).  The following are excerpts from Larry's reply on the perl6-compiler mailing list:
<br> <br>
Larry:
<br> <br> <i>
"Let me correct an oversimplification here. &#160;Most grammar changes
will *not* be done by BEGIN blocks. &#160;BEGIN blocks (like eval) are a
tool of last resort; they're only there for when it's impossible to
achieve what you want by ordinary means. &#160;Perl 6 is very much about
providing more ordinary means for things that used to have to be done
by BEGIN or eval."
<br> <br>
"Instead, grammar changes will be done by using a module that derives
a grammar from STD. &#160;The derived grammar will be defined the same way
the original grammar is, so there is no change of the basic underlying
rules here. &#160;If you find a sane way of dealing with STD you should be
able to deal with its derivatives just as easily. &#160;Unlike BEGIN blocks,
grammar warping modules come with names and versions and authorities,
so when you warp your language by calling "use", you are doing so in
a controlled fashion, and your new language can still be deterministic,
and produce a well-behaved AST."
<br> <br>
"... &#160;It will save your
sanity, and stop the flame wars about forcing people to program in
the One True Language. &#160;Perl 6 is not about that. &#160;It's about being a
metalanguage in which you can express many languages, and doing so in
a sufficiently controlled fashion that we always know what language
any given lexical scope is expressed in. &#160;And if we truly know what
language we're parsing at any moment, we can do everything PPI does
without much extra work, and without enforcing arbitrary linguistic
restrictions."
<br> <br> </i>
So basically - somebody else is taking care of PPI6 so you won't have to.  And it turns out it is the standard grammar engine.  And it turns out it will nearly just work... just like magic.



<blockquote>

<h2>Re:What Larry says...</h2>
<h3><a href="/user/Alias/">Alias</a> on 2008-01-31T03:14:00</h3>
I, of course, would still like to be placated by seeing someone actually do this...



<h2>Re:What Larry says&amp;#8230;</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2008-02-02T20:25:54</h3>
<p>Note for anyone interested: <a href="http://www.nntp.perl.org/group/perl.perl6.compiler/2008/01/msg1733.html" title="perl.org">the original post from Larry</a perl.org>.</p>

<p>Note to rhandom: when you quote something that&#8217;s on the web, it is courteous to provide a link.</p>



<blockquote>

<h2>Re:What Larry says&amp;#8230;</h2>
<h3><a href="/user/rhandom/">rhandom</a> on 2008-02-02T21:57:00</h3>
Note to aristotle: at the time the post was made, the article wasn't yet posted on google groups, and I was unaware of www.nntp.perl.org which still most likely wouldn't have had the post yet as I posted relatively soon after Larry had replied to moritz.  I did look for a link - but there wasn't one.  If there had been I wouldn't have quoted so much of his reply.
<br> <br>
However, you are very right.  I should've later replied to my own node with a link.  I think by that time I had resigned myself to the idea that if people wanted to see the full reply, they could look for a post from Larry on perl6-compiler around Jan 30 (details given in my post) in which ever way they normally access perl6-compiler.





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

