<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of Alias: YAML::Tiny 0.01</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>YAML::Tiny 0.01</h1>
<h2><a href="/user/Alias/">Alias</a> on 2006-04-24T03:24:45</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>I finally got around to reading the <a href="http://yaml.org/spec/current.html">YAML specification</a>.<br/><br/>OMG WTF BBQ!<br/><br/>It is unbelievably complex. The lower parts are a rat's nest of links to concept definitions, of which there are many. It requires a 3-phase event-based serialization and deserialisation pipeline.<br/><br/>It's like XML, plus 3 or 4 more extra resolution concepts to deal with human readability and choice.<br/><br/>This seems to result in page after page and multi-dozen EBNF statements just dealing with the issues of significant whitespace.<br/><br/>And for something which I'd originally imagined as just dealing with scalars, arrays and hashs, it contains gems like the following.<br/><br/>"A tag shorthand  consists of a valid tag handle followed by a non-empty suffix. The tag handle must be associated with a prefix, either by default or by using a Ã¢â¬ÅTAGÃ¢â¬Â directive. The resulting parsed tag is the concatenation of the prefix and the suffix, and must either begin with Ã¢â¬Å!Ã¢â¬Â (a local tag) or be a valid URI (a global tag). When the primary tag handle is used, the suffix must not contain any Ã¢â¬Å!Ã¢â¬Â  character, as this would cause the tag shorthand to be interpreted as having a named tag handle. If the Ã¢â¬Å!Ã¢â¬Â  character exists in the suffix of a tag using the primary tag handle, it must be escaped  as Ã¢â¬Å%21Ã¢â¬Â, and the parser should expand this particular escape sequence before passing the tag to the application. This behavior is consistent with the URI character quoting rules (specifically, section 2.3 of RFC2396), and ensures the choice of tag handle remains a presentation detail and is not reflected in the serialization tree (and hence the representation graph). In particular, the tag handle may be discarded once parsing is completed."<br/><br/>In its fully defined form YAML is a very impressive piece of software engineering, and the flexibility and expressiveness is breath-taking. But my god is it a heavy protocol.<br/><br/>In any case, it certainly explain why <a href="http://search.cpan.org/perldoc?YAML">YAML.pm</a> chews up 4 megabytes (in the debugger at least) of RAM just to load a default dumper and loader and round-trip an undef to a string and back again.<br/><br/>I've got some things I'd like to use it for, mostly utility config file stuff. But even in this age of large available memory, 4 meg is very big for something that isn't the focus of the program and is just doing some little side job.<br/><br/>So as with <a href="http://search.cpan.org/perldoc?Config::Tiny">Config::Tiny</a> and <a href="http://search.cpan.org/perldoc?CSS::Tiny">CSS::Tiny</a>, which both replace a heavy 3+ meg module, I'm going to have a shot at a <a href="http://search.cpan.org/perldoc?YAML::Tiny">YAML::Tiny</a>, which just implements the things you'd find in a typical META.yml, in as little code as possible.<br/><br/>I'm not sure if it can even be done yet, and I might need to kill it and do a simple event-pipeline YAML::Lite instead, but it's worth a try first.<br/><br/>And if you have a login to my SVN repository, you're welcome to join in and help.<br/><br/>And in a late-breaking update, rumors come to me of someone else's bloat frustrations over Log4Perl stimulating an idea for a Log4Perl-compatible Log::Tiny module :)</p>


<hr/>



<h2>typo in url</h2>
<h3><a href="/user/gizmo_mathboy/">gizmo_mathboy</a> on 2006-04-24T04:58:03</h3>
There is a typo in your URL's. They are missing a c in search.



<blockquote>

<h2>Re:typo in url</h2>
<h3><a href="/user/Alias/">Alias</a> on 2006-04-24T05:59:08</h3>
Thanks.<br><br>One of these days someone is going to make it simple to link to search.cpan.org. Just wish that day would hurry up.



<blockquote>

<h2>Re:typo in url</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2006-04-24T07:31:24</h3>
<p>You haven&#8217;t fixed all of them yet&#8230;</p>





</blockquote>

</blockquote>


<h2>YAML::Syck?</h2>
<h3><a href="/user/audreyt/">audreyt</a> on 2006-04-24T07:10:55</h3>
My YAML::Syck only takes 271k...<nobr> <wbr></nobr>:-)



<blockquote>

<h2>Re:YAML::Syck?</h2>
<h3><a href="/user/Alias/">Alias</a> on 2006-04-24T07:16:33</h3>
... and a C compiler<nobr> <wbr></nobr>:)<br><br>I'm terribly impressed with YAML::Syck, but I look at the entirity of the YAML spec and there's an enormous amount of, well, STUFF.<br><br>Does it handle all of the spec?



<blockquote>

<h2>Re:YAML::Syck?</h2>
<h3><a href="/user/audreyt/">audreyt</a> on 2006-04-24T07:29:03</h3>
Yes.  Syck is the most complete implementation of YAML.<nobr> <wbr></nobr>:-)



<blockquote>

<h2>Re:YAML::Syck?</h2>
<h3><a href="/user/Alias/">Alias</a> on 2006-04-25T11:52:01</h3>
Hmm... but how much of the spec is that?<br><br>I note for example that the documentation explicitly says it doesn't handle circular references. It there anything else like that?<br>



<blockquote>

<h2>Re:YAML::Syck?</h2>
<h3><a href="/user/audreyt/">audreyt</a> on 2006-04-25T12:19:07</h3>
Where does it say that?  That's already solved long ago.<nobr> <wbr></nobr>:-)<br/><br/>The only two unsupported features is "Force the Merge Key" and "Force Comments".  See <a href="http://whytheluckystiff.net/syck/" title="whytheluckystiff.net">http://whytheluckystiff.net/syck/</a whytheluckystiff.net> for details.  I've added Unicode support beyond what libsyck originally offers.



<blockquote>

<h2>Re:YAML::Syck?</h2>
<h3><a href="/user/audreyt/">audreyt</a> on 2006-04-25T13:07:52</h3>
Wow, thanks for the reminder; I have forgotten to push the new release (that handles circular refs and has been tested to be 5.005-compatible) to CPAN.<br/><br/>0.42 has been uploaded.  Thanks for the reminder.<nobr> <wbr></nobr>:)





</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Familiar sentiments&amp;#8230;</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2006-04-24T07:36:12</h3>
<p>You read my CPANRatings review, didn&#8217;t you?</p>



<blockquote>

<h2>Re:Familiar sentiments&amp;#8230;</h2>
<h3><a href="/user/Alias/">Alias</a> on 2006-04-24T13:34:39</h3>
I've wanted to do YAML::Tiny for a while, but I guess your comment just finally drove me over the edge to start it.<br>





</blockquote>


<h2>Module::Build</h2>
<h3><a href="/user/ChrisDolan/">ChrisDolan</a> on 2006-04-24T13:57:36</h3>
Be sure to check in with the Module::Build email list.  Right now, they are discussing making a mini-YAML to bundle with M::B.  Coordinating efforts would be valuable, I suspect.<br>



<h2>compared to XML?</h2>
<h3><a href="/user/slanning/">slanning</a> on 2006-04-24T16:42:50</h3>
How does YAML compare to XML in terms of heaviness, then? I thought YAML was supposed to be a lightweight configuration language. If not, then I really don't see why people wouldn't just use XML
or<nobr> <wbr></nobr>.ini-style config files.



<blockquote>

<h2>Re:compared to XML?</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2006-04-24T23:59:06</h3>
<p>YAML&#8217;s syntax is very lightweight, but extremely complex. If you only use the simple constructs, it ends up looking very clean and human-readable, but there are a <strong> <em>lot</em> </strong> of complex (ie. hard to explain to non-techies) constructs, and they all rely on funny (read: obfuscatory) punctuation.</p>

<p>XML has rather heavyweight syntax, but there are far fewer constructs than YAML has. It&#8217;s not really designed for rigidly and heavily structured  things like data structures; it lends itself much better to &#8220;documents,&#8221; ie. things that consist mostly of text with markup mixed right in.</p>



<h2>Re:compared to XML?</h2>
<h3><a href="/user/Alias/">Alias</a> on 2006-04-25T12:33:57</h3>
If I can use the machine-readable vs geek-readable vs human-readable  differentation, then I can sum up the difference as the following.<br><br>Binary file formats are machine-readable, but NOT geek-readable or human-readable.<br><br>This makes them small and compact, but very hard for developers to handle and work with, because it requires you be highly intimate to do anything at all.<br><br>XML is machine-readable AND geek-readable, but not human-readable. The format is designed for machines, but are done in a human-enough way that it's easy for developers to understand them, and work with them, without needing to be entirely intimate with the format.<br><br>This STILL makes XML not human-readable, so in general people shouldn't be expected to ever have to read them or edit them by hand in the normal course of their work, they should work with XML files through a program, or view them via some other presentation medium.<br><br>Interestingly, this means the specification for XML itself (for machine usage) is relatively compact still, but can still be fairly heavy-weight compared to a trivially simple human-readable format like Windows<nobr> <wbr></nobr>.ini files.<br><br>YAML is intended to be machine-readable, and geek-readable, AND human-readable, AND still have all the features that XML does.<br><br>This means that from a human point of view, it's fairly easy to say<br><br>
&nbsp; &nbsp; ---<br>
&nbsp; &nbsp; - foo<br>
&nbsp; &nbsp; - bar<br><br>The downside of this approach is that the complexity FOR MACHINES is much MUCH higher. The specification is enormous in order to deal with the added flexibility and easy-of-use needed to make it more human.<br><br>This results in a format that LOOKS "lighter" to humans, but is actually "heavier" for machines.<br><br>As a result, XML makes a good choice for some sorts of files. If humans will not be looking at the files directly, and you need more features than you can get from a trivial format like Windows<nobr> <wbr></nobr>.ini, then XML is a great choice.<br><br>In particular, XML with the use of Schemas is absolutely ideal for its original purpose of inter-system document transfer. If you need your data to cross a trust-boundary, to consume data from some other untrusted entity, and so on, then XML is the perfect choice.<br><br>But it's not something you should tell humans to edit, and so XML is a bad choice for configuration files humans will touch.<br><br>YAML is very heavy for machines, but it is human readable, and so it is currently quite possibly the best choice for more-complex configuration files that humans will need to edit directly.<br><br>





</blockquote>


<h2>First Impressions</h2>
<h3><a href="/user/vjo/">vjo</a> on 2006-04-28T08:44:46</h3>
I have meaning to read YAML spec too. My first impression of YAML was that it was garbage.<br><br>When I go to yaml.org I see no rationale for why it was invented. Is it better than XML? A substitute?<br><br>I only see an example<br><br>
&nbsp; &nbsp; <a href="http://www.yaml.org/start.html" title="yaml.org">http://www.yaml.org/start.html</a yaml.org><br><br>Which depending on taste is better or worse than XML.  I think it is worse because of &amp; | * &gt;<br><br>



<blockquote>

<h2>Re:First Impressions</h2>
<h3><a href="/user/sigzero/">sigzero</a> on 2006-04-28T18:26:12</h3>
<p>One thing I do like YAML for is doing a Data::Phrasebook type config. I used to have my SQL queries in an XML file but you have to change the &gt; and 

</p><p>Other than that...I would use XML.</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

