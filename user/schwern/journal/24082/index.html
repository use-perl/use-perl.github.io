<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of schwern: Early Decisions All Language Designers Will Regret</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Early Decisions All Language Designers Will Regret</h1>
<h2><a href="/user/schwern/">schwern</a> on 2005-04-08T23:04:41</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p>I recently have to touch Javascript and <a href="http://schwern.hates-software.com/2005/04/08/7eae2d31.html">am horrified at the lack of a require/include function.</a>  Now I find out it doesn't have namespaces either.

<p>FOR FUCK'S SAKE PEOPLE!  Did these guys all sleep through the last 30 years of language design?  If I had to enumerate the most important programming innovations in the last three decades namespaces and include would be near the top of the list.  This isn't something "fancy" like OO, these are the basics of MODULAR DESIGN: the thing which separates spagetti code from real code.

<p>Javascript isn't the only one to have made this mistake, not having namespaces.  Lua comes to mind as well as earlier versions of Perl and PHP.  Perl regretted it.  PHP is still regreting it as they struggle with their new namespaces.  Every C programmer which writes a header file regrets it.  Lua is just now starting to regret it as they hack further and further around the limitation.

<p>So maybe its not so obvious.  Maybe we need a list.  A list of early decisions which all language designers will eventually regret.  And take it from the Perl programmers... we know.  Oh god we know.

<p>I'll start with the obvious ones.  I'm no cross-language expert so my examples may be out of date or just plain wrong.

<ul>
<li>No namespaces.  (C, Lua, Javascript, early PHP, Perl 4)
<li>No way to include a file.  (Javascript, very early C)
<li>No lexical scope.  (PHP still screws this up I think)
</ul>

<p>And throw in some less obvious ones.

<ul>
<li>No anonymous functions. (Java and to a certain extent Python)
<li>Everything's an object... except for the built in data types. (Java, Perl 5)
<li>Treating IO as unimportant or no IO at all (C, Java, Javascript)
</ul>

<p>And some controversial ones.

<ul>
<li>Not requiring variable declarations.  (Perl 5)
</ul>

<p>Add your own!  Point out more violations!  Its fun!</p>


<hr/>



<h2>static typing</h2>
<h3><a href="/user/mary.poppins/">mary.poppins</a> on 2005-04-09T00:08:52</h3>
Here's another controversial one:<br> <br>
&nbsp; &nbsp; Static typing without type inference<br> <br>If you're going to make a new language, please make a type-inferring version of C.  kthxbye



<blockquote>

<h2>Re:static typing</h2>
<h3><a href="/user/schwern/">schwern</a> on 2005-04-09T01:22:47</h3>
Could you give an example of a language which avoids this regret?



<blockquote>

<h2>Re:static typing</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2005-04-09T02:25:47</h3>
Haskell's static typing does pretty good inferencing.<blockquote><div> <tt>$ ghci<br>Prelude&gt; let sq x = x * x<br>Prelude&gt;<nobr> <wbr></nobr>:type sq<br>sq<nobr> <wbr></nobr>:: forall a. (Num a) =&gt; a -&gt; a</tt> </div></blockquote>That is, the function <code>sq</code> is defined for all values <code>a</code>, such that <code>a</code> is an instance of the type class <code>Num</code>.  Remember, Haskell is strongly typed, and this function is defined on all kinds of numbers (machine integers, bignums, floats, doubles, complex, etc.).  Furthermore, it <i>will</i> be defined on all types you define that are also instances of <code>Num</code>.
<p>
This is a contrived example, but it does demonstrate type inference.  That is, it avoids the Java problem where a function like <code>sq</code> needs to be redefined for every numeric type you want to square (primitive numbers and user defined numeric types).  All with a single definition.</p>



<h2>Re:static typing</h2>
<h3><a href="/user/mary.poppins/">mary.poppins</a> on 2005-04-09T02:43:41</h3>
Statically typed type-inferring languages include <a href="http://en.wikipedia.org/wiki/ML_programming_language" title="wikipedia.org">ML</a wikipedia.org> variants (<a href="http://en.wikipedia.org/wiki/SML_programming_language" title="wikipedia.org">SML</a wikipedia.org> and <a href="http://en.wikipedia.org/wiki/OCaml" title="wikipedia.org">OCaml</a wikipedia.org> being the most common), as well as <a href="http://en.wikipedia.org/wiki/Haskell_programming_language" title="wikipedia.org">Haskell</a wikipedia.org> and <a href="http://en.wikipedia.org/wiki/Clean_programming_language" title="wikipedia.org">Clean</a wikipedia.org>.<br> <br>All of these have entries posted at the <a href="http://shootout.alioth.debian.org/great/" title="debian.org">shootout</a debian.org>.<br> <br>None of these languages are suitable for low-level programming (kernels, databases, etc.), which is why we need a type-inferring version of something more like C.





</blockquote>

</blockquote>


<h2>Perl 4 had namespaces</h2>
<h3><a href="/user/brian_d_foy/">brian_d_foy</a> on 2005-04-09T01:08:10</h3>
Perl 4 had packages, which allowed pudge to write the D'oh module.<nobr> <wbr></nobr>:)



<blockquote>

<h2>Re:Perl 4 had namespaces</h2>
<h3><a href="/user/schwern/">schwern</a> on 2005-04-09T01:20:37</h3>
Oh yeah.  When did "package" get added?<br>





</blockquote>


<h2>Dynamic Features</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2005-04-09T02:47:55</h3>
You missed three key features:
<ul>
<li>No Closures (Tcl messes this up; I think Python does too...)</li>
<li>No eval (C, C++, Java; makes it much harder to do macros and code generation...)</li>
<li>No variable interpolation (<code>printf</code> is just soooo lame)</li>
</ul>
Now, with interpolation and eval, you can fake closures, but it's a royal PITA.  Here's the classic make_adder example in Perl:<blockquote><div> <tt>sub make_adder ($) {<br>&nbsp; &nbsp; &nbsp;my $i = shift;<br>&nbsp; &nbsp; &nbsp;return sub {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return shift() + $i;<br>&nbsp; &nbsp; &nbsp;}<br>}<br> <br>$add1 = make_adder (1);<br>print $add1-&gt;(2);&nbsp; ## 3</tt> </div></blockquote>Here's a simplistic translation in Tcl.  Procs aren't first class, but you can create new procs dynamically.  This code is broken, because Tcl has lexical variables, but no closures:<blockquote><div> <tt>proc make_adder {procname value} {<br>&nbsp; &nbsp; proc $procname {n} {<br>&nbsp; &nbsp; &nbsp; &nbsp; return [expr {$n + $value}]<br>&nbsp; &nbsp; }<br>}<br>make_adder add1 1<br>add1 2&nbsp; ## can't read "value": no such variable</tt> </div></blockquote>But you <i>can</i> work around that problem fairly easily with interpolation:<blockquote><div> <tt>proc make_adder {procname value} {<br>&nbsp; &nbsp; &nbsp;proc $procname {n} "return \[expr {\$n + $value}\]"<br>}<br>make_adder add1 1<br>add1 2</tt> </div></blockquote>It'd be a lot better if you could make an accumulator (i.e., true closures), but even without, you can still get a decent boost in power with dynamic code generation.

<p>

I'm still on the fence whether or not you absolutely need macros.  If you can construct classes, methods, and closures at runtime, you can fake it pretty well.  And you can even work around the lack of closures if you absolutely must.  But without all three of these features, you might as well be programming in C.

</p><p>
<small>
(Yeah, <code>[expr<nobr> <wbr></nobr>...]</code> is an wart in Tcl, but them's the breaks.)</small></p>



<blockquote>

<h2>Re:Dynamic Features</h2>
<h3><a href="/user/schwern/">schwern</a> on 2005-04-09T23:06:52</h3>
I think much of that can be summed up as "allow dynamic code generation" and "have code with some data attached".  And to be able to do these things easily.  Java, for example, limps along using pre-processors (IDEs, AspectJ,<nobr> <wbr></nobr>...) for the former and anonymous classes for the latter.<br>



<blockquote>

<h2>Re:Dynamic Features</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2005-04-10T19:36:10</h3>
Respectfully, no it's not.  You really do <i>need</i> closures.  Hey, it's 21st century -- get with the program!<nobr> <wbr></nobr>;-)
<p>
Reducing this down to "allow dynamic code generation" and "attach data to code" is a false economy in specification.  Once you have true closures (which imply lexical scoping), a whole new way to code is opened up for you.  Instead of writing ridiculously long classes to, say, find files, you can have small simple classes that are responsible for the algorithmic structure of finding files and nothing else -- selecting symlinks, directories, writable files, whatnot is all <i>your</i> responsibility to handle in a callback.
</p><p>
You can punt with eval if you don't have closures, but that's like using two liters of grain alcohol instead of a shot of novocaine before doing minor dental surgery.  Eval and interpolation turn that grain alcohol into something more palatable, like Irish Whiskey, but it's still fundementally the wrong solution.
</p><p>
Limping along with pre-processors and static code generators is still a bad problem.  You might as well be programming in C at that point.  That strategy recognizes the need for code that writes code, but ignores the fact that you really need to be alble to do that at runtime (like, when you need to construct a callback to <tt>File::Find</tt>, and maybe something with persistent state to select the first ten results).</p>



<blockquote>

<h2>Re:Dynamic Features</h2>
<h3><a href="/user/schwern/">schwern</a> on 2005-04-10T21:45:05</h3>
I think we're having a violent agreement.<br> <br>By changing the wording from "have closures" to "easily attach data to code" (with the implied "at runtime") I was attempting to restate the problem as a problem rather than as a solution.  Closures are a solution to the problem and you've layed out the problem quite well.  I would rather not assume that closures are the only way to do it.  Or eval.  Or pluggable functions (*foo = \&amp;bar).  Maybe there is a way to do it efficiently and concisely with anonymous classes, dunno.<br>



<blockquote>

<h2>Re:Dynamic Features</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2005-04-10T23:58:25</h3>
Hm.
<p>
As you stated the problem above, there are some design decisions that are fundementally wrong in language design today.  Like no namespaces, no way to include files, etc.
</p><p>
"No Closures" is as big a design flaw as "no anonymous functions", "no eval" and "no interpolation".  You can find all sorts of ways around that problem, but fundementally, there's no good reason to not have closures.  Rephrasing that, there's no defensible reason for asking your users to jump through hoops to achieve the same result (like Python's hackish way of using anonymous objects with a <tt>__getattr__</tt> method).
</p><p>
I think you're focusing on the impact rather than on the language feature.  Yet you started with a list of language features.
</p><p>
From what I've seen elsewhere, wiggling around the problem of closures by making the moral equivalent of a closure available is just as much of a problem.  Even Smalltalk has closures, even though they call them "anonymous blocks".  Whatever you call them, they're pretty much a requirement today.</p>



<h2>Re:Dynamic Features</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2005-04-12T18:26:47</h3>
Re-reading your comment, this stands out:
<blockquote><div> <i>
Maybe there is a way to do it efficiently and concisely with anonymous classes, dunno.
</i> </div></blockquote>
Anonymous classes are a form of closure.  It's how Java fakes closures in particular, and it's a cleaner solution for some problems.  (You <i>could</i> define anon classes with dynamic scoping rules a la Tcl, but why?)
<p>
The issues are very closely related, but not identical.
</p><p>
If you say no to closures and yes to anon classes, you're really saying <i>no jam!</i> and <i>more orange marmalade!</i></p>





</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Even more unbelievable</h2>
<h3><a href="/user/vsergu/">vsergu</a> on 2005-04-09T04:26:22</h3>
<b>No user-defined functions</b> -- ColdFusion, until version 5, I think. That's clearly more than enough to disqualify it as a real language,



<h2>include</h2>
<h3><a href="/user/pne/">pne</a> on 2005-04-09T05:53:51</h3>
I don't know... when I think about how to use functionality from several different pieces of code in C, I don't think of "include"; I think of a linker. Including another C source file in another strikes me as a bit odd.<br> <br>Though perhaps thinking static inclusion is not quite the same - Turbo Pascal had "uses foo, bar baz;" lines which were directives to the "linker" IIRC (though there was no stand-alone linker, I think; it was a compiler-and-linker all in one, so you couldn't link TP code to, say, C code, though the other way around worked).



<h2>Perl 6</h2>
<h3><a href="/user/malte/">malte</a> on 2005-04-09T12:16:40</h3>
<blockquote><div>
Everything's an object... except for the built in data types. (Java, Perl 5)
</div></blockquote>

<p>Doesn't Perl 6 make this mistake, too? (I'm thinking of the int Type)</p>

<p>I'm re-reading the Smalltalk 80 book (last time I read it was about 10 years ago). Its really amazing how much they were ahead in 1980 compared to the state of most languages in 2005</p>



<blockquote>

<h2>Re:Perl 6</h2>
<h3><a href="/user/schwern/">schwern</a> on 2005-04-09T21:18:23</h3>
<blockquote><div> <tt>Doesn't Perl 6 make this mistake, too? (I'm thinking of the int Type)</tt> </div></blockquote>Don't think so.  I sure hope not.  AFAIK Parrot doesn't make that assumption so there's no implementation reason why Perl 6 would.<blockquote><div> <tt>I'm re-reading the Smalltalk 80 book (last time I read it was about 10 years ago). Its really amazing how much they were ahead in 1980 compared to the state of most languages in 2005</tt> </div></blockquote>Surprise!  And people wonder why they should learn Smalltalk.  If more folks learned Smalltalk instead of C++ in the early 90s I think object-oriented programming would be a whole lot farther along now.  Fortunately, Matz did learn Smalltalk and thus we have Ruby.





</blockquote>


<h2>Re:</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2005-04-10T22:54:52</h3>
You can do <a href="http://www.netalive.org/swsu/archives/2004/11/namespaces_in_j.html" title="netalive.org">namespaces in Javascript</a netalive.org>. And there is no include in the language, because <code>&lt;script src="..."&gt; </code> does that for you. Javascript is actually a pretty nice language. I far prefer writing JS over PHP, even over Python (though not as decidedly).



<h2>iframe hacks</h2>
<h3><a href="/user/itub/">itub</a> on 2005-04-11T18:55:29</h3>
I decided to play a bit with iframes for emulating JavaScript includes and namespaces, as you can see in <a href="http://use.perl.org/user/itub/journal/24130" title="perl.org">my journal</a perl.org>.



<h2>No regexes, no decent string handling</h2>
<h3><a href="/user/roeland/">roeland</a> on 2005-04-14T08:59:15</h3>
<p>Anyone who's ever tried to do anything nearly useful with XSLT must have hit the same wall (no pun).</p>

<p>The very least you'd expect in a language is taking a substring at fixed position, and locating and optionally replacing a substring. But just how many C programs that do some form of string processing do you know that do <i>not</i> link against some regex library? Right.</p>



<h2>javascript as a general purpose language</h2>
<h3><a href="/user/spike0xff/">spike0xff</a> on 2005-08-04T01:13:04</h3>
So Michael...  Read a lot of your comments today on js, including the thread about 'include'.  Are programmers literal-minded or what? I've recently discovered javascript, and I am so charmed by its elegance as a language.  I'm an old Lisp fan, but a long-time C/C++ programmer, so... I'm writing a javascript-to-C++ translator.  For fun, and as a way to understand javascript.  The idea is to use the local C++ compiler as a backend, link to a JS runtime, and be able to get a native<nobr> <wbr></nobr>.exe (on Windows), so I can do tools and hacks in a language I like and respect.  Obviously I'll have to add an I/O system.  (I was thinking of something like stdio<nobr> <wbr></nobr>;-)
<br>
The Konfabulator <a href="http://www.konfabulator.com/info" title="konfabulator.com">http://www.konfabulator.com/info</a konfabulator.com> guys have an include function in their javascript dialect, and what looks like a very slick way to import COM objects.  So all in all, javascript seems to me (and I am just starting out) like a sweet way to cook up useful applications quickly.  Am I insane?





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

