<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of brian_d_foy: Comments make Perl unreadable, says Paul Graham</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Comments make Perl unreadable, says Paul Graham</h1>
<h2><a href="/user/brian_d_foy/">brian_d_foy</a> on 2004-12-19T20:54:30</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>I'm reading <a href=""><i>Hackers and Painters</i></a>, and as much as I enjoy the general idea of most of the essays, Paul Graham seems to pull certain things out of the ether for no apparent reason.<br/><br/>In the essay "Hackers and Painters" (<a href="http://www.paulgraham.com/hp.html">online version, slightly different</a>), he says:<br/><br/><blockquote>
Many a hacker has written a program only to find on returning to it six months later that he has no idea how it works. I know several people who've sworn off Perl after such experiences.
</blockquote><br/><br/>Fair enough.  The statement is reasonable even if the people it references aren't. Name a language and I'll tell you I know several people who've abandoned it. I know plenty of people who can't read their own handwriting.  So what.  Why pick on any one in particular he doesn't mention any other language in the essay?<br/><br/>There is a little end-note attached to it though.  I only quote the first sentence:<br/><br/><blockquote>
The way to make programs easy to read is not to stuff them with comments.
</blockquote><br/><br/>Okay, now I have no idea what he's talking about.  At first I figured someone wrote a bunch of code and that was that.  Why is he talking about comments?  If there were comments, and the authors wrote their own comments, what's the problem?<br/><br/>Still, this remark seems totally out of whack.  I don't think that Perl code needs comments more than any other code.  I can do wacky things in any language.  Indeed, the most heinous code I've seen  recently was a bit of Python.  So what. Next week it will be Java and the week after that Perl.  Tomorrow it might be some C code.  All of them can comment code. <br/><br/>I thought that the end note might actually belong to some other comment, but the online version and the dead-tree version both have it, although with different note numbers in each. Nope, that's what he meant to say.<br/><br/>I have a different view though:  programs are easy to read by judicious use of whitespace.  I don't care which language you use:  whitespace is the first thing that affects readability. <br/><br/>Comments aren't there to explain the mechanics, but to document the state of mind. So why is he elevating them to the top of the list of things to demonize in source code?  And how does Perl get to be the whipping boy?</p>


<hr/>



<h2>comments suck</h2>
<h3><a href="/user/jjohn/">jjohn</a> on 2004-12-19T21:44:26</h3>
<p>Strangely, I agree with Graham's point.  Sparse, on-point comments are wonderful.  Code that's too tricksy to grok should be rewritten.  From my own experience, I find that my perl vocabulary has shrunk while making the programs easier for me to pick up months later.  Also, debuggers work on code, not comments.  That's to say, a reader needs to grok the code not what the comments say about the code.  And the debugger is an excellent way to understand how the code really works.  I recall exploring both Tk and DBI using this technique.
</p><p>It's an obvious point, I know, but what I'm after is clean code that's only as complicated as it needs to be.  So while I'm not against commenting, I am against making a fetish of them.</p>



<blockquote>

<h2>Re:comments suck</h2>
<h3><a href="/user/Dom2/">Dom2</a> on 2004-12-19T22:04:46</h3>
I don't find anything wrong with large comments outlining intention.  What I (and I think Paul Graham) objects to is something like this:<blockquote><div> <tt>$a = $a + 1; # Add one to $a.</tt> </div></blockquote> <p>-Dom</p>



<blockquote>

<h2>Re:comments suck</h2>
<h3><a href="/user/Smylers/">Smylers</a> on 2004-12-20T00:14:17</h3>
<blockquote><div> <p>What I (and I think Paul Graham) objects to is something like this:</p> <blockquote><div> <tt>$a = $a + 1; # Add one to $a.</tt> </div></blockquote> </div></blockquote>

<p>I also agree with Graham, and I don't think that was quite what he had in mind, especially since he mentioned Perl, and the above type of commenting can crop up in any language.</p>

<p>One of the main reasons I love Perl is because of its expressiveness: the fact that the language is so malleable that you can craft the code to closely map to the underlying process that it's implementing.  And that's what I always try to do.</p>

<p>But there are other programmers who, for whatever reason, don't aim to do this; some are merely happy that their code runs at all and just go for the first thing that works.  This is where Perl's flexibility gives it a bad name (and hence gets cited in Graham's article): people carelessly
drifting towards a working program without being bothered by its form will probably end up with something that is convoluted, and hard to read.  This couldn't happen to anywhere near the same extent in a language such as Java, which is so rigid that multiple programmers write almost identical code to each other (that is, even the good programmers are restricted from writing code that is anywhere near as expressive as a carefully written Perl program would be).</p>

<p>At work I've had to add features to some Perl code that I've found incredibly hard to read.  Once I've finally grasped what the code is doing (and why) I feel I should put the knowledge to good use before it gets lost again.  One option is to put a comment in the code explaining it.</p>

<p>Another option is to re-arrange the code (&#8220;refactor&#8221;, if you like) so that it better reflects the underlying business logic.  That's always my preferred option (time permitting): why have hard-to-read code with a comment attached, when instead you can have code that's sufficiently clear it doesn't require a comment?</p>

<p>I believe that is the point Graham was making.</p>

<div>Smylers</div>





</blockquote>


<h2>Re:comments suck</h2>
<h3><a href="/user/brian_d_foy/">brian_d_foy</a> on 2004-12-20T03:54:14</h3>
Either point is fine, but I don't see how they are connected.  Unreadable Perl code and bad comments don't seem to support each other's validity.



<h2>Re:comments suck</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2004-12-20T05:23:32</h3>
<p> <em>Code that's too tricksy to grok should be rewritten.</em> </p>

<p>Sometimes code needs to be complicated.  Some tasks are tough and impossible to oversimplify and that can justify comments.  That being said, shoving that code into an appropriately named subroutine should make it easier.</p>

<p>However, there is one thing that code frequently cannot reveal and that is <em>why</em> something is being done.  Maybe it's easy to see that the clone of the customer object does not include their Social Security Number, but that doesn't tell you why.  Is it a bug, something to help protect privacy or just not bothering to clone unecessary fields?  Any of those reasons could be valid, but the code could be useless as a point of explanation.</p>





</blockquote>


<h2>comments and whipping</h2>
<h3><a href="/user/wickline/">wickline</a> on 2004-12-19T22:24:20</h3>
&gt; Comments aren't there to explain the mechanics,<br>&gt; but to document the state of mind.<br> <br>Agreed. However, not all folks use comments in that manner.<br> <br>If your code implements a diagonal proof at one point, Paul would probably be unopposed to a comment referencing what such a thing is (assuming that the expected maintainers of the code would not already know). In a mathematics department, the comment is probably uneccessary. If you found cause to use a diagonal proof in your flowchart layout generation code at a securities exchange firm, then the comment would probably be very appropriate.<br> <br>&gt; So why is he elevating them to the top of the list<br>&gt; of things to demonize in source code?<br> <br>I think Paul is talking about comments that are there to explain code which is not self-explanatory... code that needs to be explained because the author had these huge subroutines with opaque variable names and the latest tricks they picked up on the golf mailing list.<br> <br>Those authors use comments as an excuse to write opaque code. "As long as I have enough comments, I can implement this in any fashion I see fit. The maintianer can always follow my comments." If those authors were forced to maintian their own code without any comments, then they would likely start writting better code in the first place.<br> <br>&gt; And how does Perl get to be the whipping boy?<br> <br>Because Perl always gets to be the whipping boy when the subject matter is opaque code. No, it's not fair.<br> <br>-matt



<h2>Regexps and T-SQL</h2>
<h3><a href="/user/jplindstrom/">jplindstrom</a> on 2004-12-20T01:03:58</h3>
I have two opposing examples of languages that are more likely to need comments than others: regexps and T-SQL (Sybase/SQL Server). One is extremely terse, one is extremely verbose.<br> <br>Regexps are usually very compact and opaque. Your comment about whitespace is spot on, so<nobr> <wbr></nobr>/x should obviously be encouraged. But even with a sanely laid out regexp, the pattern of a regexp usually needs comments to indicate exactly what (\w+-\d) <i>means</i> in the context of a program. The regexp syntax itself doesn't allow us to do that. And coming back to a regexp a year later, I find it immensly useful to have a sample line of text of what the regexp is supposed to match.<br> <br>Stored procedure code in T-SQL on the other hand is ridiculously fluffy. The syntax requires you to express your ideas in so many lines of code that sometimes you need a comment on top of each code block in order to summarize what it does. Kind of what a descriptive method name does in a sane langauge. The verbose syntax actually obscures the meaning of the code because of the low semantic density (wow, new word!).<br> <br>When it comes to Perl, I find that using implicit $_ often obscures the code. Not using an explicit variable means a missed opportunity to self-document the code by naming the variable properly.<br> <br>The bad rap Perl gets is probably mostly due to:<br> <ul> <li>Special variables like $| . If you're not used to reading code with sigils, the special variables will totally throw you.<br></li> <li>Regexps. Which was inherited because they were so <i>useful</i>, but perhaps mostly intended for one-offs in shell script situations.<br></li> <li>The abundance of ugly {} when dereferencing references from sub routine calls.<br></li> </ul>



<blockquote>

<h2>Re: $_</h2>
<h3><a href="/user/Smylers/">Smylers</a> on 2004-12-20T10:00:45</h3>
<blockquote><div>When it comes to Perl, I find that using implicit $_ often obscures the code. Not using an explicit variable means a missed opportunity to self-document the code by naming the variable properly.</div></blockquote>

<p>I think the exact opposite.  <code>$_</code> <em>has</em> a meaning in Perl: &#8220;the current &#8216;thing&#8217; being operated on&#8221;.  That's a well-defined convention, and it has the advantage of being the same in every program.</p>

<p>In other languages when people want a temporary variable they often use <code>i</code> or <code>n</code> or <code>s</code>, but they aren't more readable than <code>$_</code>.</p>

<p>If you've got an <code>@server</code> array of objects, and perhaps a <code>$server_num</code> variable too, and you want to iterate over each server, you could call the iterator variable <code>$server</code>, but then you have several variables with very similar names.  Far better to use the form of <code>foreach</code> that doesn't explicitly name an iterator variable to avoid having to synthesize an artificial name, and use the standard name that Perl already provides.</p>

<div>Smylers</div>



<blockquote>

<h2>Re: $_</h2>
<h3><a href="/user/jplindstrom/">jplindstrom</a> on 2004-12-20T16:33:03</h3>
Using $i as a loop variable doesn't increase readability unless it is to communicate that "it's just a loop variable" and that's seldom the case since the Perl foreach is so much more useful than the C-style for loop.<br> <br>If the code block is very brief, like in<blockquote><div> <tt>dostuff($_) for(@servers);</tt> </div></blockquote>then I agree that it isn't necessary to alias it to a new name. But if the code block is longer than a few lines, it's indeed very useful to have an actual name connected to the entity you're dealing with.<br> <br>Consider the following piece of code:<blockquote><div> <tt>for ($oPost-&gt;aCommentLast($no)) {<br>&nbsp; &nbsp; sleepMinutes(rand(2));<br>
&nbsp; <br>&nbsp; &nbsp; my $oReplier = Snacks::Subscriber-&gt;oGetRandom;<br>&nbsp; &nbsp; my $oReply = Snacks::Message-&gt;new(<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oPoster =&gt; $oReplier,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oReplyTo =&gt; $oMessage,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text =&gt; $_-&gt;{text}<br>&nbsp; &nbsp; );<br>&nbsp; &nbsp; $oReply-&gt;send($oSender);<br>}</tt> </div></blockquote>Note how the <i>my $oReply</i> line doesn't stand alone since you have to backtrack to the loop to find out what $_ is.





</blockquote>

</blockquote>


<h2>Misleading Subject</h2>
<h3><a href="/user/shiflett/">shiflett</a> on 2004-12-20T01:47:34</h3>
<blockquote><div> <i>Comments make Perl unreadable, says Paul Graham</i> </div></blockquote>
<p>I'm not fond of seeing such misleading attributions. I'll try to give you the benefit of the doubt and assume that you actually think this is what he is saying, but I have a difficult time seeing how you (or anyone) can come to that conclusion.</p>
<p>If Paul had stated,</p>
<blockquote><div> <i>The way to get rid of the stench of spoiled food in an apartment is not to spray a bunch of air freshner.</i> </div></blockquote>
<p>Would it make sense to summarize it as follows?</p>
<blockquote><div> <i>Air freshner makes apartments stink, says Paul Graham</i> </div></blockquote>
<p>That is just poor logic.</p>



<blockquote>

<h2>Re:Misleading Subject</h2>
<h3><a href="/user/brian_d_foy/">brian_d_foy</a> on 2004-12-20T03:51:46</h3>
His comment is that Perl is unreadable, and the end note to support that says that comments are an abomination.  As I said in my post, I don't see how he connects the two.  Either statement is fine by itself, but not together: hence, the title.<br> <br>Indeed it is poor logic, but it is what he uses to support that Perl is unreadable.  I don't know why he connected those two.  What do you think it means when he connects those two things?



<blockquote>

<h2>Re:Misleading Subject</h2>
<h3><a href="/user/shiflett/">shiflett</a> on 2004-12-20T04:54:05</h3>
<blockquote><div> <i>His comment is that Perl is unreadable, and the end note to support that says that comments are an abomination.</i> </div></blockquote>
<p>I don't think that's what he's saying at all (neither point, in fact). His point is that comments don't guarantee programs that are "written for people to read, and only incidentally for machines to execute."</p>
<blockquote><div> <i>Indeed it is poor logic, but it is what he uses to support that Perl is unreadable.</i> </div></blockquote>
<p>I meant that your summary was poor logic. It's the classic logic problem. If A, then B. Does this mean if B, then A? How about if not B then not A?</p>
<p>In a footnote, he states, "The way to make programs easy to read is not to stuff them with comments." Regardless of whether you agree, clearly it is a logical fallacy to equate this statement with, "Comments make Perl unreadable." A logical conclusion would be, "Comments don't make programs readable." See the difference?</p>
<p>I also happen to think that Paul intends to be discussing programming as a craft, not programming languages.</p>



<blockquote>

<h2>Re:Misleading Subject</h2>
<h3><a href="/user/brian_d_foy/">brian_d_foy</a> on 2004-12-20T08:03:22</h3>
I understand logic so you don't need to explain it. I think Paul makes a leap in logic. That's my point.  That's what I discuss in the post, and that's why I chose the title.  It's ironic.  See the title in the context of the post.  It's not what he says, it's that he connects them.  It's very clear in the post that I don't know what he's actually trying to say.<br> <br>The two statements I pulled out do not connect with each other, but Paul specifically and on purpose connects them. He's using one to support the other. He's not talking about programming languages in general.  He's talking about Perl.  If he were talking about languages in general, he didn't have to single out one.<br> <br>Whatever he's saying is unclear, and it's only something he knows.





</blockquote>

</blockquote>

</blockquote>


<h2>Perl code needs more comments...</h2>
<h3><a href="/user/trachtenberga/">trachtenberga</a> on 2004-12-20T08:54:44</h3>
<blockquote><div>I don't think that Perl code needs comments more than any other code.</div></blockquote>

<p>This is where you're getting tripped up.<nobr> <wbr></nobr>:)</p>

<p>Here's my version of Graham's logic:</p>

<ol>
  <li>Lots of hackers write terse, fancy, etc. code that's hard to decipher when they come back to it 6 months later.</li>
  <li>The way to make your code easier to remember isn't by adding comments everywhere, but by reworking the code to be simpler and easier to understand.</li>
  <li>Perl is so fucking nasty that there's no way to do Step 2; therefore, so you're forced to add more comments than in other languages.</li>
</ol>

<p>I'm going to guess that you two disagree on the last point.<nobr> <wbr></nobr>:) I'm also going to guess that he'll say if it isn't obvious why Perl code is so fucking nasty then it's too late for you because you've already drank too much of the Perl kool-aid.</p>

<p>But it's hard to know for sure.</p>



<blockquote>

<h2>Re:Perl code needs more comments...</h2>
<h3><a href="/user/brian_d_foy/">brian_d_foy</a> on 2004-12-20T09:32:10</h3>
I guess that could be that point, even if I don't agree with it.<br> <br>As I've been thinking about this and trying to get into his mind, and I have the feeling he may be talking about people who tried Perl for a couple of days and then stopped.  Six months later  they can't remember anything from those two days.  That's not surprising.<br> <br>Or, he's talking about people who tried to understand somebody else's code and gave up after a couple of days.  Well, I have that problem with a lot of code no matter the language.<br> <br>Maybe I should just ask him what he meant.<br>





</blockquote>


<h2>Comments can't save bad code</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2004-12-21T04:02:36</h3>
Here's Paul's comment and footnote in their entirety:
<blockquote><div> <i>
You need to have empathy not just for your users, but for your readers. It's in your interest, because you'll be one of them. Many a hacker has written a program only to find on returning to it six months later that he has no idea how it works. I know several people who've sworn off Perl after such experiences. [7]
</i><p><i>
[7] The way to make programs easy to read is not to stuff them with comments. I would take Abelson and Sussman's quote a step further. Programming languages should be designed to express algorithms, and only incidentally to tell computers how to execute them. A good programming language ought to be better for explaining software than English. You should only need comments when there is some kind of kludge you need to warn readers about, just as on a road there are only arrows on parts with unexpectedly sharp curves.
</i></p> </div></blockquote>
Knowing Paul's background is as a lisp hacker, I would hazard a guess that the readers he's talking about are not people deeply steeped in Perl, but people who will dabble with Perl on occasion, and not get too deeply attached to any language other than Lisp.  From that perspective, Perl is a little befuddling, what with all of the special variables and contexts.  For example, it may make total sense to you today that <tt>$|++</tt> is the magic incantation to turn off output buffering, but six months from now, deleting that seemingly innocuous do-nothing assignment actually changes the behavior of the program in a way you would not have predicted.
<p>
Perl is like that, because Perl is optimized in different axes.  If you are comfortable with C, sh, awk, or other languages that are more popular than Lisp, the syntax will be somewhat comforting and easy to pick up.  If you spend enough time with it to consider yourself a Perl programmer (rather than a programmer who hacks on the odd Perl script now and again), the little idiosyncracies will be simple concise statements of purpose (like the difference between <tt>$count=@list</tt> vs. <tt>($first)=@list</tt>).
</p><p>
Perl is different in this respect.  It's not unique, because there are some dark corners in C++ that I wouldn't want to visit even if Aragorn and the entire army of Middle Earth was on my side leaving comments along the way as they prepared to battle the compiler.  And, no offense to John McCarthy, but Lisp only starts to make sense once you've drunk deeply from the magic bowl of Lambda flavored Kool-Aid and convinced yourself that the smell is much worse than the taste.

</p><p>

Add all that up and what do you get?  Comments won't save you, and if you're not interested in joining the church of Perl, you may need more comments than average to Perl's context and special variables straight in your head.</p>



<h2>Re:</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2004-12-21T20:46:27</h3>
<p>It thought what he was saying was quite clear, if pretty silly. He's saying that Perl tempts people to write confusing code, which they usually react to by adding comments to hopefully later remind themselves of their mental pirouettes.</p>

<p>To which I reply &#8220;You are correct, sir, but it's a poor craftsman who blames his tools.&#8221;</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

