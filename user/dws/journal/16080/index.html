<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of dws: Debugger as Drug</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Debugger as Drug</h1>
<h2><a href="/user/dws/">dws</a> on 2003-11-30T07:15:34</h2>
</div> <!-- /span4 -->


<div class="span8">
<p>Robert C. Martin <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=23476">weighs in on debuggers</a>:
<blockquote>
"I consider debuggers to be a drug -- an addiction. Programmers can get into the horrible habit of depending on the debugger instead of on their brain."
</blockquote>
Martin's essay reminded me of a
fellow I worked for briefly early in my career. He wrote one of the first personal computer database packages (and became rather wealthy as a consequence). When I asked him about his work habits and philosophy, he told me that he'd single-stepped through every instruction in the application at least once. He also said that he didn't see how anyone who called themselves a professional wouldn't do the same.
<p>
I've though about that occassionaly over the past few years, as I've noticed that I'm getting a lot done without ever reaching for a debugger. Taking small steps and writing lots of unit tests helps a lot, even when working with languages that don't have safe pointers and built-in garbage collection. Writing the tests first as a way to develop testable APIs shakes out a lot of silliness before it has a change to grow into one of those "what in the heck was I thinking?!?" moments.

</p>


<hr/>



<h2>Same here...</h2>
<h3><a href="/user/Adrian/">Adrian</a> on 2003-12-01T15:26:18</h3>
About the only time I drop into a debugger these days is to do some exploratory testing, or to play with somebody else's code.<br> <br>I've actually noticed a new pattern in my coding style since I started doing TDD. I delete the code I have just written when I unexpectedly fail a test without bothering to figure out what caused the bug - let alone dropping into a debugger. It's quicker to rewrite it correctly than it is to figure out what I did wrong<nobr> <wbr></nobr>:-)



<h2>Good analogy</h2>
<h3><a href="/user/merlyn/">merlyn</a> on 2003-12-01T16:31:17</h3>
I learned programming before debuggers became available.  My theory was "understand what you write, never outwrite ahead of your brain".  And when that failed, "add print until it works".
<p>
I never realized how much this influences my coding style until I was recently in front of 30 people at a client location, writing some complex code in real time for them.  I'd write three or four lines of code, run the program, then either rewrite those three or four lines if they didn't do what I expect, or I'd write three or four new lines if they did.
</p><p>
While this was "normal" for me (even before all this XP craze), it was pointed out to me about my "radical way of programming".
</p><p>
Maybe that's why I never understood why people spend all that time in debuggers.  I've never needed one.  I just don't outwrite my brain, and always have something to test after a few minutes more work.  If I need, I add YAML (formerly Data::Dumper) and dump a data structure that seems odd.
</p><p>
Of course, in the process, I build a lot of scaffolding that I later tear down, but that's no problem because my overall progress seems far faster than doing it the "hard" (to me) way.</p>



<blockquote>

<h2>Re:Good analogy</h2>
<h3><a href="/user/djberg96/">djberg96</a> on 2003-12-14T23:02:17</h3>
My counter to this would be that you're often debugging *someone else's* code, and that's where debuggers can be a lifesaver, or simply help you find a bug in someone's module on CPAN.
<p>
I sometimes use a debugger as a way to graphically represent complex data structures that I don't understand and I'm not sure how deeply nested they are (i.e. where print statements won't necessarily work).
</p><p>
But on the whole, yes, they can make you lazy.</p>



<h2>Re:Good analogy</h2>
<h3><a href="/user/jplindstrom/">jplindstrom</a> on 2003-12-16T18:18:44</h3>
I guess this small-steps way of doing things kind of requires a language like Perl where you essentially have no compilation step to prevent you  from seeing what you just did.<br> <br>In a way it resembles the way of writing HTML: write, save, switch to the browser and reload in a quick sequence.<br> <br>So using a language which takes longer to compile, like C++ in a lot of cases, breaks the cycle, forcing you to write more and more code to justify a compilation (thereby verifying that you didn't outwit yourself).<br>



<blockquote>

<h2>Re:Good analogy</h2>
<h3><a href="/user/dws/">dws</a> on 2003-12-17T00:16:01</h3>
Yeah, quick turnaround on the compile/link/run cycle is essential. I've been able to do Test Driven Development in Perl, Java, and now Python, but have thus far avoided the opportunity of trying it in C++.
<p>
It's amazing how comforting it is to know that if you find a problem, changes are really good that you caused it within the last few minutes, and that you only have to take one step back.</p>



<blockquote>

<h2>Re:Good analogy</h2>
<h3><a href="/user/jplindstrom/">jplindstrom</a> on 2003-12-17T21:34:40</h3>
Anyone with success stories of TDD in C++?<br> <br>I'm think I'm about to get involved in that in the near future, and I'd appreciate any practical tips and tricks.<br>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

