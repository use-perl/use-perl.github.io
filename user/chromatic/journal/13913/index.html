<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of chromatic: When is Simple Not Simple?</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>When is Simple Not Simple?</h1>
<h2><a href="/user/chromatic/">chromatic</a> on 2003-08-05T05:55:18</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p>I like when CPAN modules have simple interfaces.  I like to use shell aliases and will never give up the command line.  I like things that make my life easier.</p>

<p>If you want to make my life easier, do not make tools that require me to <em>write</em> XML to use them!</p>

<p>To help you remember this rule, I have written a simple song:</p>

<blockquote><p>when you find yourself hacking<br />
a tool you've been lacking<br />
you have one great choice to make</p>

<p>make it painless to write<br />
skimp docs, tests, and the like<br />
"to use it, just read the source code!"</p>

<p>or make it easy to use<br />
make a good API<br />
and remember the best rule of all</p>

<p>XML, XML, XML<br />
it's not for configuration files!<br />
XML, XML, XML<br />
hard to write! hard to read! angle braces!</p>

<p>"easy for me!" may be hard for your users<br />
so they'll curse your name in their frustration<br />
and wish for something like YAML</p>

<p>so work a little harder<br />
and write a smarter parser<br />
and everyone will think you're swell</p></blockquote>

<p>The moral of the story is, "Don't annoy a music major."</p></p>


<hr/>



<h2>No it's not!</h2>
<h3><a href="/user/mir/">mir</a> on 2003-08-05T07:46:08</h3>
<p>What do you mean XML is not for configuration files? See how elegant the <a href="http://xmltwig.com/talk/stop/img3.html" title="xmltwig.com">XML version</a xmltwig.com> is compared to the <a href="http://xmltwig.com/talk/stop/img4.html" title="xmltwig.com">YAML version</a xmltwig.com>? </p>
<p>The problem is that it is <b>really</b> hard to go from one to the other:</p>
<code>perl -MXML::Simple -MYAML -e'print Dump (XMLin( $ARGV[0]))' config.xml &gt; config.yaml</code>
<p>(modulo <a href="http://search.cpan.org/author/GRANTM/XML-Simple-2.08/lib/XML/Simple.pm#ForceArray" title="cpan.org">forcearray </a cpan.org> and other option problems of course)</p>
<p>;--)</p>



<h2>we could get together</h2>
<h3><a href="/user/hfb/">hfb</a> on 2003-08-05T07:51:21</h3>
<p>and write "CPAN: The fucking musical rant!", a musical spanning several hours and a finale of encrypted music though everyone in the audience would have the words....XML is the least of it<nobr> <wbr></nobr>:)</p>



<h2>&quot;Hard to read&quot;</h2>
<h3><a href="/user/Matts/">Matts</a> on 2003-08-05T11:38:00</h3>
Depends what you mean.<br> <br>XML is easy for a computer to read. And it's easy for a programmer to write an interface to.<br> <br>That's perhaps where the problem you perceive lies - it's almost too easy to punt and opt for XML rather than some custom config file.<br> <br>YAML kind of gets rid of that problem, but it brings along a bunch of other problems, such as lack of tools for languages other than Perl (especially C and Java), so we end up isolating ourselves from other programming communities. Yes, the YAML spec is open and anyone can implement a parser. But the Java and C parsers are still works in progress, and don't allow as easy access to the data as the XML libraries for those languages.<br> <br>Perl hackers complain far too much about XML. It's ironic really, given how hard to type perl code is (all those sigils). I don't dislike YAML. I just don't think it's the panacea that perl hackers have been convinced it is. And now I see even the perl core is opting for this non-standard data format (that we'll likely include a YAML parser in the perl core before we include an XML parser is just the dumbest thing ever).<br> <br>People who write apps that store their configs in XML should not be criticised - they're doing exactly what we want them to do - make their config files process-able by standard tools. That's no bad thing, and you shouldn't complain about it IMHO.



<blockquote>

<h2>Re:&quot;Hard to read&quot;</h2>
<h3><a href="/user/rafael/">rafael</a> on 2003-08-05T11:58:22</h3>
<i>And now I see even the perl core is opting for this non-standard data format</i> -- no, PAUSE is opting for it.
<p> <i>we'll likely include a YAML parser in the perl core before we include an XML parser</i> -- I don't think so. But consider that there's only one YAML parser, and multiple XML parsers : selecting one of them would probably produce endless wars.</p>



<blockquote>

<h2>Re:&quot;Hard to read&quot;</h2>
<h3><a href="/user/Matts/">Matts</a> on 2003-08-05T12:42:28</h3>
We in the Perl XML community already solved the "multiple XML parsers" war problem when it was last raised by the perl community. It's a dead argument now. Just install XML::SAX and be done with it.





</blockquote>


<h2>Re:&quot;Hard to read&quot;</h2>
<h3><a href="/user/jjohn/">jjohn</a> on 2003-08-05T16:52:24</h3>
<p> <i>XML is easy for a computer to read. And it's easy for a programmer to write an interface to.</i>

</p><p>If I recall correctly, XML was designed so that hyoo-mons could read it.  The "computer", that is to say programmers, can munch any digital data format you choose.  XML is still a bear to deal with.  Subclassing parsers or writing callbacks for event-driven parsing is not particularly straight-forward for many programmers.  This is not to suggest that I pine for the days of random ASCII formats (like YAML), but I don't think XML is as good as it can be.  XML is a good solution for data interchange and frankly, that's a huge win for many, many programmers.
</p><p>So, I guess my point is: let's keep looking for ways to represent data in a platform neutral-way.  (Sadly, I'm beginning to think that Comma Separated Value files might not have been so bad after all).</p>



<blockquote>

<h2>Re:&quot;Hard to read&quot;</h2>
<h3><a href="/user/Matts/">Matts</a> on 2003-08-05T17:06:53</h3>
I hear you on the event driven parsing front.<br> <br>I'm writing a pull parsing module for XML right now that gives you nodes that are the same as SAX2 nodes. Ultimately a pull parser is probably a better low level parser as it's easier to write an event driven parser on top of a pull parser than it is to do it the other way around.<br> <br>But all of this reminds me of Mirod's call to not use low level APIs to read XML. If you want to just access bits of an XML document there's an awesome syntax available to do that: XPath. Alternatively use XML::Simple. I'm not sure why people still revert to using XML::Parser (is it really just the name?)



<blockquote>

<h2>Re:&quot;Hard to read&quot;</h2>
<h3><a href="/user/koschei/">koschei</a> on 2003-08-09T06:24:31</h3>
There's the name, and that the docs to XML::Parser don't say: "Go use XML::SAX. Use of XML::Parser is deprecated.".



<blockquote>

<h2>Re:&quot;Hard to read&quot;</h2>
<h3><a href="/user/Matts/">Matts</a> on 2003-08-09T13:04:23</h3>
They will in the next release<nobr> <wbr></nobr>:-)



<blockquote>

<h2>Re:&quot;Hard to read&quot;</h2>
<h3><a href="/user/koschei/">koschei</a> on 2003-08-09T13:10:20</h3>
Excellent. matts++





</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Re:&quot;Hard to read&quot;</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2003-08-05T17:13:26</h3>
<blockquote><div> <em>People who write apps that store their configs in XML should not be criticised - they're doing exactly what we want them to do - make their config files process-able by standard tools. That's no bad thing, and you shouldn't complain about it IMHO.</em> </div></blockquote>

<p>Expecting users to <strong>write</strong> configuration files in XML is wrong.  Maybe, someday, when usable XML authoring tools are widely distributed, the situation will change.  I do point out that user-hostile file formats such as that of <tt>sendmail.cf</tt> also needs a slightly-nicer front end so mere mortals can use it.</p>

<p>I'm fine with XML as an interoperability format between programs, where <em>users don't have to write it</em>.  If you want to use it as a serialization format, where <em>users don't have to write it</em>, that's also fine.</p>

<p>If the first thing a user has to do to use your tool is to write XML, you're being insufficiently lazy.  I'm all for standard tools, and XML gets points there, but making it easy for the computer at the expense of the user is the wrong approach.</p>



<blockquote>

<h2>Re:&quot;Hard to read&quot;</h2>
<h3><a href="/user/mir/">mir</a> on 2003-08-05T17:37:03</h3>
<p>Well, to be honest you don't have to write the XML by hand. Just create the data structure you want any way you want (through a dedicated GUI for example) and let XML::Simple dump it as XML. This also works for YAML, BTW.</p>



<h2>Re:&quot;Hard to read&quot;</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2003-08-07T17:17:22</h3>
<blockquote><div> <i>
Expecting users to write configuration files in XML is wrong.
</i> </div></blockquote>
Actually, I think your expectations here are wrong.  Or at least your POV.
<p>
One of the benefits to XML is its anglebrackety syntax.  Bemoan it all you want, but by the time XML came around, the world had lovingly embraced HTML.  For all of its warts, give someone a copy of Notepad.exe and they can start writing HTML.  And XML.  And perl.
</p><p>
What I think you're harping about is the data/document duality.  XML as originally envisioned is much easier to handle on the document side of the spectrum.  Things get nasty when you add all sorts of strictures (like those necessary in config files) and expect users to hand-code data structures for you.
</p><p>
Asking users to hand-code data structures in notepad or vi is the problem, not XML.  XML for data has gone one step backwards -- instead of creating grammars that can be forgiving and flexible, we're adopting the strictest of the strict XML vocabularies and processing them in the least liberal manner possible.  Whenever there's an error at the syntactic or the semantic level, things break, and they break hard.
</p><p>
We're back to sendmail.cf all over again, but with "standardized processing tools" to ease the pain.</p>





</blockquote>

</blockquote>


<h2>I could not agree less...</h2>
<h3><a href="/user/brianiac/">brianiac</a> on 2003-08-05T15:30:37</h3>
<p>I find XML to be quite readable, and much more friendly and powerful than most alternatives (though I have not played with YAML). Frankly, I find it amusing to see someone complaining about XML readability in a Perl forum.<nobr> <wbr></nobr><tt>;)</tt> </p>

<p>What really bothers me is learning <b>another</b> format, and installing <b>another</b> parser, for a grammar that turns out to have severe limitations, and eventually has to be changed or replaced.</p>

<p>Take Mozilla's search plugin syntax for example: a clone (apparently) of the syntax used by Apple Sherlock, it looks similar to XML, but is definitely not! "Attributes" (used to define delimiting sequences) cannot contain spaces or character entites, a significant problem for parsing web pages; plus, no language designation can be embedded in a file, so each plugin requires a separate configuration file for each available language. Mozilla's not-quite-HTML-not-quite-XML bookmarks file is also deeply irritating to work with.</p>

<p>(Don't get me wrong, I love Mozilla, but primarily for standards support (though they have yet to <i>completely</i> implement HTTP, HTML, XHTML, or CSS2), so it bothers me more when it eschews standards (especially ones already implemented in it, like XML) in favor of strange proprietary stuff.)</p>

<p>If it turns out I am in the minority, and XML is simply too darn hard to puzzle out for most (though it <i>was</i> specifically engineered to be human-readable), perhaps the best solution is for programmers to provide a configuration screen or config generator utility, leaving their choice of back-end to the best <i>technical</i> fit.</p>



<blockquote>

<h2>Utilities!  Yes!</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2003-08-05T19:13:38</h3>
<p>Yep, that's the best solution.  As long as it's possible to configure the program without writing or editing a difficult file format, I'm reasonably happy.</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

