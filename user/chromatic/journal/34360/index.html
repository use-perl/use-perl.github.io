<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of chromatic: Why is this Myth Still Pervasive?</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Why is this Myth Still Pervasive?</h1>
<h2><a href="/user/chromatic/">chromatic</a> on 2007-09-06T00:59:24</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><blockquote><p><em>What I have found irritating about Perl is its TOTAL LACK OF READABILITY.... If you want proof, look at this:</em></p>

<pre>my $msg = " spacey string ";
$msg =~ s/^\s+//;
$msg =~ s/\s+$//;</pre></em></blockquote>

<p><em>... I see a totally random series of symbols, as if a kid was writing something in 1337.</em></p>

<p>&mdash; <a href="http://omegalphasblog.blogspot.com/2007/09/perl-versus-python-eternal-battle.html">Perl versus Python: The eternal battle</a></p>

<p>In a government course, I put together a phone survey where the querents asked people randomly selected from the phone book their opinion on made-up issues.  We invented plausible but fictional decisions of the local government and pretended that they were true.</p>

<p>Thanks to the Internet, I no longer have to go to that much work to find ignorant opinions from people who've done no research.  Also, English is <em>impossible</em> to read if you don't know the definition of the word "querent" in the previous paragraph.  QED.</p></p>


<hr/>



<h2>You are an idiot</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-06T01:45:15</h3>
<p>Just look at it:</p> <p><blockquote> <div><tt>msg = ' spacey string ';<br>msg.replace(r'^\s+', '');<br>msg.replace(r'\s+$', '');</tt></div> </blockquote>  <p>That&#8217;s clearly orders of magnitude easier to read than the Perl version.</p>



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-06T01:49:17</h3>
<p>Oh wait, it has to be this:</p> <p><blockquote> <div><tt>msg = ' spacey string ';<br>msg = msg.replace(r'^\s+', '');<br>msg = msg.replace(r'\s+$', '');</tt></div> </blockquote>  <p>Or possibly chain the methods.</p> <p><blockquote> <div><tt>msg = ' spacey string ';<br>msg = msg.replace(r'^\s+', '').replace(r'\s+$', '');</tt></div> </blockquote>  <p>Perl can&#8217;t hold a candle to any of that.</p>



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/pudge/">pudge</a> on 2007-09-06T02:17:34</h3>
Wow<nobr> <wbr></nobr>... I've seen many complaints about lack of readability, but this has to be the dumbest one (not yours, of course, the original).  Just wow.<br><br>



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/pudge/">pudge</a> on 2007-09-06T02:23:30</h3>
BTW, the "blogger" is apparently only 15, acc. to his profile.  After reading the rest of his post I figured he was a dumb kid.  So he is.<br><br>Sometimes I worry that the chorus of "Perl, in a Nutshell" will damage Perl's reputation ("it's so easy to write, but it's not always easy to read").  Then I think, if only I could be so lucky!<br><br>



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/mr.bambers/">mr.bambers</a> on 2007-09-06T04:07:20</h3>
As a new Perl programmer, and (I will disclaim now) having never written any PHP, I'd like to point out that no computer language has intrinsic "readability". Do you remember your first time ploughing through "Learning Perl"'s 'A Stroll Through Perl'?<br><br>No programming language is readable until someone invents a programming language that reads like a native language. Think Pseudo-code, and THAT is readable (or at least you'll get the idea...) However, no-one has made a REAL language like that. Yet.<br><br>I've been told by a Perl programmer that adding comments to Perl is "not the done thing" and is (apparently) unconventional. However, if there are comments it's readable. If there are none, it's difficult to read without having a good understanding and some patience.<br><br>If I post a piece of sheet music and you can't sight-read, would you find it readable? I can read music, but it takes me 30 minutes to translate a page. I can READ it, but it's not READABLE...<br><br>(Thank you for the chance to rant with my first post... I might be more constructive next time...<nobr> <wbr></nobr>:~);<br><br>



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/pudge/">pudge</a> on 2007-09-06T04:32:40</h3>
I agree with much of what you say, but some quibbles:<p><div class="quote">No programming language is readable until someone invents a programming language that reads like a native language.</div> I don't accept that: I am fluent in Perl.  It is nearly as a native language to me.  I'd say no programming language -- or any language -- is readable to a person until they, simply, learn that language.<p><div class="quote">I've been told by a Perl programmer that adding comments to Perl is "not the done thing" and is (apparently) unconventional. However, if there are comments it's readable. If there are none, it's difficult to read without having a good understanding and some patience.</div> I wonder if perhaps you misunderstood slightly.  I've never heard someone say that comments are not done if they are needed; the goal, however, is to make it so that your code is self-explanatory (to someone who knows Perl, of course).  If I write this:<p><blockquote> <div><tt>print "Perl";</tt></div> </blockquote> that obviously needs no comment.  However, this code, that produces the same output, is much harder to read, even for a Perl programmer:<p><blockquote> <div><tt>vec($str,&nbsp; 1, 32) = 0x5065726C;<br>print $str;</tt></div> </blockquote> The latter needs comments, the former does not.  And that's what many people mean when they say "don't comment": write code that doesn't need comments.  Use variable and subroutine names and data structures and so on that are self-explanatory for Perl-speakers.  And if it needs explanation, for you or someone else, either to know how the code works or what its purpose is, then by all means, comment!<br>



<h2>Re:You are an idiot</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2007-09-06T04:56:37</h3>
<p><blockquote> <div><em>No programming language is readable until someone invents a programming language that reads like a native language.</em></div> </blockquote>

<p>I'm not sure that's even possible, at least for any interesting problems.  It's not that interesting to discuss the abstract relative readability of programming languages; syntax is just one particular expression of the semantics of the solution to a problem.  You have to understand the problem and the semantics of a problem as well, and once you start talking along those lines, you have to bring in the principle of the conservation of complexity.</p>

<p>Suddenly syntax isn't as abstract, or important.  As Paul Hummer says, <a href="http://theironlion.net/blog/syntax-vs-semantics/" title="theironlion.net">You simply <em>cannot</em> become an expert in Scheme by becoming an expert in its syntax. That's not where the power is.</a theironlion.net> </p>



<h2>You obviously have a lot to learn</h2>
<h3><a href="/user/btilly/">btilly</a> on 2007-09-06T12:06:58</h3>
I would suggest starting with <a href="http://www.amazon.com/Code-Complete-Second-Steve-McConnell/dp/0735619670" title="amazon.com">Code Complete 2</a amazon.com> to fill in the gaps.<br><br>After that you'll understand things like the inherent tradeoffs in commenting.  It isn't as simple as "comments aren't done."  And it isn't as simple as "comments make things readable."  Instead it is much closer to, "comments are helpful but untrustworthy."  Which is why there is a big emphasis on making your code (which can be trusted much more since errors there get noticed and fixed) read as much like comments as possible.  (Much easier said than done!)<br><br>After you've come to understand principles like that, you'll be able to appreciate why pseudocode is not inherently more (or less) readable than a computer language, and making a computer language that reads like a native one does not suddenly make it easy to program.  (The first language to try that approach was COBOL almost 50 years ago.  There is a reason that modern computer languages are not marketed on the basis of being easy for your manager to read...)  If you're lucky, you'll also be on your way to seeing how readability is an interaction between text and the reader, and how to use this to deliberately write code that is pitched to a specific type of reader.<br><br>And you'll be a better programmer.  In any language you try to program in.



<blockquote>

<h2>Re:You obviously have a lot to learn</h2>
<h3><a href="/user/mr.bambers/">mr.bambers</a> on 2007-09-06T19:17:00</h3>
I do have a lot to learn, and your comments and observations about this are most welcome. I'll check out Code Complete 2 (aaah... expensing is awesome) and will soldier on with the learning.<br><br>My original comments came from the fact I do black box testing at work, and have recently started to approach the source code. One way I find comments helpful is when they describe what the following function is supposed to do. If I just read through the function (slowly...<nobr> <wbr></nobr>:~) and figure it out I can see what it does. I can't tell if that's what it's supposed to be doing though, and I don't usually have a programmer there to ask.<br><br>Of course, given time I hope I'll find code as readable as you all. Right now it's a barely readable black box (to me) but wish me luck and I'll be around.<br><br>And thank you btilly, chromatic and pudge for your comments and direction!



<blockquote>

<h2>Re:You obviously have a lot to learn</h2>
<h3><a href="/user/btilly/">btilly</a> on 2007-09-06T21:35:15</h3>
One of my favorite comments on commenting is <i>I find the most useful comments state what remains invariant, while the code states what gets transformed.</i>  (From <a href="http://www.perlmonks.org/?node_id=52788" title="perlmonks.org">this post</a perlmonks.org>.)<br><br>The explicit or implicit API presented by a function should not (lightly) be changed.  Therefore it is often worthwhile to comment on that.  And it is always worthwhile to pick a function name that tells you what it means.  However the mechanics of how the function works internally should not generally be commented.<br><br>That said, there isn't any magic by which good programmers become magically able to find any code readable.  You can probably improve quite a bit from where you are, but there are definite limits.  For instance spaghetti is not particularly readable by anyone, and everyone gets slowed by it.  Plus with any significant codebase, productivity strongly depends on how well you know your way around it.  Being able to find what you want is partly a question of being able to read the code, and partly a question of being able to figure out what code to read.  Memory plays a definite role in that process.<br><br>So even after you've learned to program well, you'll still have to accept that code will not always be easy for you to read.<br><br>That said, the value of <i>good</i> code is that good programmers can become extremely productive with it.  They can understand it more easily, make changes faster, the changes are more likely to be correct, and there are fewer unexpected interactions between different parts of the code.  Bad programmers also benefit from good code, but they just don't benefit as much, and their changes tend to reduce the quality of the code.



<blockquote>

<h2>Re:You obviously have a lot to learn</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2007-09-07T06:27:32</h3>
<p><blockquote> <div><em>Plus with any significant codebase, productivity strongly depends on how well you know your way around it.</em></div> </blockquote>

<p>Also very important is your knowledge of the problem domain.</p>





</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Re:You are an idiot</h2>
<h3><a href="/user/stvn_skuo/">stvn_skuo</a> on 2007-09-06T07:07:33</h3>
<p><div class="quote">Perl can&#8217;t hold a candle to any of that.</div>  <br>
But perl6 might...
<br>
<a href="http://xrl.us/ftqq" title="xrl.us">http://xrl.us/ftqq</a xrl.us>
<br>
<a href="http://xrl.us/5obh" title="xrl.us">http://xrl.us/5obh</a xrl.us>
<br> <br>
In Python that can be written as:
<br>
<code>
msg = msg.strip()
</code>



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-06T12:11:49</h3>
<p>I expected that. Of course, until I read the documentation, I don&#8217;t actually have any idea about what <code>strip</code> does.</p>



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/sigzero/">sigzero</a> on 2007-09-06T18:42:24</h3>
The Python version removes spaces from both sides of the text. Just create that in a sub{} in Perl and be done with it.  : )



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-06T18:56:32</h3>
<p>I know. I&#8217;m saying that if I see <code>msg.strip()</code> in a random piece of Python code, and I&#8217;ve never seen the documentation of <code>strip</code>, then I don&#8217;t know what it does, any more than I know what the Perl code does if I&#8217;ve never read the documentation.</p>



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2007-09-06T19:54:36</h3>
<p>You're absolutely right.  I wish more people realized that.</p>





</blockquote>

</blockquote>

</blockquote>


<h2>Re:You are an idiot</h2>
<h3><a href="/user/ferreira/">ferreira</a> on 2007-09-06T13:32:33</h3>
<p><div class="quote">In Python that can be written as:
<br>
<code>
msg = msg.strip()
</code> </div> Hey, but that's nearly impossible to write in Perl. Let me see:<p><blockquote> <div><tt># in-place version<br>sub strip { s/^\s+//; s/\s+$//; }<br># which would be used as<br>strip($msg);</tt></div> </blockquote>



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-06T14:49:30</h3>
<p>That won&#8217;t quite work. Make it</p> <p><blockquote> <div><tt>sub strip { $_[0] =~ s/^\s+//; $_[0] =~ s/\s+$//; }</tt></div> </blockquote>  <p>or maybe</p> <p><blockquote> <div><tt>sub strip { s/^\s+//, s/\s+$// for $_[0] }</tt></div> </blockquote>



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/sigzero/">sigzero</a> on 2007-09-06T19:12:59</h3>
use strict;<br>use warnings;<br><br>my $string = "  This is the test    ";<br><br>sub trim {<br>
&nbsp; &nbsp; &nbsp; &nbsp; my $a = $_[0];<br>
&nbsp; &nbsp; &nbsp; &nbsp; $a = join(" ", split(" ", $a));<br>
&nbsp; &nbsp; &nbsp; &nbsp; return $a;<br>}<br><br>my $nstring = trim($string);<br><br>print "$string\n";<br>print "$nstring\n";<br><br>I don't think it takes every case...but it works with the "test" string.



<h2>Re:You are an idiot</h2>
<h3><a href="/user/btilly/">btilly</a> on 2007-09-06T21:43:14</h3>
The latter version can be generalized to:<br><br><code>sub strip { s/^\s+//, s/\s+$// for @_ }</code><br><br>However I don't like the idea of modifying arguments in place.  Functions that do that violate my expectations.  Instead I'd make a copy and return the copy.  Like this:<br><br><code>sub strip {<br>
&nbsp; &nbsp; return map strip($_), @_ unless 1 == @_;<br><br>
&nbsp; &nbsp; my $x = shift;<br>
&nbsp; &nbsp; $x =~ s/^\s+//;<br>
&nbsp; &nbsp; $x =~ s/\s+$//;<br>
&nbsp; &nbsp; return $x;<br>}</code>



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-06T21:53:00</h3>
<p>The latter took me a while to read. I&#8217;m not used to recursion so casually&#8230; and it seems to me that deliberately creating opportunities to get the termination condition wrong is an unnecessary source of bugs.</p>

<p>I agree though that returning a copy is better; I wrote my code that way only because was correcting the example code.</p>

<p>Personally I&#8217;d write it like this:</p> <p><blockquote> <div><tt>sub strip {<br>&nbsp; &nbsp; my @stripped = @_;<br>&nbsp; &nbsp; s/^\s+//, s/\s+$// for @stripped;<br>&nbsp; &nbsp; return @stripped;<br>}</tt></div> </blockquote>  <p>On a related tangent, I&#8217;ve often wished for a variant of <code>s///</code> that modifies a copy of the string and returns that.</p>



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/btilly/">btilly</a> on 2007-09-06T22:22:43</h3>
There is a subtle but significant difference between the two versions that shows up if someone writes <code>my $bar = strip($foo);</code>  Your code will return 1 in that case, while mine returns $foo stripped appropriately.<p>

To fix that you would need to check wantarray.  Or you could return <code>@_[0..$#_]</code> instead.</p><p>

Personally I have a lot of utility functions that usually accept one value, but sometimes accepts a list and returns a list.  I find it annoying to add the loop and the wantarray check to each one.  And I find that I always am passing in only one value when I want to return one value.  It is not <i>quite</i> as good if you're paranoid, but the assumption works for me.  So for me <code>return map function($_), @_ unless 1 == @_;</code> has become an idiom.  I just stick that in, then write the case for a single argument.  At a glance I know that it will handle one argument or many, and the logic of what it does is not obscured by the mechanics of the loop.</p>



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-06T23:30:33</h3>
<p>I see the points, but I still don&#8217;t like the idiom. It has several moving parts that have to be arranged just so, and you have to read carefully to trace its self-interaction to understand what is really going on.</p>

<p>I prefer to write simpleton code. I also prefer to avoid conditionals for the same reason, so I&#8217;d use <code>@_[0..$#_]</code> over <code>wantarray</code>. All told, for a general-case idiom I&#8217;d settle on this:</p> <p><blockquote> <div><tt>sub foo {<br>&nbsp; &nbsp; for ( @_ = @_ ) {<br>&nbsp; &nbsp; &nbsp; &nbsp; #<nobr> <wbr></nobr>...<br>&nbsp; &nbsp; &nbsp; &nbsp; # mutate the iterator here<br>&nbsp; &nbsp; &nbsp; &nbsp; #<nobr> <wbr></nobr>...<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return @_[ 0<nobr> <wbr></nobr>.. $#_ ];<br>}</tt></div> </blockquote>  <p>This is straight code, IMO. There is very little going on here on a conceptual level. I wouldn&#8217;t have any trouble with reading this, nor with re-deriving it on the spot. (As a fringe benefit, this structure is more efficient too &#8211; a correlation that seems frequent. But I&#8217;ll pick dumb over efficient by default in those cases where they are in antagonism.)</p>

<p>I don&#8217;t think the loop really gets in the way there, other than increasing the indentation level once.</p>



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/runrig/">runrig</a> on 2007-09-07T00:07:54</h3>
I'm too dumb to remember what the difference between <code>@_</code> and <code>@_[0..$#_]</code> is (and I'd guess others are also), so MHO is that wantarray would be preferable. I like btilly's way also, though it does make more function calls when run on a list. And on a side note, I also find the title of this thread amusing<nobr> <wbr></nobr>:-)



<h2>Re:You are an idiot</h2>
<h3><a href="/user/btilly/">btilly</a> on 2007-09-07T02:57:17</h3>
A lot of this is personal taste.  All solutions are ugly.  Yours involves an extra level of indentation, assignment in the for loop declaration (normally a red flag), and the subtle return construct.<br><br>I'll note that efficiency depends on your use case.  My approach is more efficient for the single argument case.  Yours is more efficient for the list case.  (More efficient than either of our versions is to make your return depend on a call to wantarray.)<br><br>Anyways there was a period where I had to write a bunch of these.  And adding one line per just worked out to be easier for me than adding several lines and adding another layer of indentation.



<blockquote>

<h2>Re:You are an idiot</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-07T03:22:50</h3>
<p>Well, I&#8217;ve <em>actually</em> written <a href="http://search.cpan.org/perldoc?Sub::ArgShortcut" title="cpan.org">a module to deal with that sort of thing</a cpan.org>, so&#8230;</p>





</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>

</blockquote>


<h2>Eternally...</h2>
<h3><a href="/user/brian_d_foy/">brian_d_foy</a> on 2007-09-06T02:48:51</h3>
September. Literally even!



<h2>It does get old...</h2>
<h3><a href="/user/sigzero/">sigzero</a> on 2007-09-06T12:13:29</h3>
There was another post about "readability" that I read this morning. I usually just post that it isn't Perl's fault that the code it hard to read it is the programmers fault/choice.



<h2>It's gone</h2>
<h3><a href="/user/petdance/">petdance</a> on 2007-09-06T22:48:29</h3>
His entire blog is now gone.<br><br>Here's what he originally posted:<br><br>-------<br><br>Perl vs. Python. 2 interpreted languages, whose purpose is to prevent you from writing C/C++ code. Programmers have argued for years on which is better, and many fanboys have been seen swearing at each other for no real reason. I'm here to say which is (IMHO) the better. To discover that, we must first see what those languages are meant to do for the average programmer.<br><br>C and C++ are undoubtedly the best programming languages out there in terms of speed, power, size of community, portability and usefulness. However, over the years it became clear what was the problem with them. In the many articles I have read, C++<br>programmers hate 2 things about their language of choice (mostly):<br>1)Having to write their own memory management.<br>2)The lack of readability.<br>Interpreted languages deal with both issues and that's why they're famous. It's much easier for the average programmer to write a random, not speed-requiring application with them.<br>Personally, I don't know C++, but I will someday for sure.<br><br>I have also read many articles conserning Perl, most writers found that it is very hard to write large applications (1000+ lines) with Perl. That's because of Perl's 'crazy' philosophy on doing things as they say. Now, I don't Perl either, but I DO have noticed its philosophy is strange. That's not the main problem for me, however.<br><br>What I have found irritating about Perl is its TOTAL LACK OF READABILITY. The winner of obfuscated C contest can surely write a more readable C program that a normal Perl programmer can write in Perl. If you want proof, look at this:<br><br><code><br>my $msg = " spacey string ";<br>$msg =~ s/^\s+//;<br>$msg =~ s/\s+$//;<br></code><br><br>Its purpose is to remove the spaces from the left and right of the string. Forgeting what the program's purpose is, forgeting even in what language it is writen in, what do you see? I see a totally random series of symbols, as if a kid was writing something in 1337. It reminds of an anonymous enterance in Obfuscated C Contest that used '-'-'-' to write zero and '/'/'/' to write one, but even that is more readable than THIS MONSTER I have before me.<br><br>I seriously think that Perl is overrated.<br><br>Next time I'm gonna check on Ruby. I have heard a lot of great stuff about it, so my expectations are high<nobr> <wbr></nobr>:).



<blockquote>

<h2>Re:It's gone</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2007-09-07T06:25:39</h3>
<p><blockquote> <div><em>His entire blog is now gone.</em></div> </blockquote>

<p>Whoa.  I took a 15 year old off of the Internet.  I'm sort of proud and sort of not.</p>



<blockquote>

<h2>Re:It's gone</h2>
<h3><a href="/user/petdance/">petdance</a> on 2007-09-07T06:36:46</h3>
I posted a more welcoming comment, posting equivalent code in C and pointing out that the Perl code was much easier to read, once you understood it, and that brain cycles were better spent working on the programming problem than the specifics of how to remove spaces from a string.  I invited him to look into Perl some more before writing it off.<br/><br/>I was hoping it might do some good.





</blockquote>

</blockquote>


<h2>You call that a spacey string?</h2>
<h3><a href="/user/bart/">bart</a> on 2007-09-07T10:30:51</h3>
<em>This</em> is <p><blockquote> <div><tt>"&nbsp; &nbsp;a&nbsp; &nbsp; &nbsp; spacey&nbsp; &nbsp; &nbsp; string&nbsp; &nbsp; "</tt></div> </blockquote> It's easy to quibble about readability with trivivial examples. But a "readable" language often implies "limited in power" too. So how would you solve the same problem with the added requirement that multiple spaces should be squashed into a single space? In Perl it's easy: you just have to add the additional statement:<p><blockquote> <div><tt>tr/<nobr> <wbr></nobr>//s;</tt></div> </blockquote> or<p><blockquote> <div><tt>s/\s+/<nobr> <wbr></nobr>/g;</tt></div> </blockquote> (Too bad <code>tr</code> doesn't recognize the <code>\s</code> meta character class.)
<p>So how do you tackle that in a readable language like Python? I don't know enough Python, let's stick to something I do know: PL/SQL, the (Ada-based) language Oracle includes in its databases:</p><p><blockquote> <div><tt>function normalize_spaces(s in varchar2) return varchar2 is<br>&nbsp; r varchar2(32000);<br>begin<br>&nbsp; r<nobr> <wbr></nobr>:= trim(s);<br>&nbsp; while(instr(r, '&nbsp; ') &gt; 0) loop<br>&nbsp; &nbsp; r<nobr> <wbr></nobr>:= replace(r, '&nbsp; ', ' ');<br>&nbsp; end loop;<br>&nbsp; return r;<br>end;</tt></div> </blockquote> That's what "readability" buys you: a requirement for a lot of extra, very low level code. <i>But, it least it's "readable"!</i>
<p>I wouldn't be too surprised that in general, Python makes you jump through the same hoops, as Guido is notorious for ripping out features out of the language he considers too advanced.
</p><p>p.s. I like Javascript, and their solution really appeals to me:</p><p><blockquote> <div><tt>function normalize_space(s) {<br>&nbsp; return s.replace(/^\s+/, '').replace(/\s+$/, '').replace(/\s+/g, ' ');<br>}</tt></div> </blockquote> I really like chaining in this way. Much better than the nesting of procedural function calls that you have to write backwards &mdash; the last function to call is the first one you read in the source. And Javascript knows first class regular expressions (which are like qr// objects in Perl).





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

