<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of chromatic: Perl 6 Design Minutes for 28 May 2008</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Perl 6 Design Minutes for 28 May 2008</h1>
<h2><a href="/user/chromatic/">chromatic</a> on 2008-06-05T00:23:07</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p>The Perl 6 design team met by phone on 28 May 2008.  Larry, Allison,
Patrick, Jerry, and chromatic attended.</p>

<p><strong>Larry:</strong></p>

<ul>
<li>mostly off for this long weekend elsewhere</li>
<li>continuing to work on quoting roles</li>
<li>they need generic support to mix in roles with parameterized strings as starter and stopper sequences</li>
<li>that's an interesting problem, when mapped into Perl 5</li>
<li>no support for generic roles or parameterized types yet</li>
<li>I'll probably just do an <code>eval</code></li>
</ul>

<p><strong>Allison:</strong></p>

<ul>
<li>reworked continuations in Parrot, based on our discussion last week</li>
<li>I have very high regard for the value of reading through the commit logs</li>
<li>found the source of the problem that way</li>
<li>someone committed the problem about a year and a half ago</li>
<li>now continuations work the way they should work</li>
<li>we now don't try to make CPS respect the dynamic environment stack</li>
<li>it's largely unused now that we don't store exceptions there anymore</li>
<li>tracking down one last bug</li>
<li>I can duplicate it</li>
<li>it's an exception thrown, caught, and resumed from an <code>:onload</code> subroutine</li>
<li>looks like they get executed differently from regular execution</li>
<li>first draft of the Bylaws and Articles of Incorporation for the Parrot Foundation</li>
<li>hired a lawyer in Washington state for incorporation there</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>added quite a few things in the Rakudo implementation</li>
<li>added a new metamodel that looks like the Perl 6 metamodel</li>
<li>with Jonathan's and Jerry's and Moritz's help, we converted the compiler tools to that model</li>
<li>cleaned up some of the inheritance hierarchy in Rakudo</li>
<li>builtin types report correct methods and types</li>
<li>a Parrot Integer reports itself as an Int in Rakudo, down to the metaobject information</li>
<li>fixed pair handling, especially for calling functions</li>
<li>people are testing those in great detail now</li>
<li>now it's obvious that Rakudo's and Parrot's and Perl 6's argument handling there somewhat disagree</li>
<li>doing some PGE refactoring</li>
<li>primarily fixing up its class hierarchy; looks pretty easy</li>
<li>may move Rakudo's grammar to use protoregexes</li>
<li>might help get the metaoperators working -- French brackets, for example</li>
<li>if we don't get this soon, people might submit patches doing things the wrong way (multiplying new operators for various combinations)</li>
</ul>

<p><strong>Jerry:</strong></p>

<ul>
<li>Google Summer of Code started this week</li>
<li><a href="http://www.brokd.com/psoc08/">the aggregated feed of Perl GSoC 2008 student and mentor blogs</a> is available</li>
<li>the students will report weekly status at the <a href="http://www.parrotcode.org/misc/parrotsketch-logs/">#parrotsketch meeting</a></li>
<li>the students and mentors will report at <a href="http://irclog.perlgeek.de/perl6-soc/">#perl6-soc on irc.freenode.net</a> on Wednesdays at 18:30 UTC</li>
<li>all of the students seem to be on track now</li>
<li>made some spectest changes</li>
<li>made some changes to rakudo List methods, applied some patches</li>
<li>made some Rakudo test changes, should make test management easier and allowing us to create private and shared lists of tests we want to run</li>
<li>should make it simple for rakudo developers to specify a subset of test files, making focused development and focused testing easier</li>
</ul>

<p><strong>c:</strong></p>

<ul>
<li>not a lot of energy for hacking for some reason</li>
<li>applied a few patches</li>
<li>cleaned up a few tickets</li>
<li>talked with Andrew quite a bit yesterday about GC plans</li>
<li>he has some good ideas, including a clever marking scheme for which I have high hopes</li>
<li>mostly on the right track</li>
<li>will write up some guidelines on profiling and optimizing</li>
<li>have one idea to optimize keyed object attribute access</li>
<li>otherwise really need to work on the PIR profiler</li>
</ul>

<p><strong>Richard:</strong></p>

<ul>
<li>trying to plan a legitimate way to ascertain Perl 6 grants, given the donation from Ian Hague</li>
<li>planning a process around that</li>
<li>thinking about YAPC::NA and a grant process BOF</li>
</ul>

<p><strong>Allison:</strong></p>

<ul>
<li>Patrick mentioned argument passing in his report</li>
<li>we don't quite understand how it needs to work in Perl 6</li>
<li>Parrot will support whatever Perl 6 needs, though it may not necessarily be the default</li>
<li>one goal of argument passing is to make it lazy</li>
<li>you don't have to parse the whole list to start pulling out parameters</li>
<li>required parameter positionals are clear</li>
<li>required positional parameters are clear</li>
<li>you can pass in a required positional parameter as either a positional or named argument</li>
<li>Parrot maps the positional arguments to positional parameters</li>
<li>when it runs out of positional arguments, it starts checking named arguments</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>that's not really what Parrot does</li>
<li>Parrot fills positional parameters with positional arguments</li>
<li>then it fills in named parameters with positional arguments</li>
</ul>

<p><strong>Larry:</strong></p>

<ul>
<li>what do you mean when you say "named parameter"?</li>
</ul>

<p><strong>Allison:</strong></p>

<ul>
<li>pairs</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>all parameters are named in Perl 6</li>
<li>they can be filled by a named argument</li>
<li>Parrot has parameters that you can fill only by position</li>
<li>then there are parameters that you can fill by position <em>or</em> name</li>
<li>but Parrot fills them opposite from how Perl 6 would expect; it chooses the positional argument over the named one.</li>
</ul>

<p><strong>Allison:</strong></p>

<ul>
<li>I thought you needed a way to skip over a named parameter in a list</li>
<li>and then fill in its value from the named argument list</li>
<li>or scan the entire named argument list first, and then fill in positional parameters</li>
<li>it sounds like this is different</li>
</ul>

<p><strong>Larry:</strong></p>

<ul>
<li>the compiler should recognize arguments intended as named parameters</li>
<li>it can set up a data structure for efficient access</li>
<li>the other constraint is that any argument can depend on the value of a previous argument in the list</li>
<li>you have to bind them in the order of declaration</li>
<li>you go down the list</li>
<li>for each of them, you look up in the named argument list</li>
<li>to see if it's bound by a name</li>
<li>if not, you take the next one from the positional list</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>that can be lazy</li>
</ul>

<p><strong>Larry:</strong></p>

<ul>
<li>yes</li>
<li>that's the abstract view from the Perl 6 end</li>
<li>one reason we invented prototypes is so that the compiler can know that the first <em>n</em> arguments are positional</li>
<li>map any named arguments into positional without having to do the lookup</li>
<li>that's primarily a sop to efficiency</li>
<li>for a very small number of named arguments, brute force is probably faster</li>
</ul>

<p><strong>Allison:</strong></p>

<ul>
<li>do you never have any parameters which are strictly only positional?</li>
</ul>

<p><strong>Larry:</strong></p>

<ul>
<li>there's no way to write that</li>
<li>other than writing a bare sigil in the declaration</li>
<li>you're not giving it a name</li>
<li>but you can't access it, because it needs a name</li>
</ul>

<p><strong>Allison:</strong></p>

<ul>
<li>sounds like we want three different flags in Parrot</li>
<li>one for a purely-positional argument</li>
</ul>

<p><strong>Larry:</strong></p>

<ul>
<li>the optimizer might use that, if it sees a prototype</li>
</ul>

<p><strong>Allison:</strong></p>

<ul>
<li>we keep the <code>:named</code> flag</li>
<li>for named parameters</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>named-only</li>
</ul>

<p><strong>Allison:</strong></p>

<ul>
<li>we don't really have that</li>
<li>we have named that acts like positional</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>we have named that prefers positional, and then throws an exception if a matching named argument is also supplied</li>
</ul>

<p><strong>Allison:</strong></p>

<ul>
<li>might have four flags then</li>
<li>one that's either named or positional</li>
<li>maybe one that gives priority to the positional</li>
<li>not sure that's useful</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>I couldn't come up with a case where that's useful</li>
</ul>

<p><strong>Larry:</strong></p>

<ul>
<li>some languages want that</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>you can almost simulate that with slurpies in your code</li>
<li>or sticking in dummy arguments</li>
</ul>

<p><strong>Allison:</strong></p>

<ul>
<li>could come in useful if you have optional parameters</li>
<li>you don't have to pass anything at all</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>I proposed what you described as numbers 1, 2, and 4</li>
<li>the existing <code>:named</code> flag is named-only</li>
<li>the <code>:positional</code> flag is a named parameter that accepts positional arguments</li>
</ul>

<p><strong>Allison:</strong></p>

<ul>
<li>I'm trying to get down the ideas</li>
<li>I probably wouldn't use <code>:positional</code> for that</li>
<li>important to get the categories right</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>I couldn't figure out a case where you have a named parameter that prefers the positional over the name</li>
</ul>

<p><strong>Allison:</strong></p>

<ul>
<li>make it a positional and don't worry about it</li>
<li>if you make it positional, you don't have to scan the argument list</li>
</ul>

<p><strong>c:</strong></p>

<ul>
<li>look at Python's default parameter handling</li>
<li>I think it may follow the one case you couldn't figure out</li>
<li>not entirely sure</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>is the answer that Parrot's underlying model will likely change to support what Perl 6 needs?</li>
</ul>

<p><strong>Allison:</strong></p>

<ul>
<li>yes</li>
<li>exact details yet to be determined</li>
<li>as soon as possible so that you can use it</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>it's been the subject of at least five or six RT tickets in the Rakudo queue</li>
<li>they look like different problems, but they call come down to the same problem</li>
<li>it's becoming a pain point</li>
<li>I'm willing to implement it</li>
<li>there are probably three or four related tickets in the Parrot queue</li>
</ul>

<p><strong>Larry:</strong></p>

<ul>
<li>there was a question about writing Pairs various ways as arguments</li>
<li>are they intended to be named arguments or pairs?</li>
<li>how do you write the prototype for <code>list</code>, by the way?</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>I suggested putting colons in front of it</li>
</ul>

<p><strong>Larry:</strong></p>

<ul>
<li>but <code>:a</code> is always a valid term</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>you can always look ahead for a fat arrow</li>
</ul>

<p><strong>Larry:</strong></p>

<ul>
<li>I'd almost rather write <code> :&gt; </code> for that</li>
<li>originally we always used the fat arrow</li>
<li>then we put in the colons</li>
<li>we wanted to use the fat arrow for arguments</li>
<li>people seem to be used to the colon for named arguments, not the fat arrow</li>
<li>maybe we should just bite the bullet</li>
<li>you need the name as the identifier</li>
<li>you don't need the general pair form</li>
<li>the fat arrow makes a Pair not intended for a named argument, unless you do processing on it</li>
<li>that'd be a simplification</li>
<li>you can tell by just looking at it</li>
<li>one is a named argument</li>
<li>the other is just a positional parameter</li>
</ul>

<p><strong>Jerry:</strong></p>

<ul>
<li>is there a method on a Pair that allows it to be passed as a named parameter?</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>prefix vertical bar?</li>
<li>S06 has options for making a Pair a named argument</li>
<li>or a hash as a list of named arguments</li>
</ul>

<p><strong>Larry:</strong></p>

<ul>
<li>we're trying to guess it based on the context of the argument list</li>
<li>if you pass the list to a function call, it assumes you want named arguments</li>
<li>otherwise you don't</li>
<li>that might be guessing too far</li>
<li>the <code>list</code> function might want to parse more like parens</li>
<li>but it behaves like a function</li>
<li>you don't want to pass those as named arguments</li>
<li>how do you tell the compiler that it's special</li>
<li>maybe you want to make it a macro, but that's kind of weird</li>
<li>maybe it's time to look at the cultural issue of how people want to write named arguments</li>
<li>maybe we can simplify that</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>there's a similar issue with the hash constructor</li>
<li>you can kinda get away with it, because order is less important</li>
<li>but it still exists</li>
<li>it'd be interesting to look at the existing tests and Synopses to see the results</li>
<li>there is some historical baggage toward using the fat arrow</li>
</ul>

<p><strong>Larry:</strong></p>

<ul>
<li>the guy who wrote that Synopsis was familiar with Ada's fat arrow for named arguments</li>
</ul>

<p><strong>c:</strong></p>

<ul>
<li>is there some sort of prototype declarator that says "It was an ordered list in the source code, and that's what I want!"</li>
</ul>

<p><strong>Larry:</strong></p>

<ul>
<li>macros are a lot like prototypes</li>
</ul>

<p><strong>Patrick:</strong></p>

<ul>
<li>Rakudo for now will treat them as special in the way that Pugs does</li>
<li>it'll treat <code>list</code> as a macro</li>
<li>do something special, it's not a normal argument list</li>
</ul>
</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

