<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of chromatic: Yeah, This Here's the Problem</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Yeah, This Here's the Problem</h1>
<h2><a href="/user/chromatic/">chromatic</a> on 2003-06-07T00:41:00</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p>If <a href="http://developers.slashdot.org/article.pl?sid=03/06/06/1628211">80% of software developers are brilliant enough to write better code faster, cheaper, and more efficiently than they can reuse existing code</a>, why does software still suck so much?</p>

<p>Me, I'm wearing my dubious pants.</p></p>


<hr/>



<h2>It sucks because ...</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2003-06-07T01:18:06</h3>
<p>Software still sucks because our software design abilities do not grow at the same pace as our hardware design abilities.  We try new things, we experiment, but "engineer" is certainly not a term that is rightfully applied to programmers.  We're some weird amalgam of engineer, artist, and con-artist, all rolled into one.  Personally, I suspect that until we get to the point where we can start offering formal proofs that our programs are correct, we're still going to limp along -- though we'll limp faster all the time.</p>



<blockquote>

<h2>Re:It sucks because ...</h2>
<h3><a href="/user/gav/">gav</a> on 2003-06-07T04:23:21</h3>
<p> <i>I suspect that until we get to the point where we can start offering formal proofs that our programs are correct..</i> </p>
<p>
From what little I remember of my formal methods classes, it's not possible to prove program correctness. <a href="http://www.wikipedia.org/wiki/Halting_problem" title="wikipedia.org">The Halting Problem</a wikipedia.org> </p>
<p>I try not to think too hard about formal methods in case I have another Z Notation triggered flashback.</p>
<p>I think the real gains will come from not treating programming as something done in a vaccum  and working on better management and user involvement.</p>



<blockquote>

<h2>Re:It sucks because ...</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2003-06-07T16:58:53</h3>
<p>There's actually a fair amount of research in functional programming languages such as Haskell about proving program correctness.  While granted, there are certain things which cannot be provably correct (as demonstrated by the Halting Problem), the aim of this research is to either develop formal mathematical proof systems for programs, or to calculate programs from mathematically precise specifications. Unfortunately, G&#195;&#182;del had the cheek to prove that any system that contains basic mathematics can lead to statements that are true, but unproveable, thus ensuring that this research cannot be perfect.</p>

<p>I agree that real gains will most likely come from better management and user involvement, but I suspect that in the next couple of decades we're going to see programming systems evolve that are radically different from what we expect today.  It may simply be different methods of approaching the existing problem or reformulating the problem itself, but I don't think, in the long run, that trying to continually tweak the existing mechanisms is the way to go.  Too often we get issues such as "we have to beat our competitors to the market" or "we don't have sufficient resources" which ensures that taking the time to do things right will often be a secondary consideration.</p>

<p>I think that automated software testing could be one of the new legs of the programming stool (given the caveat that it's been around for a while, but only recently started to hit its stride).  While I have this underlying sense that there's a better way to accomplish testing, I am still astounded at the results I get from testing.  I used to write spaghetti programs that didn't have a terribly huge numbers of defects.  They were pigs to work on, though, and maintenance often added defects.  Since I've really gone gung ho in testing, I've started working on an inventory system which is the largest system that I've worked on (well, I've worked on larger, but only as a maintenance programmer).  When I check our bug tracking database, almost invariably the issues entered in there are changes to the specification.  Actual honest-to-goodness bugs tend to crop up in the presentation layer.  This layer, as we all know, is traditionally the hardest to test.  Those types of bugs are often caught by the QA team and not the programmer.</p>

<p>Again, I have a sense that the testing that I am doing can be done better -- it still seems pretty ad hoc -- but having clearer specifications up front and a test-first environment has led to far superior code for us.  We have a junior programmer whose Perl skills are not up to snuff, but I worked with him to show him how our testing works and he's turning in good, productive code that's better than the code that I've seen more experienced programmers turn in.</p>



<blockquote>

<h2>haskell again</h2>
<h3><a href="/user/educated_foo/">educated_foo</a> on 2003-06-08T14:49:09</h3>
Okay, this is the second comment I've seen here recently mentioning Haskell (in a positive way at that!), in a forum that seems to me to live on the opposite side of the programming language universe.  How many of you (a) have heard of the language, and (b) find it promising/interesting/fun?<p>/s</p>



<blockquote>

<h2>Re:haskell again</h2>
<h3><a href="/user/Ovid/">Ovid</a> on 2003-06-08T15:10:01</h3>
<p>Pardon me for recommending myself<nobr> <wbr></nobr>:), but you can check out <a href="http://www.perlmonks.org/index.pl?node_id=205797" title="perlmonks.org">this thread about functional programming</a perlmonks.org> that I started on Perlmonks.  I give a couple of brief examples in Haskell, though MJD has some far more interesting comments in the thread.</p>

<p>I certainly recommend checking out Haskell.  It's an interesting language, though it's not widely used.</p>



<blockquote>

<h2>Re:haskell again</h2>
<h3><a href="/user/educated_foo/">educated_foo</a> on 2003-06-08T15:56:38</h3>
I've actually spent quite a bit of time playing around in Haskell.  Paul Hudak's <a href="http://haskell.cs.yale.edu/haskore/" title="yale.edu">Haskore</a yale.edu> is a pretty decent MIDI manipulation system, though not as good (IMHO) as <a href="http://ccrma-www.stanford.edu/software/clm/" title="stanford.edu">CLM</a stanford.edu>.  It's conceptually interesting in a sort of Puritan way, and practically interesting (and relevant to Perl 6) in trying to compile laziness efficiently.  But to me it's always been one of these academic languages that's more about itself than about getting anything done.  It's optimized for writing a sexy, intuitive 1-line quicksort.  Want to insert a debug statement?  Try restructuring your entire program to avoid becoming entangled in the IO Monad.  Want to tune a slow application?  Good luck figuring out what's slow.<p><nobr> <wbr></nobr>/s</p>





</blockquote>

</blockquote>


<h2>Re:It sucks because ...</h2>
<h3><a href="/user/jmm/">jmm</a> on 2003-06-09T15:05:20</h3>
<i>While granted, there are certain things which cannot be provably correct (as demonstrated by the Halting Problem), the aim of this research is to either develop formal mathematical proof systems for programs, or to calculate programs from mathematically precise specifications. Unfortunately, G&#195;&#182;del had the cheek to prove that any system that contains basic mathematics can lead to statements that are true, but unproveable, thus ensuring that this research cannot be perfect.</i> <p>
While the Halting Problem and G&#195;&#182;del's Theorem are limitations, they are more of a theoretic problem than a practical one.  A program that is "true but unproveable" is likely to be a spaghetti code action-at-a-distance confusing mass that is also nearly impossible to maintain <b>even if it is correct</b>, so having the program prover give up is a perfectly useful answer.</p><p>
Just because you can write programs that are hard to prove or disprove doesn't mean that such programs are ones that are worth writing.</p><p>
The vast majority of programming tasks do not involve recursive analysis of programs that analyse programs<nobr> <wbr></nobr>...</p><p>
The object is to find a way of writing programs that does not tax the reader, or the program prover, so much that it is hard to demonstrate the program's correctness.</p>





</blockquote>

</blockquote>

</blockquote>


<h2>Slashdot Post Quality++</h2>
<h3><a href="/user/chaoticset/">chaoticset</a> on 2003-06-07T14:59:39</h3>
With this, I can officially say I like Slashdot a little more.
<blockquote><div> <blockquote><div> <tt>Outstanding objects, and they're developed dirt cheap<br>Outstanding objects, and they're developed dirt cheap<br> <br>Functors... serialization... patterns...<br>Developed dirt cheap<br>Regex... templates... iterators...<br>Developed dirt cheap</tt> </div></blockquote> </div></blockquote>
Sadly, I can hear this song in my head, right now, and will probably make some feeble attempt to make up the rest of the lyrics.





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

