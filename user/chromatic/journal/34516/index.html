<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of chromatic: Syntactic Complexity and Implementation Time</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Syntactic Complexity and Implementation Time</h1>
<h2><a href="/user/chromatic/">chromatic</a> on 2007-09-21T19:44:24</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><blockquote><em>The complexity of a languageÃ¢â¬â¢s syntax does matter. As Eric Raymond once wrote, Ã¢â¬ÅRobustness is the child of transparency and simplicityÃ¢â¬Â. Do you for example think itÃ¢â¬â¢s a coincidence that Perl 6 is still not ready for production after six years of development?</em></blockquote>

<p>&mdash; <a href="http://laurentszyster.be/blog/jruby-vs-cpython/#comment-6318">jpersson commenting on a critique of JRuby versus CPython</a></p>

<p>Common Lisp barely has syntax.  Where are all the reliable F/OSS cross-platform CL implementations then?  (Hint: <a href="http://www.oreillynet.com/onlamp/blog/2007/09/squeezing_one_year_of_work_int.html">volunteer effort is cheap, not necessarily fast</a>.)</p></p>


<hr/>



<h2>Notation</h2>
<h3><a href="/user/djberg96/">djberg96</a> on 2007-09-22T03:22:33</h3>
<p><div class="quote">Common Lisp barely has syntax.</div> But people hate the notation. Otherwise, it would be the one, true language. Which, it may yet be.



<blockquote>

<h2>Re:Notation</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2007-09-22T06:23:18</h3>
<p>Do you think the ease of implementation depends on how much people like the notation more than the simplicity of the syntax?  That's an intriguing thought.</p>



<blockquote>

<h2>Re:Notation</h2>
<h3><a href="/user/Alias/">Alias</a> on 2007-09-23T23:54:39</h3>
He may not, but I do.<br><br>The more people like the notation, the more people will be attracted to assisting with the implementation, which should greatly improve the ease of implementation (from the perspective of a project manager at least)...<br><br>The definition of "ease" is highly subjection and subject to misuse though.<br><br>"How long/easy is a piece of string"





</blockquote>

</blockquote>


<h2>False Analogy Alert!</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2007-09-24T01:53:09</h3>
<p><blockquote> <div><i>
Common Lisp barely has syntax. Where are all the reliable F/OSS cross-platform CL implementations then?
</i></div> </blockquote>
chromatic, I understand your frustration with jpersson's comparison, but that does not make your false analogy correct.
<p>
If we start with the premise that "sharp objects are cheap and easy to fabricate", it's a huge leap to ask "where are all of the disposable <a href="http://en.wikipedia.org/wiki/Katana" title="wikipedia.org">samurai swords</a wikipedia.org>?"  In fact, there are very many "disposable sharp objects", but we call them "razor blades", "box cutters" and "toothpicks".
</p><p>
The point here is that <b> <i>Lisp</i> </b> barely has any syntax.  Common Lisp is a Lisp, but that doesn't mean that the 'barely any syntax' attribute necessarily applies to it.  Common Lisp takes Lisp, and adds a lot of features, many of which layer on top of the trivial <i>surface</i> syntax.  So, while it appears that Common Lisp programs are nothing more than well-crafted trees of cons cells, they are in fact much more syntactically rich.  Consider what happens when you add vectors, hashes, macros, MOP, generic functions, and format strings.  The only thing the surface syntax simplifies is the Common Lisp reader function, not the entirety of the implementation.
</p><p>
Nevertheless, you asked for a list of cross platform common lisp implementations, and wikipedia <a href="http://en.wikipedia.org/wiki/Common_Lisp#List_of_implementations" title="wikipedia.org">lists a few</a wikipedia.org>.  Specifically, I draw your attention to SBCL, CMUCL, CLisp, GCL, ECL, OpenMCL, and Armed Bear Common Lisp.  The number of open source implementations of Common Lisp is actually larger than the list of commercial implementations.  We can quibble about their robustness, cross-platform-ness or whatnot, but the fact is that there <i>are</i> multiple open source, cross platform, somewhat interchangeable implementations to choose from.
</p><p>
Again, Common Lisp's simple <i>surface</i> syntax simply obscures the issue.  No implementation of Common Lisp is ideal, which is why there are multiple implementations and no single canonical implementation.  As I said, Common Lisp <i>appears</i> to have a simple syntax, but it doesn't, so it really shouldn't be under discussion anyway.
</p><p>
A better example for your critique would be Scheme, since there are <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)#Implementation" title="wikipedia.org">multiple open source, robust, and cross platform</a wikipedia.org> implementations of Scheme.  Interestingly, nearly all Scheme implementations are open source.  Most are conformant to some community standard or another, usually R5RS, but also R4RS for some of the older projects.
</p><p>
Add all this up, and jpersson's comment does in fact hold up, even if it isn't supported by esr's snarky remark.  Languages with simpler syntax are easier to implement, easier to re-implement, and easier to build to a robust state.  This helps explain why there are multiple implementations of Common Lisp, Scheme, Tcl, Ruby, Python, Make, various XML parsers, XSLT, C and so on, many of which are robust enough for real world use.  This also helps explain why there is effectively only one implementation of languages like Perl, TeX, and perhaps Ada -- these languages are so quirky that it's hard enough to build one complete, robust, open source implementation that no one really wants to build another.  (Even pumpkings assert that Only Perl Can Parse Perl, with all seriousness.)
</p><p>
If Perl6 were less syntactically rich, there <i>would</i> be more implementations of it.  Decades of industry experience back up this assertion, snarky quotes and false analogies aside.  But that's Larry's decision to make, and he's comfortable with syntactic richness, and all of the tradeoffs it brings.  And that should be enough for us.</p>



<blockquote>

<h2>Re:False Analogy Alert!</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-24T03:02:03</h3>
<p><blockquote> <div><p>Consider what happens when you add vectors, hashes, macros, MOP, generic functions, and format strings. The only thing the surface syntax simplifies is the Common Lisp reader function, not the entirety of the implementation.</p></div> </blockquote>

<p>I think that was exactly chromatic&#8217;s point: whether or not the surface syntax is complex is not what makes the entirety of the implementation big and complex. Unlike the Schemes you mention, Perl 6 puts the entirety of the implementation (or nearly) under the syntax umbrella. This means there is no language core to implement sooner than the rest of the system.</p>

<p>So you are correct, but so is chromatic.</p> <p><blockquote> <div><p>(Even pumpkings assert that Only Perl Can Parse Perl, with all seriousness.)</p></div> </blockquote>

<p>Sorry, that doesn&#8217;t support your argument. The fact that only perl can parse Perl is not because Perl&#8217;s syntax is so quirky that implementing a parser would be painfully difficult. It&#8217;s because you cannot parse Perl without executing it.</p>

<p>But not being able to statically reason about code without executing it is not at all exclusive to Perl. F.ex., IDE code completion is never going to be as robust for a language with open, runtime-mutable classes as it is for, say, Java. (Unless the IDE is part of the same VM as the code, and the code is compiled on the fly during editing. I hear there is a language where they do that sort of thing&#8230;)</p>



<blockquote>

<h2>Re:False Analogy Alert!</h2>
<h3><a href="/user/slanning/">slanning</a> on 2007-09-24T09:10:37</h3>
<p><blockquote> <div><i>The fact that only perl can parse Perl is not because Perl&#8217;s syntax is so quirky that implementing a parser would be painfully difficult. It&#8217;s because you cannot parse Perl without executing it.</i></div> </blockquote>
<p>So only <code>perl</code> can execute <code>Perl</code>, then? Why is that?</p>



<blockquote>

<h2>Re:False Analogy Alert!</h2>
<h3><a href="/user/Aristotle/">Aristotle</a> on 2007-09-24T11:05:51</h3>
<p> <em>That</em> is because the language is big and quirky in all sorts of ways, obvious and obscure alike &#8211; much more so than just the surface syntax itself.</p>

<p>But we were talking about surface syntax, so that is beside the point.</p>





</blockquote>

</blockquote>


<h2>Re:False Analogy Alert!</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2007-09-24T17:12:25</h3>
<p><blockquote> <div><em>Languages with simpler syntax are easier to implement, easier to re-implement, and easier to build to a robust state.</em></div> </blockquote>

<p>Aristotle expanded on what I meant, but I still want to push the point of CL.  What does it take to write a CL reasonably competitive with SBCL?  You have to compete with its performance (which likely means targeting architectures directly), or portability, or library support, or getting at least one of those an order of magnitude righter than SBCL.  None of those have anything to do with the syntax.  They don't necessarily have much to do with the semantics, either.  (Even if you could bootstrap a Lisp with support for <code>cons</code>, <code>car</code>, <code>cdr</code>, <code>eval</code>, and I believe <code>cond</code>, you won't get much performance that way.)</p>

<p>Perhaps my analogy was over-broad, but if I wanted to write a robust, cross-platform F/OSS application in CL, my options are few.  If ease of writing a parser for a language were really significant to the difficulty of implementing the language, I would expect to have more options.</p>

<p>(There are probably more LOLCODE compilers than cross-platform F/OSS CL implementations, and LOLCODE has terrible syntax.  Pun intended.)</p>



<blockquote>

<h2>Re:False Analogy Alert!</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2007-09-24T17:53:07</h3>
<p><div class="quote"> <p>What does it take to write a CL reasonably competitive with SBCL?  </p> </div>  <p>A whole heck of a lot.  First, you need to be compliant with <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/cltl2.html" title="cmu.edu">CLTL2</a cmu.edu>, which clocks in at over 1,000 pages.  Then, if you want to make an ANSI Common Lisp implementation, there's additional work to implement the <a href="http://bc.tech.coop/cltl2-ansi.htm" title="tech.coop">diffs</a tech.coop> between the two specs.</p>

<p>By comparison, the original Lisp specification was 2 pages, the original Scheme specification wasn't much bigger.  R4RS and R5RS both clock in at about 50 pages.</p>

<p>All of this gets back to the original point of contention:</p> <p><div class="quote"> <p> <i>Common Lisp barely has syntax.</i> </p> </div>  <p>That assertion is simply untrue.  Common Lisp has <i>plenty</i> of syntax.  It's just that its syntax is quite regular and <i>appears</i> simple on the surface.  </p>

<p>If you were making a point that a language with a truly simple syntax should spawn a plethora of robust, open source implementations, then that assertion seems valid, even though you claim it isn't.  Witness all of the robust open source Scheme implementations available today.  If you want to take it back to the original vision of Lisp (<code>car</code>, <code>cdr</code>, <code>cons</code> and all that), then there are in fact thousands of these implementations produced every year.  They just happen to be better known as "homework assignments" rather than "robust, production-grade open source systems".  They tend to be written and forgotten (like many open source projects) because the language they implement simply isn't very interesting.</p> <p><div class="quote"> <p>Perhaps my analogy was over-broad, but if I wanted to write a robust, cross-platform F/OSS application in CL, my options are few.  If ease of writing a parser for a language were really significant to the difficulty of implementing the language, I would expect to have more options.</p> </div>  <p>Now you're <i>really</i> conflating a whole mess of issues.<nobr> <wbr></nobr>:-)</p>

<p>Common Lisp is not a simple language, even though its roots are in Lisp.  Expecting it to be simple because it is derived from a language with transparently simple syntax is like expecting you to reproduce by mitosis because, at some point in your past, your ancestors were single celled organisms.  Although <i>parts</i> of do you reproduce by mitosis, as an organism, you yourself do not split into two every time you find yourself in a vat of growth media.</p>

<p>You are castigating Common Lisp for being complex, and not having the properties of a simple language.  Common Lisp is complex.  It is not a simple language.  A simple language like plain old vanilla Lisp truly is simple, and has the kind of properties you assert Common Lisp lacks.</p>



<blockquote>

<h2>Re:False Analogy Alert!</h2>
<h3><a href="/user/chromatic/">chromatic</a> on 2007-09-24T21:51:41</h3>
<p><blockquote> <div><em>Common Lisp has</em> plenty <em>of syntax. It's just that its syntax is quite regular and</em> appears <em>simple on the surface.</em></div> </blockquote>

<p>Perhaps we mean different things by syntax.  The way I understood the original comment, syntax means "Things you need to write a parser for."  For CL, that's basically identifying applications, atoms, conses, and symbols, while providing access to the parser for macros and allowing (optionally) a couple of special forms (I <em>think</em> you can provide everything you need if only <code>eval</code> and <code>cond</code> are special forms, but I haven't tried to write a Lisp without <code>eval</code> as a special form).  That makes for a reasonably simple parser.  The code can get more complex if you rewrite the AST into a different execution form (or compile it instead of interpreting it), but <em>parsing</em> Lisp code is almost trivial.</p>

<p>If you mean something different by "syntax", then I see where we're talking past each other.</p>



<blockquote>

<h2>Re:False Analogy Alert!</h2>
<h3><a href="/user/ziggy/">ziggy</a> on 2007-09-25T13:44:26</h3>
<p><div class="quote"> <p>Perhaps we mean different things by syntax.  The way I understood the original comment, syntax means "Things you need to write a parser for."
</p> </div>  <p>No, we mean the same thing.  Lisp is all cons cells and lambdas.  It's a small language, which is why it can be defined in <a href="http://www.technologyreview.com/player/07/01/Hack/1.aspx" title="technologyreview.com">one page of code</a technologyreview.com>.  (I said "two pages of code" before, because Technology Review originally published an annotated version as a centerfold spread).</p>

<p>Common Lisp is not that language.</p>

<p>Common Lisp, for one example, supports macros.  Macros are read by the reader function (the parser), and change its behavior.  Common Lisp also supports modules, which can export macros, and also change the nature of the parser.  Common Lisp also supports both dynamic and lexical binding (depending on the context and usage), which means that a local macro can override a previous definition of a macro of the same name in some situations.</p>

<p>Common Lisp also supports optional static type declarations, which, strictly speaking, a parser could ignore, but realistically speaking, the parser should understand to some degree.  If nothing else, the presence of optional constructs like these only serves to complicate the parser.</p>

<p>Common Lisp also supports a rich set of data structures, like vectors, bit vectors and hashes:</p> <p><blockquote><div><nobr> <wbr></nobr><tt>;; Vectors<br>* (vector 1 2 3)<br> <br>#(1 2 3)<br>* #(4 5 6)<br> <br>#(4 5 6)<br> <br>;; Bit Vectors<br>* #*1101<br> <br>#*1101</tt></div> </blockquote>  <p>Note that the reader syntax <code>#(1 2 3)</code> creates a vector and <code>#*1101</code> creates a bit vector, both specific data structures that generally use an optimized representation and not stored as a simple set of atoms and cons cells.  Note that these values are not atoms, strings or cons cells, and the reader is <i>required</i> to recognize <code>#(...)</code> as a vector and <code>#*...</code> as a bit string.  I don't remember off the top of my head what other reader syntaxes a Common Lisp reader must support, but I seem to remember that the reader is required to allow hooks to recognize new user-defined constructs.  So a reader isn't required to understand a construct like <code>#regex{...}</code>, but IIRC, it <i>is</i> required to allow you to plug in code to recognize that construct.  Which, again, complicates the requirements of a Common Lisp parser.</p>

<p>Hash tables fall into a similar category, but you could argue that functions like <code>(make-hash-table)</code> doesn't require special knowledge in the parser, but you could also argue that an expression like <code>(setf (gethash c 'color) red)</code>, can impact the parser, because <code>setf</code> requires a lookup to find the "<a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node80.html" title="cmu.edu">setf function</a cmu.edu>" to invoke to perform the update.  A friendly Lisp parser would tell you when you're trying to invoke <code>setf</code> on a value known not to have a corresponding setf-function.</p>

<p>I'll grant you that forms like <code>make-hash-table</code> setf-functions don't necessarily <i>require</i> support from the parser, but reader syntax like <code>#(1 2 3)</code> and <code>#*1101</code> do, and macros certainly do.</p> <p><div class="quote"> <p>I <em>think</em> you can provide everything you need if only <code>eval</code> and <code>cond</code> are special forms, but I haven't tried to write a Lisp without <code>eval</code> as a special form.  That makes for a reasonably simple parser.
</p> </div>  <p>
See, this proves my point.  You're conflating "Lisp" with "Common Lisp", and casting aspersions on Common Lisp for not being more like McCarthy's one page of code.
</p>

<p>
A simple Lisp, like Scheme, has a very small number of special forms.  Scheme uses <a href="http://www.federated.com/user/jim/schintro-v14/schintro_17.html#SEC17" title="federated.com">13</a federated.com>:
<code>if</code>, <code>cond</code>, <code>case</code>, <code>and</code>, <code>or</code>, <code>let</code>, <code>letrec</code>, <code>let*</code>, <code>quote</code>, <code>quasiquote</code> and <code>lambda</code>.  If your Scheme supports macros, there's also <code>define-syntax</code>, which supports the creation of more special forms.  Many of those aren't strictly necessary, and could be reduced to about 4 or 5 if memory serves (<code>lambda</code>, <code>cond</code>, <code>quote</code> and <code>let</code>, but don't hold me to that list), and still be a substantially similar language.</p>

<p>As proof that Common Lisp is not a simple lisp, consider the <a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node59.html#SECTION00913000000000000000" title="cmu.edu">24</a cmu.edu> special forms that a Common Lisp implementation supports <i>at a minimum</i>.  This ignores macros, additional reader syntax for things like vectors, and issues like support for setf-functions, among other things.
</p>

<p>One of the nice things about Lisp, though, is that really heinous forms like <code>loop</code> don't need parser support.  They complicate the language from a user's perspective, but not the perspective of the programmer writing the parser (just the perspective of the programmer writing the standard library functions).  You're talking about the Lisp <i>parser</i>, so I won't go down that path.<nobr> <wbr></nobr>:-)</p> <p><div class="quote"> <p>
<em>parsing</em> Lisp code is almost trivial.</p> </div>  <p>True, for certain definitions of "Lisp", that generally exclude Common Lisp.<nobr> <wbr></nobr>:-)</p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

