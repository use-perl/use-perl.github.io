<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>use.perl.org journal of Mark Leighton Fisher: Thoughts on &quot;Composition Is More Important Than Inheritance&quot;</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="/static/css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the
bottom of the topbar */
      }
    </style>
    <link href="/static/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script
src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/static/ico/favicon.ico">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse"
data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/static/img/slashhead.png"/></a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/about/">About</a></li>
              <li><a href="/authors/">Authors</a></li>
              <li><a href="/journals/">Journals</a></li>
              <li><a href="/stories/">Stories</a></li>
            </ul>
            <p class="navbar-text">All the Perl that's Practical to Extract and Report</p>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>



<div class="container">

<div class="row">

<div class="span4">
<h1>Thoughts on &quot;Composition Is More Important Than Inheritance&quot;</h1>
<h2><a href="/user/Mark Leighton Fisher/">Mark Leighton Fisher</a> on 2007-03-02T17:58:24</h2>
</div> <!-- /span4 -->


<div class="span8">
<p><p>First, thanks to all those who responded &ndash; I needed the input to help clarify my thoughts on this topic (<i>see <a href="/user/Mark+Leighton+Fisher/journal/32361">Composition Is More Important Than Inheritance</a> to know what I am babbling about<i>).</p>
<p>My point is that, whenever the subject turns to object-oriented programming, the examples always seem (IMHO) to feature inheritance and inheritance alone. Polymorphism is seen only as a useful side-effect of an inheritance-oriented design, while no attention is paid to (a) encapsulation, the basis for all O-O programming, and (b) other programming paradigms, even those conventionally seen in modern O-O programming like interfaces and allomorphism.</p>
<p>Like I have said, we have many tools in our toolbox, so we need to quit viewing the world as a set of nails to be hammered down. <a href="http://irbseminars.intel-research.net/AlanKayNSF.pdf">Looser coupling through message-passing instead of argument passing</a>, like Alan Kay et.al. have advocated, is one approach likely to bear some exotically useful fruit.  Personally, I have been working through <a href="http://perl.plover.com/">Mark Jason Dominus</a>'s <b>Higher-Order Perl</b>, which reveals how techniques developed by LISP and functional programmers are of use to Perl programmers. For that matter, I was able last week to (manually) apply memoization to a VB6 routine thereby dropping the average execution time of the routine by 90%, so the lessons therein are not limited to Perl programmers.</p>
<p>As far as the software on <a href="http://www.cpan.org/">CPAN</a> goes, I am sure that just like my software, some of the designs could use improvement. However, my CPAN point was that the "things" in the solution domain do not all constitute a single, well-ordered tree (or even a forest of such trees). To me, solution domains instead resemble a mixed area, partly forested (high use of inheritance), but mostly a grassy plain with some trees scattered amongst the grasses. To stretch the metaphor past the breaking point, the methods (pun intended) for feeding horses and cattle (grasses/encapsulation) are necessarily different from the methods used in building country cabins (rule-based systems), which are different yet from the methods for maintaining fish and other water creatures (functional programming) (and so on). CPAN possesses a large subset of the infrastructure needed for building modern-day software, so (IMHO) it resembles the software engineering solution domain.</p>
<p>We have a large software engineering toolkit &ndash; let's use all of it rather than confining ourselves to the hammers and the screwdrivers. One way to explore the toolkit is to learn a language that is specialized for a certain solution domain. For example, it pays to learn regular expressions thoroughly, as no matter what problem domain you write programs for, you will still have to deal with a representation of your data and your program. Regular expressions make many problems in manipulating data&amp;program representations (whether text, AST, or whatever) much more tractable (no surprise to Perl programmers).</p>
<p>Another solution set that is currently hot, Domain-Specific Languages, is actually just <a href="http://www.princeton.edu/user/hos/frs122/precis/kernighan.htm">Little Languages</a> all over again &ndash; DSLs owe much to the Unix Little Language tools YACC, eqn, pic, etc., which themselves owe much to the ease of building little languages when you have tools (like compiler-compilers) for easily building little languages. (YACC and its ilk represent an interesting case of bootstrapping.)</p>
<p>A software engineer's toolbox is so large that you may never explore the whole thing, even over the course of your whole career &ndash; but it pays and pays to explore the tools you need to make your programs faster, better, and cheaper. For example, if you have ever built a program to verify data, whether it is postal addresses, CAD data, or what-have-you, you have probably built some kind of expert system engine inside of the program. (This reminds of the quote about <a href="http://en.wikipedia.org/wiki/Greenspun%27s_Tenth_Rule">every large program having a badly-written Common LISP interpreter inside</a>.)</p>
<p>Inheritance is not the only tool we have when composing programs (although it can be very useful). <a href="http://dev.perl.org/perl6/">Perl 6</a> should be very interesting, as it brings (more of) the benefits of LISP and functional programming to a wider, conventional-syntax-using, audience. (Perl 5 already has closures, anonymous functions, (nearly) first-class-object regexes, along with the other functionality that enabled a not-too-wordy implementation (sic) for <b>Higher-Order Perl</b>.) As far as I know, Perl 6 will bring the most programming paradigms together under one roof of any mainstream language (and it seems to me to have a logical, consistent design to boot).</p>
<p>So, remember as you compose your programs &ndash; there are more notes than inheritance and more chord progressions than polymorphism in your program composition toolbox.</p></p>





</div> <!-- /span8 -->

</div> <!-- row -->
</div> <!-- /container -->



    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

  </body>
</html>

